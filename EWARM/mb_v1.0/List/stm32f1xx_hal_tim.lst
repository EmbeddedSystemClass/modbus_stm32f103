###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  06:16:09 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1 #
#                    xx_HAL_Driver\Src\stm32f1xx_hal_tim.c                    #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F #
#                    1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c" -D               #
#                    USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F103xB -lC  #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    List\" -o "D:\projects\задания от                        #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/Obj\" --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\stm32f1xx_hal_tim.lst                                #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\stm32f1xx_hal_tim.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + Time Base Initialization
      9            *           + Time Base Start
     10            *           + Time Base Start Interruption
     11            *           + Time Base Start DMA
     12            *           + Time Output Compare/PWM Initialization
     13            *           + Time Output Compare/PWM Channel Configuration
     14            *           + Time Output Compare/PWM  Start
     15            *           + Time Output Compare/PWM  Start Interruption
     16            *           + Time Output Compare/PWM Start DMA
     17            *           + Time Input Capture Initialization
     18            *           + Time Input Capture Channel Configuration
     19            *           + Time Input Capture Start
     20            *           + Time Input Capture Start Interruption 
     21            *           + Time Input Capture Start DMA
     22            *           + Time One Pulse Initialization
     23            *           + Time One Pulse Channel Configuration
     24            *           + Time One Pulse Start 
     25            *           + Time Encoder Interface Initialization
     26            *           + Time Encoder Interface Start
     27            *           + Time Encoder Interface Start Interruption
     28            *           + Time Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + Time OCRef clear configuration
     31            *           + Time External Clock configuration
     32            @verbatim
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include:
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output 
     45          
     46                      ##### How to use this driver #####
     47            ==============================================================================
     48              [..]
     49               (#) Initialize the TIM low level resources by implementing the following functions 
     50                   depending from feature used :
     51                     (++) Time Base : HAL_TIM_Base_MspInit()
     52                     (++) Input Capture : HAL_TIM_IC_MspInit()
     53                     (++) Output Compare : HAL_TIM_OC_MspInit()
     54                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     55                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     56                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     57          
     58               (#) Initialize the TIM low level resources :
     59                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     60                  (##) TIM pins configuration
     61                      (+++) Enable the clock for the TIM GPIOs using the following function:
     62                       __HAL_RCC_GPIOx_CLK_ENABLE();
     63                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     64          
     65               (#) The external Clock can be configured, if needed (the default clock is the 
     66                   internal clock from the APBx), using the following function:
     67                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     68                   any start function.
     69          
     70               (#) Configure the TIM in the desired functioning mode using one of the 
     71                 Initialization function of this driver:
     72                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     73                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     74                      Output Compare signal.
     75                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     76                      PWM signal.
     77                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     78                      external signal.
     79                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     80                        in One Pulse Mode.
     81                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     82          
     83               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     84                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     85                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     86                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     87                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     88                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     89                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     90          
     91               (#) The DMA Burst is managed with the two following functions:
     92                   HAL_TIM_DMABurst_WriteStart()
     93                   HAL_TIM_DMABurst_ReadStart()
     94          
     95            @endverbatim
     96            ******************************************************************************
     97            * @attention
     98            *
     99            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    100            *
    101            * Redistribution and use in source and binary forms, with or without modification,
    102            * are permitted provided that the following conditions are met:
    103            *   1. Redistributions of source code must retain the above copyright notice,
    104            *      this list of conditions and the following disclaimer.
    105            *   2. Redistributions in binary form must reproduce the above copyright notice,
    106            *      this list of conditions and the following disclaimer in the documentation
    107            *      and/or other materials provided with the distribution.
    108            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    109            *      may be used to endorse or promote products derived from this software
    110            *      without specific prior written permission.
    111            *
    112            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    113            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    114            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    115            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    116            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    117            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    118            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    119            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    120            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    121            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    122            *
    123            ******************************************************************************
    124            */
    125          
    126          /* Includes ------------------------------------------------------------------*/
    127          #include "stm32f1xx_hal.h"
    128          
    129          /** @addtogroup STM32F1xx_HAL_Driver
    130            * @{
    131            */
    132          
    133          /** @defgroup TIM TIM
    134            * @brief TIM HAL module driver
    135            * @{
    136            */
    137          
    138          #ifdef HAL_TIM_MODULE_ENABLED
    139          
    140          /* Private typedef -----------------------------------------------------------*/
    141          /* Private define ------------------------------------------------------------*/
    142          /* Private macro -------------------------------------------------------------*/
    143          /* Private variables ---------------------------------------------------------*/
    144          /* Private function prototypes -----------------------------------------------*/
    145          /** @defgroup TIM_Private_Functions TIM Private Functions
    146            * @{
    147            */
    148          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    149          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    150          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    151          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    152          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    153                                 uint32_t TIM_ICFilter);
    154          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    155          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    156                                 uint32_t TIM_ICFilter);
    157          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    158                                 uint32_t TIM_ICFilter);
    159          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
    160                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
    161          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t InputTriggerSource);
    162          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    163          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    164          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    165                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    166          
    167          /**
    168            * @}
    169            */
    170          
    171          /* Exported functions ---------------------------------------------------------*/
    172          
    173          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    174            * @{
    175            */
    176          
    177          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    178           *  @brief    Time Base functions 
    179           *
    180          @verbatim 
    181            ==============================================================================
    182                        ##### Time Base functions #####
    183            ==============================================================================
    184            [..]
    185              This section provides functions allowing to:
    186              (+) Initialize and configure the TIM base.
    187              (+) De-initialize the TIM base.
    188              (+) Start the Time Base.
    189              (+) Stop the Time Base.
    190              (+) Start the Time Base and enable interrupt.
    191              (+) Stop the Time Base and disable interrupt.
    192              (+) Start the Time Base and enable DMA transfer.
    193              (+) Stop the Time Base and disable DMA transfer.
    194          
    195          @endverbatim
    196            * @{
    197            */
    198          /**
    199            * @brief  Initializes the TIM Time base Unit according to the specified
    200            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    201            * @param  htim : TIM Base handle
    202            * @retval HAL status
    203            */

   \                                 In section .text, align 2, keep-with-next
    204          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    205          {
   \                     HAL_TIM_Base_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    206            /* Check the TIM handle allocation */
    207            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_Base_Init_0
    208            {
    209              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_Base_Init_1
    210            }
    211          
    212            /* Check the parameters */
    213            assert_param(IS_TIM_INSTANCE(htim->Instance));
    214            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    215            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    216            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    217          
    218            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0:
   \   0000000C   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_Base_Init_2
    219            {
    220              /* Allocate lock resource and initialize it */
    221              htim->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x003C      STRB     R0,[R4, #+60]
    222              
    223              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    224              HAL_TIM_Base_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    225            }
    226          
    227            /* Set the TIM state */
    228            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_2:
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x003D      STRB     R0,[R4, #+61]
    229          
    230            /* Set the Time Base configuration */
    231            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
    232          
    233            /* Initialize the TIM state*/
    234            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x003D      STRB     R0,[R4, #+61]
    235          
    236            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Init_1:
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    237          }
    238          
    239          /**
    240            * @brief  DeInitializes the TIM Base peripheral 
    241            * @param  htim : TIM Base handle
    242            * @retval HAL status
    243            */

   \                                 In section .text, align 2, keep-with-next
    244          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    245          {
   \                     HAL_TIM_Base_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    246            /* Check the parameters */
    247            assert_param(IS_TIM_INSTANCE(htim->Instance));
    248          
    249            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x003D      STRB     R0,[R4, #+61]
    250          
    251            /* Disable the TIM Peripheral Clock */
    252            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    253          
    254            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    255            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    256          
    257            /* Change TIM state */
    258            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x003D      STRB     R0,[R4, #+61]
    259          
    260            /* Release Lock */
    261            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x003C      STRB     R0,[R4, #+60]
    262          
    263            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    264          }
    265          
    266          /**
    267            * @brief  Initializes the TIM Base MSP.
    268            * @param  htim : TIM handle
    269            * @retval None
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    272          {
    273            /* Prevent unused argument(s) compilation warning */
    274            UNUSED(htim);
    275            /* NOTE : This function Should not be modified, when the callback is needed,
    276                      the HAL_TIM_Base_MspInit could be implemented in the user file
    277             */
    278          }
   \                     HAL_TIM_Base_MspInit:
   \   00000000   0x4770             BX       LR               ;; return
    279          
    280          /**
    281            * @brief  DeInitializes TIM Base MSP.
    282            * @param  htim : TIM handle
    283            * @retval None
    284            */

   \                                 In section .text, align 2, keep-with-next
    285          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    286          {
    287            /* Prevent unused argument(s) compilation warning */
    288            UNUSED(htim);
    289            /* NOTE : This function Should not be modified, when the callback is needed,
    290                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    291             */
    292          }
   \                     HAL_TIM_Base_MspDeInit:
   \   00000000   0x4770             BX       LR               ;; return
    293          
    294          
    295          /**
    296            * @brief  Starts the TIM Base generation.
    297            * @param  htim : TIM handle
    298            * @retval HAL status
    299          */

   \                                 In section .text, align 2, keep-with-next
    300          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    301          {
    302            /* Check the parameters */
    303            assert_param(IS_TIM_INSTANCE(htim->Instance));
    304          
    305            /* Set the TIM state */
    306            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Start:
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x103D      STRB     R1,[R0, #+61]
    307          
    308            /* Enable the Peripheral */
    309            __HAL_TIM_ENABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x6011             STR      R1,[R2, #+0]
    310          
    311            /* Change the TIM state*/
    312            htim->State= HAL_TIM_STATE_READY;
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF880 0x103D      STRB     R1,[R0, #+61]
    313          
    314            /* Return function status */
    315            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    316          }
    317          
    318          /**
    319            * @brief  Stops the TIM Base generation.
    320            * @param  htim : TIM handle
    321            * @retval HAL status
    322          */

   \                                 In section .text, align 2, keep-with-next
    323          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    324          {
    325            /* Check the parameters */
    326            assert_param(IS_TIM_INSTANCE(htim->Instance));
    327          
    328            /* Set the TIM state */
    329            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Stop:
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x103D      STRB     R1,[R0, #+61]
    330          
    331            /* Disable the Peripheral */
    332            __HAL_TIM_DISABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x6A09             LDR      R1,[R1, #+32]
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x4211             TST      R1,R2
   \   00000010   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_0
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x6A09             LDR      R1,[R1, #+32]
   \   00000016   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001A   0x4211             TST      R1,R2
   \   0000001C   0xD105             BNE.N    ??HAL_TIM_Base_Stop_0
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6802             LDR      R2,[R0, #+0]
   \   00000028   0x6011             STR      R1,[R2, #+0]
    333          
    334            /* Change the TIM state*/
    335            htim->State= HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0:
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0xF880 0x103D      STRB     R1,[R0, #+61]
    336          
    337            /* Return function status */
    338            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x4770             BX       LR               ;; return
    339          }
    340          
    341          /**
    342            * @brief  Starts the TIM Base generation in interrupt mode.
    343            * @param  htim : TIM handle
    344            * @retval HAL status
    345          */

   \                                 In section .text, align 2, keep-with-next
    346          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    347          {
    348            /* Check the parameters */
    349            assert_param(IS_TIM_INSTANCE(htim->Instance));
    350          
    351             /* Enable the TIM Update interrupt */
    352             __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Start_IT:
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68C9             LDR      R1,[R1, #+12]
   \   00000004   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x60D1             STR      R1,[R2, #+12]
    353          
    354             /* Enable the Peripheral */
    355            __HAL_TIM_ENABLE(htim);
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x6001             STR      R1,[R0, #+0]
    356          
    357            /* Return function status */
    358            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    359          }
    360          
    361          /**
    362            * @brief  Stops the TIM Base generation in interrupt mode.
    363            * @param  htim : TIM handle
    364            * @retval HAL status
    365          */

   \                                 In section .text, align 2, keep-with-next
    366          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    367          {
    368            /* Check the parameters */
    369            assert_param(IS_TIM_INSTANCE(htim->Instance));
    370            /* Disable the TIM Update interrupt */
    371            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Stop_IT:
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68C9             LDR      R1,[R1, #+12]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x60D1             STR      R1,[R2, #+12]
    372          
    373            /* Disable the Peripheral */
    374            __HAL_TIM_DISABLE(htim);
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x6A09             LDR      R1,[R1, #+32]
   \   00000010   0xF241 0x1211      MOVW     R2,#+4369
   \   00000014   0x4211             TST      R1,R2
   \   00000016   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x6A09             LDR      R1,[R1, #+32]
   \   0000001C   0xF240 0x4244      MOVW     R2,#+1092
   \   00000020   0x4211             TST      R1,R2
   \   00000022   0xD105             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x0849             LSRS     R1,R1,#+1
   \   0000002A   0x0049             LSLS     R1,R1,#+1
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    375          
    376            /* Return function status */
    377            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0:
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x4770             BX       LR               ;; return
    378          }
    379          
    380          /**
    381            * @brief  Starts the TIM Base generation in DMA mode.
    382            * @param  htim : TIM handle
    383            * @param  pData : The source Buffer address.
    384            * @param  Length : The length of data to be transferred from memory to peripheral.
    385            * @retval HAL status
    386          */

   \                                 In section .text, align 2, keep-with-next
    387          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    388          {
   \                     HAL_TIM_Base_Start_DMA:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    389            /* Check the parameters */
    390            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    391          
    392            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000004   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_Base_Start_DMA_0
    393            {
    394               return HAL_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE02B             B.N      ??HAL_TIM_Base_Start_DMA_1
    395            }
    396            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_Base_Start_DMA_0:
   \   00000010   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD109             BNE.N    ??HAL_TIM_Base_Start_DMA_2
    397            {
    398              if((pData == 0U) && (Length > 0U))
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD104             BNE.N    ??HAL_TIM_Base_Start_DMA_3
   \   0000001C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD001             BEQ.N    ??HAL_TIM_Base_Start_DMA_3
    399              {
    400                return HAL_ERROR;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE020             B.N      ??HAL_TIM_Base_Start_DMA_1
    401              }
    402              else
    403              {
    404                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_3:
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x003D      STRB     R0,[R4, #+61]
    405              }
    406            }
    407            /* Set the DMA Period elapsed callback */
    408            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_2:
   \   0000002C   0x6A20             LDR      R0,[R4, #+32]
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable15
   \   00000032   0x6283             STR      R3,[R0, #+40]
    409          
    410            /* Set the DMA error callback */
    411            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000034   0x6A20             LDR      R0,[R4, #+32]
   \   00000036   0x.... 0x....      LDR.W    R3,??DataTable15_1
   \   0000003A   0x6303             STR      R3,[R0, #+48]
    412          
    413            /* Enable the DMA channel */
    414            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
   \   0000003C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003E   0x0013             MOVS     R3,R2
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0xF110 0x022C      ADDS     R2,R0,#+44
   \   00000046   0x6A20             LDR      R0,[R4, #+32]
   \   00000048   0x.... 0x....      BL       HAL_DMA_Start_IT
    415          
    416            /* Enable the TIM Update DMA request */
    417            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x68C0             LDR      R0,[R0, #+12]
   \   00000050   0xF44F 0x7180      MOV      R1,#+256
   \   00000054   0x4308             ORRS     R0,R1,R0
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x60C8             STR      R0,[R1, #+12]
    418          
    419            /* Enable the Peripheral */
    420            __HAL_TIM_ENABLE(htim);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x6008             STR      R0,[R1, #+0]
    421          
    422            /* Return function status */
    423            return HAL_OK;
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Start_DMA_1:
   \   00000068   0xBD10             POP      {R4,PC}          ;; return
    424          }
    425          
    426          /**
    427            * @brief  Stops the TIM Base generation in DMA mode.
    428            * @param  htim : TIM handle
    429            * @retval HAL status
    430          */

   \                                 In section .text, align 2, keep-with-next
    431          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    432          {
    433            /* Check the parameters */
    434            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    435          
    436            /* Disable the TIM Update DMA request */
    437            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     HAL_TIM_Base_Stop_DMA:
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68C9             LDR      R1,[R1, #+12]
   \   00000004   0xF431 0x7180      BICS     R1,R1,#0x100
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x60D1             STR      R1,[R2, #+12]
    438          
    439            /* Disable the Peripheral */
    440            __HAL_TIM_DISABLE(htim);
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x6A09             LDR      R1,[R1, #+32]
   \   00000010   0xF241 0x1211      MOVW     R2,#+4369
   \   00000014   0x4211             TST      R1,R2
   \   00000016   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x6A09             LDR      R1,[R1, #+32]
   \   0000001C   0xF240 0x4244      MOVW     R2,#+1092
   \   00000020   0x4211             TST      R1,R2
   \   00000022   0xD105             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x0849             LSRS     R1,R1,#+1
   \   0000002A   0x0049             LSLS     R1,R1,#+1
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x6011             STR      R1,[R2, #+0]
    441          
    442            /* Change the htim state */
    443            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0:
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF880 0x103D      STRB     R1,[R0, #+61]
    444          
    445            /* Return function status */
    446            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4770             BX       LR               ;; return
    447          }
    448          
    449          /**
    450            * @}
    451            */
    452          
    453          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    454           *  @brief    Time Output Compare functions 
    455           *
    456          @verbatim 
    457            ==============================================================================
    458                            ##### Time Output Compare functions #####
    459            ==============================================================================
    460            [..]
    461              This section provides functions allowing to:
    462              (+) Initialize and configure the TIM Output Compare.
    463              (+) De-initialize the TIM Output Compare.
    464              (+) Start the Time Output Compare.
    465              (+) Stop the Time Output Compare.
    466              (+) Start the Time Output Compare and enable interrupt.
    467              (+) Stop the Time Output Compare and disable interrupt.
    468              (+) Start the Time Output Compare and enable DMA transfer.
    469              (+) Stop the Time Output Compare and disable DMA transfer.
    470          
    471          @endverbatim
    472            * @{
    473            */
    474          /**
    475            * @brief  Initializes the TIM Output Compare according to the specified
    476            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    477            * @param  htim : TIM Output Compare handle
    478            * @retval HAL status
    479            */

   \                                 In section .text, align 2, keep-with-next
    480          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    481          {
   \                     HAL_TIM_OC_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    482            /* Check the TIM handle allocation */
    483            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_OC_Init_0
    484            {
    485              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_OC_Init_1
    486            }
    487          
    488            /* Check the parameters */
    489            assert_param(IS_TIM_INSTANCE(htim->Instance));
    490            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    491            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    492            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    493          
    494            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0:
   \   0000000C   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_OC_Init_2
    495            {
    496              /* Allocate lock resource and initialize it */
    497              htim->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x003C      STRB     R0,[R4, #+60]
    498              
    499              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    500              HAL_TIM_OC_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    501            }
    502          
    503            /* Set the TIM state */
    504            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_2:
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x003D      STRB     R0,[R4, #+61]
    505          
    506            /* Init the base time for the Output Compare */
    507            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
    508          
    509            /* Initialize the TIM state*/
    510            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x003D      STRB     R0,[R4, #+61]
    511          
    512            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Init_1:
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    513          }
    514          
    515          /**
    516            * @brief  DeInitializes the TIM peripheral 
    517            * @param  htim : TIM Output Compare handle
    518            * @retval HAL status
    519            */

   \                                 In section .text, align 2, keep-with-next
    520          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    521          {
   \                     HAL_TIM_OC_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    522            /* Check the parameters */
    523            assert_param(IS_TIM_INSTANCE(htim->Instance));
    524          
    525             htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x003D      STRB     R0,[R4, #+61]
    526          
    527            /* Disable the TIM Peripheral Clock */
    528            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    529          
    530            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    531            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    532          
    533            /* Change TIM state */
    534            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x003D      STRB     R0,[R4, #+61]
    535          
    536            /* Release Lock */
    537            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x003C      STRB     R0,[R4, #+60]
    538          
    539            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    540          }
    541          
    542          /**
    543            * @brief  Initializes the TIM Output Compare MSP.
    544            * @param  htim : TIM handle
    545            * @retval None
    546            */

   \                                 In section .text, align 2, keep-with-next
    547          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    548          {
    549            /* Prevent unused argument(s) compilation warning */
    550            UNUSED(htim);
    551            /* NOTE : This function Should not be modified, when the callback is needed,
    552                      the HAL_TIM_OC_MspInit could be implemented in the user file
    553             */
    554          }
   \                     HAL_TIM_OC_MspInit:
   \   00000000   0x4770             BX       LR               ;; return
    555          
    556          /**
    557            * @brief  DeInitializes TIM Output Compare MSP.
    558            * @param  htim : TIM handle
    559            * @retval None
    560            */

   \                                 In section .text, align 2, keep-with-next
    561          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    562          {
    563            /* Prevent unused argument(s) compilation warning */
    564            UNUSED(htim);
    565            /* NOTE : This function Should not be modified, when the callback is needed,
    566                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    567             */
    568          }
   \                     HAL_TIM_OC_MspDeInit:
   \   00000000   0x4770             BX       LR               ;; return
    569          
    570          /**
    571            * @brief  Starts the TIM Output Compare signal generation.
    572            * @param  htim : TIM Output Compare handle 
    573            * @param  Channel : TIM Channel to be enabled
    574            *          This parameter can be one of the following values:
    575            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    576            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    577            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    578            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
    579            * @retval HAL status
    580          */

   \                                 In section .text, align 2, keep-with-next
    581          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    582          {
   \                     HAL_TIM_OC_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    583            /* Check the parameters */
    584            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    585          
    586            /* Enable the Output compare channel */
    587            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
    588          
    589            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD105             BNE.N    ??HAL_TIM_OC_Start_0
    590            {
    591              /* Enable the main output */
    592              __HAL_TIM_MOE_ENABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6C40             LDR      R0,[R0, #+68]
   \   0000001A   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6448             STR      R0,[R1, #+68]
    593            }
    594          
    595            /* Enable the Peripheral */
    596            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_0:
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    597          
    598            /* Return function status */
    599            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    600          }
    601          
    602          /**
    603            * @brief  Stops the TIM Output Compare signal generation.
    604            * @param  htim : TIM handle
    605            * @param  Channel : TIM Channel to be disabled
    606            *          This parameter can be one of the following values:
    607            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    608            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    609            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    610            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    611            * @retval HAL status
    612          */

   \                                 In section .text, align 2, keep-with-next
    613          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    614          {
   \                     HAL_TIM_OC_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    615            /* Check the parameters */
    616            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    617          
    618            /* Disable the Output compare channel */
    619            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
    620          
    621            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD111             BNE.N    ??HAL_TIM_OC_Stop_0
    622            {
    623              /* Disable the Main Ouput */
    624              __HAL_TIM_MOE_DISABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_1
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6A00             LDR      R0,[R0, #+32]
   \   00000026   0xF240 0x4144      MOVW     R1,#+1092
   \   0000002A   0x4208             TST      R0,R1
   \   0000002C   0xD105             BNE.N    ??HAL_TIM_OC_Stop_1
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6C40             LDR      R0,[R0, #+68]
   \   00000032   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x6448             STR      R0,[R1, #+68]
    625            }
    626          
    627            /* Disable the Peripheral */
    628            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_1:
   \                     ??HAL_TIM_OC_Stop_0:
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6A00             LDR      R0,[R0, #+32]
   \   0000003E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000042   0x4208             TST      R0,R1
   \   00000044   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_2
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6A00             LDR      R0,[R0, #+32]
   \   0000004A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000004E   0x4208             TST      R0,R1
   \   00000050   0xD105             BNE.N    ??HAL_TIM_OC_Stop_2
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x0840             LSRS     R0,R0,#+1
   \   00000058   0x0040             LSLS     R0,R0,#+1
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    629          
    630            /* Return function status */
    631            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_2:
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
    632          }
    633          
    634          /**
    635            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    636            * @param  htim : TIM OC handle
    637            * @param  Channel : TIM Channel to be enabled
    638            *          This parameter can be one of the following values:
    639            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    640            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    641            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    642            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    643            * @retval HAL status
    644          */

   \                                 In section .text, align 2, keep-with-next
    645          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    646          {
   \                     HAL_TIM_OC_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    647            /* Check the parameters */
    648            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    649          
    650            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_OC_Start_IT_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_OC_Start_IT_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_OC_Start_IT_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_OC_Start_IT_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_OC_Start_IT_4
    651            {
    652              case TIM_CHANNEL_1:
    653              {
    654                /* Enable the TIM Capture/Compare 1 interrupt */
    655                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
    656              }
    657              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_OC_Start_IT_5
    658          
    659              case TIM_CHANNEL_2:
    660              {
    661                /* Enable the TIM Capture/Compare 2 interrupt */
    662                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
    663              }
    664              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_OC_Start_IT_5
    665          
    666              case TIM_CHANNEL_3:
    667              {
    668                /* Enable the TIM Capture/Compare 3 interrupt */
    669                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
    670              }
    671              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_OC_Start_IT_5
    672          
    673              case TIM_CHANNEL_4:
    674              {
    675                /* Enable the TIM Capture/Compare 4 interrupt */
    676                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
    677              }
    678              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_OC_Start_IT_5
    679          
    680              default:
    681              break;
    682            }
    683          
    684            /* Enable the Output compare channel */
    685            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_4:
   \                     ??HAL_TIM_OC_Start_IT_5:
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
    686          
    687            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD105             BNE.N    ??HAL_TIM_OC_Start_IT_6
    688            {
    689              /* Enable the main output */
    690              __HAL_TIM_MOE_ENABLE(htim);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6C40             LDR      R0,[R0, #+68]
   \   00000066   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x6448             STR      R0,[R1, #+68]
    691            }
    692          
    693            /* Enable the Peripheral */
    694            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_IT_6:
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x6008             STR      R0,[R1, #+0]
    695          
    696            /* Return function status */
    697            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
    698          }
    699          
    700          /**
    701            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    702            * @param  htim : TIM Output Compare handle
    703            * @param  Channel : TIM Channel to be disabled
    704            *          This parameter can be one of the following values:
    705            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    706            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    707            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    708            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    709            * @retval HAL status
    710          */

   \                                 In section .text, align 2, keep-with-next
    711          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    712          {
   \                     HAL_TIM_OC_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    713            /* Check the parameters */
    714            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    715          
    716            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_IT_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_IT_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_OC_Stop_IT_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_OC_Stop_IT_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_OC_Stop_IT_4
    717            {
    718              case TIM_CHANNEL_1:
    719              {
    720                /* Disable the TIM Capture/Compare 1 interrupt */
    721                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
    722              }
    723              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_OC_Stop_IT_5
    724          
    725              case TIM_CHANNEL_2:
    726              {
    727                /* Disable the TIM Capture/Compare 2 interrupt */
    728                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
    729              }
    730              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_OC_Stop_IT_5
    731          
    732              case TIM_CHANNEL_3:
    733              {
    734                /* Disable the TIM Capture/Compare 3 interrupt */
    735                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
    736              }
    737              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_OC_Stop_IT_5
    738          
    739              case TIM_CHANNEL_4:
    740              {
    741                /* Disable the TIM Capture/Compare 4 interrupt */
    742                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
    743              }
    744              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_OC_Stop_IT_5
    745          
    746              default:
    747              break;
    748            }
    749          
    750            /* Disable the Output compare channel */
    751            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_IT_4:
   \                     ??HAL_TIM_OC_Stop_IT_5:
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
    752          
    753            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD111             BNE.N    ??HAL_TIM_OC_Stop_IT_6
    754            {
    755              /* Disable the Main Ouput */
    756              __HAL_TIM_MOE_DISABLE(htim);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6A00             LDR      R0,[R0, #+32]
   \   00000066   0xF241 0x1111      MOVW     R1,#+4369
   \   0000006A   0x4208             TST      R0,R1
   \   0000006C   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_IT_7
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6A00             LDR      R0,[R0, #+32]
   \   00000072   0xF240 0x4144      MOVW     R1,#+1092
   \   00000076   0x4208             TST      R0,R1
   \   00000078   0xD105             BNE.N    ??HAL_TIM_OC_Stop_IT_7
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6C40             LDR      R0,[R0, #+68]
   \   0000007E   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6448             STR      R0,[R1, #+68]
    757            }
    758          
    759            /* Disable the Peripheral */
    760            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_IT_7:
   \                     ??HAL_TIM_OC_Stop_IT_6:
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6A00             LDR      R0,[R0, #+32]
   \   0000008A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000008E   0x4208             TST      R0,R1
   \   00000090   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_IT_8
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6A00             LDR      R0,[R0, #+32]
   \   00000096   0xF240 0x4144      MOVW     R1,#+1092
   \   0000009A   0x4208             TST      R0,R1
   \   0000009C   0xD105             BNE.N    ??HAL_TIM_OC_Stop_IT_8
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x0840             LSRS     R0,R0,#+1
   \   000000A4   0x0040             LSLS     R0,R0,#+1
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    761          
    762            /* Return function status */
    763            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_8:
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xBD10             POP      {R4,PC}          ;; return
    764          }
    765          
    766          /**
    767            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    768            * @param  htim : TIM Output Compare handle
    769            * @param  Channel : TIM Channel to be enabled
    770            *          This parameter can be one of the following values:
    771            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    772            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    773            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    774            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    775            * @param  pData : The source Buffer address.
    776            * @param  Length : The length of data to be transferred from memory to TIM peripheral
    777            * @retval HAL status
    778          */

   \                                 In section .text, align 2, keep-with-next
    779          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    780          {
   \                     HAL_TIM_OC_Start_DMA:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0011             MOVS     R1,R2
    781            /* Check the parameters */
    782            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    783          
    784            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_0
    785            {
    786               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE087             B.N      ??HAL_TIM_OC_Start_DMA_1
    787            }
    788            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_OC_Start_DMA_0:
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD109             BNE.N    ??HAL_TIM_OC_Start_DMA_2
    789            {
    790              if(((uint32_t)pData == 0U) && (Length > 0U))
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD104             BNE.N    ??HAL_TIM_OC_Start_DMA_3
   \   00000020   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_3
    791              {
    792                return HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE07C             B.N      ??HAL_TIM_OC_Start_DMA_1
    793              }
    794              else
    795              {
    796                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_3:
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x003D      STRB     R0,[R4, #+61]
    797              }
    798            }
    799            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_2:
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD006             BEQ.N    ??HAL_TIM_OC_Start_DMA_4
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xD01B             BEQ.N    ??HAL_TIM_OC_Start_DMA_5
   \   0000003A   0x2808             CMP      R0,#+8
   \   0000003C   0xD02F             BEQ.N    ??HAL_TIM_OC_Start_DMA_6
   \   0000003E   0x280C             CMP      R0,#+12
   \   00000040   0xD043             BEQ.N    ??HAL_TIM_OC_Start_DMA_7
   \   00000042   0xE058             B.N      ??HAL_TIM_OC_Start_DMA_8
    800            {
    801              case TIM_CHANNEL_1:
    802              {
    803                /* Set the DMA Period elapsed callback */
    804                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4:
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable18
   \   0000004A   0x6282             STR      R2,[R0, #+40]
    805          
    806                /* Set the DMA error callback */
    807                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000004C   0x6A60             LDR      R0,[R4, #+36]
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \   00000052   0x6302             STR      R2,[R0, #+48]
    808          
    809                /* Enable the DMA channel */
    810                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000054   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0xF110 0x0234      ADDS     R2,R0,#+52
   \   0000005C   0x6A60             LDR      R0,[R4, #+36]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Start_IT
    811          
    812                /* Enable the TIM Capture/Compare 1 DMA request */
    813                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x68C0             LDR      R0,[R0, #+12]
   \   00000066   0xF44F 0x7100      MOV      R1,#+512
   \   0000006A   0x4308             ORRS     R0,R1,R0
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x60C8             STR      R0,[R1, #+12]
    814              }
    815              break;
   \   00000070   0xE041             B.N      ??HAL_TIM_OC_Start_DMA_9
    816          
    817              case TIM_CHANNEL_2:
    818              {
    819                /* Set the DMA Period elapsed callback */
    820                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5:
   \   00000072   0x6AA0             LDR      R0,[R4, #+40]
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable18
   \   00000078   0x6282             STR      R2,[R0, #+40]
    821          
    822                /* Set the DMA error callback */
    823                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   0000007A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \   00000080   0x6302             STR      R2,[R0, #+48]
    824          
    825                /* Enable the DMA channel */
    826                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000082   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0xF110 0x0238      ADDS     R2,R0,#+56
   \   0000008A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008C   0x.... 0x....      BL       HAL_DMA_Start_IT
    827          
    828                /* Enable the TIM Capture/Compare 2 DMA request */
    829                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x68C0             LDR      R0,[R0, #+12]
   \   00000094   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x60C8             STR      R0,[R1, #+12]
    830              }
    831              break;
   \   0000009C   0xE02B             B.N      ??HAL_TIM_OC_Start_DMA_9
    832          
    833              case TIM_CHANNEL_3:
    834              {
    835                /* Set the DMA Period elapsed callback */
    836                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_6:
   \   0000009E   0x6AE0             LDR      R0,[R4, #+44]
   \   000000A0   0x.... 0x....      LDR.W    R2,??DataTable18
   \   000000A4   0x6282             STR      R2,[R0, #+40]
    837          
    838                /* Set the DMA error callback */
    839                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000A6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000A8   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \   000000AC   0x6302             STR      R2,[R0, #+48]
    840          
    841                /* Enable the DMA channel */
    842                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000AE   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0xF110 0x023C      ADDS     R2,R0,#+60
   \   000000B6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B8   0x.... 0x....      BL       HAL_DMA_Start_IT
    843          
    844                /* Enable the TIM Capture/Compare 3 DMA request */
    845                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x68C0             LDR      R0,[R0, #+12]
   \   000000C0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x60C8             STR      R0,[R1, #+12]
    846              }
    847              break;
   \   000000C8   0xE015             B.N      ??HAL_TIM_OC_Start_DMA_9
    848          
    849              case TIM_CHANNEL_4:
    850              {
    851               /* Set the DMA Period elapsed callback */
    852                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_7:
   \   000000CA   0x6B20             LDR      R0,[R4, #+48]
   \   000000CC   0x.... 0x....      LDR.W    R2,??DataTable18
   \   000000D0   0x6282             STR      R2,[R0, #+40]
    853          
    854                /* Set the DMA error callback */
    855                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000D2   0x6B20             LDR      R0,[R4, #+48]
   \   000000D4   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \   000000D8   0x6302             STR      R2,[R0, #+48]
    856          
    857                /* Enable the DMA channel */
    858                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000DA   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0xF110 0x0240      ADDS     R2,R0,#+64
   \   000000E2   0x6B20             LDR      R0,[R4, #+48]
   \   000000E4   0x.... 0x....      BL       HAL_DMA_Start_IT
    859          
    860                /* Enable the TIM Capture/Compare 4 DMA request */
    861                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x68C0             LDR      R0,[R0, #+12]
   \   000000EC   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000F0   0x6821             LDR      R1,[R4, #+0]
   \   000000F2   0x60C8             STR      R0,[R1, #+12]
    862              }
    863              break;
   \   000000F4   0xE7FF             B.N      ??HAL_TIM_OC_Start_DMA_9
    864          
    865              default:
    866              break;
    867            }
    868          
    869            /* Enable the Output compare channel */
    870            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_8:
   \                     ??HAL_TIM_OC_Start_DMA_9:
   \   000000F6   0x2201             MOVS     R2,#+1
   \   000000F8   0x0029             MOVS     R1,R5
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x.... 0x....      BL       TIM_CCxChannelCmd
    871          
    872            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   00000106   0x4288             CMP      R0,R1
   \   00000108   0xD105             BNE.N    ??HAL_TIM_OC_Start_DMA_10
    873            {
    874              /* Enable the main output */
    875              __HAL_TIM_MOE_ENABLE(htim);
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6C40             LDR      R0,[R0, #+68]
   \   0000010E   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000112   0x6821             LDR      R1,[R4, #+0]
   \   00000114   0x6448             STR      R0,[R1, #+68]
    876            }
    877          
    878            /* Enable the Peripheral */
    879            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_DMA_10:
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000011E   0x6821             LDR      R1,[R4, #+0]
   \   00000120   0x6008             STR      R0,[R1, #+0]
    880          
    881            /* Return function status */
    882            return HAL_OK;
   \   00000122   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_1:
   \   00000124   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    883          }
    884          
    885          /**
    886            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    887            * @param  htim : TIM Output Compare handle
    888            * @param  Channel : TIM Channel to be disabled
    889            *          This parameter can be one of the following values:
    890            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    891            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    892            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    893            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    894            * @retval HAL status
    895          */

   \                                 In section .text, align 2, keep-with-next
    896          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    897          {
   \                     HAL_TIM_OC_Stop_DMA:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    898            /* Check the parameters */
    899            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    900          
    901            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_DMA_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_DMA_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_OC_Stop_DMA_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_OC_Stop_DMA_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_OC_Stop_DMA_4
    902            {
    903              case TIM_CHANNEL_1:
    904              {
    905                /* Disable the TIM Capture/Compare 1 DMA request */
    906                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
    907              }
    908              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_OC_Stop_DMA_5
    909          
    910              case TIM_CHANNEL_2:
    911              {
    912                /* Disable the TIM Capture/Compare 2 DMA request */
    913                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
    914              }
    915              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_OC_Stop_DMA_5
    916          
    917              case TIM_CHANNEL_3:
    918              {
    919                /* Disable the TIM Capture/Compare 3 DMA request */
    920                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
    921              }
    922              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_OC_Stop_DMA_5
    923          
    924              case TIM_CHANNEL_4:
    925              {
    926                /* Disable the TIM Capture/Compare 4 interrupt */
    927                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
    928              }
    929              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_OC_Stop_DMA_5
    930          
    931              default:
    932              break;
    933            }
    934          
    935            /* Disable the Output compare channel */
    936            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4:
   \                     ??HAL_TIM_OC_Stop_DMA_5:
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
    937          
    938            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD111             BNE.N    ??HAL_TIM_OC_Stop_DMA_6
    939            {
    940              /* Disable the Main Ouput */
    941              __HAL_TIM_MOE_DISABLE(htim);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6A00             LDR      R0,[R0, #+32]
   \   00000066   0xF241 0x1111      MOVW     R1,#+4369
   \   0000006A   0x4208             TST      R0,R1
   \   0000006C   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_DMA_7
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6A00             LDR      R0,[R0, #+32]
   \   00000072   0xF240 0x4144      MOVW     R1,#+1092
   \   00000076   0x4208             TST      R0,R1
   \   00000078   0xD105             BNE.N    ??HAL_TIM_OC_Stop_DMA_7
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6C40             LDR      R0,[R0, #+68]
   \   0000007E   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6448             STR      R0,[R1, #+68]
    942            }
    943          
    944            /* Disable the Peripheral */
    945            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_DMA_7:
   \                     ??HAL_TIM_OC_Stop_DMA_6:
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6A00             LDR      R0,[R0, #+32]
   \   0000008A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000008E   0x4208             TST      R0,R1
   \   00000090   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_DMA_8
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6A00             LDR      R0,[R0, #+32]
   \   00000096   0xF240 0x4144      MOVW     R1,#+1092
   \   0000009A   0x4208             TST      R0,R1
   \   0000009C   0xD105             BNE.N    ??HAL_TIM_OC_Stop_DMA_8
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x0840             LSRS     R0,R0,#+1
   \   000000A4   0x0040             LSLS     R0,R0,#+1
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    946          
    947            /* Change the htim state */
    948            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_8:
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xF884 0x003D      STRB     R0,[R4, #+61]
    949          
    950            /* Return function status */
    951            return HAL_OK;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xBD10             POP      {R4,PC}          ;; return
    952          }
    953          
    954          /**
    955            * @}
    956            */
    957          
    958          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    959           *  @brief    Time PWM functions 
    960           *
    961          @verbatim 
    962            ==============================================================================
    963                                    ##### Time PWM functions #####
    964            ==============================================================================
    965            [..]
    966              This section provides functions allowing to:
    967              (+) Initialize and configure the TIM PWM.
    968              (+) De-initialize the TIM PWM.
    969              (+) Start the Time PWM.
    970              (+) Stop the Time PWM.
    971              (+) Start the Time PWM and enable interrupt.
    972              (+) Stop the Time PWM and disable interrupt.
    973              (+) Start the Time PWM and enable DMA transfer.
    974              (+) Stop the Time PWM and disable DMA transfer.
    975          
    976          @endverbatim
    977            * @{
    978            */
    979          /**
    980            * @brief  Initializes the TIM PWM Time Base according to the specified
    981            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    982            * @param  htim : TIM handle
    983            * @retval HAL status
    984            */

   \                                 In section .text, align 2, keep-with-next
    985          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
    986          {
   \                     HAL_TIM_PWM_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    987            /* Check the TIM handle allocation */
    988            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_PWM_Init_0
    989            {
    990              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_PWM_Init_1
    991            }
    992          
    993            /* Check the parameters */
    994            assert_param(IS_TIM_INSTANCE(htim->Instance));
    995            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    996            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    997            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    998          
    999            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0:
   \   0000000C   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_PWM_Init_2
   1000            {
   1001              /* Allocate lock resource and initialize it */
   1002              htim->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x003C      STRB     R0,[R4, #+60]
   1003              
   1004              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1005              HAL_TIM_PWM_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
   1006            }
   1007          
   1008            /* Set the TIM state */
   1009            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Init_2:
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x003D      STRB     R0,[R4, #+61]
   1010          
   1011            /* Init the base time for the PWM */
   1012            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
   1013          
   1014            /* Initialize the TIM state*/
   1015            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x003D      STRB     R0,[R4, #+61]
   1016          
   1017            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Init_1:
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1018          }
   1019          
   1020          /**
   1021            * @brief  DeInitializes the TIM peripheral 
   1022            * @param  htim : TIM handle
   1023            * @retval HAL status
   1024            */

   \                                 In section .text, align 2, keep-with-next
   1025          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1026          {
   \                     HAL_TIM_PWM_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1027            /* Check the parameters */
   1028            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1029          
   1030            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x003D      STRB     R0,[R4, #+61]
   1031          
   1032            /* Disable the TIM Peripheral Clock */
   1033            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1034          
   1035            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1036            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1037          
   1038            /* Change TIM state */
   1039            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x003D      STRB     R0,[R4, #+61]
   1040          
   1041            /* Release Lock */
   1042            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x003C      STRB     R0,[R4, #+60]
   1043          
   1044            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   1045          }
   1046          
   1047          /**
   1048            * @brief  Initializes the TIM PWM MSP.
   1049            * @param  htim : TIM handle
   1050            * @retval None
   1051            */

   \                                 In section .text, align 2, keep-with-next
   1052          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1053          {
   1054            /* Prevent unused argument(s) compilation warning */
   1055            UNUSED(htim);
   1056            /* NOTE : This function Should not be modified, when the callback is needed,
   1057                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1058             */
   1059          }
   \                     HAL_TIM_PWM_MspInit:
   \   00000000   0x4770             BX       LR               ;; return
   1060          
   1061          /**
   1062            * @brief  DeInitializes TIM PWM MSP.
   1063            * @param  htim : TIM handle
   1064            * @retval None
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1067          {
   1068            /* Prevent unused argument(s) compilation warning */
   1069            UNUSED(htim);
   1070            /* NOTE : This function Should not be modified, when the callback is needed,
   1071                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1072             */
   1073          }
   \                     HAL_TIM_PWM_MspDeInit:
   \   00000000   0x4770             BX       LR               ;; return
   1074          
   1075          /**
   1076            * @brief  Starts the PWM signal generation.
   1077            * @param  htim : TIM handle
   1078            * @param  Channel : TIM Channels to be enabled
   1079            *          This parameter can be one of the following values:
   1080            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1081            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1082            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1083            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1084            * @retval HAL status
   1085          */

   \                                 In section .text, align 2, keep-with-next
   1086          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1087          {
   \                     HAL_TIM_PWM_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1088            /* Check the parameters */
   1089            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1090          
   1091            /* Enable the Capture compare channel */
   1092            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1093          
   1094            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD105             BNE.N    ??HAL_TIM_PWM_Start_0
   1095            {
   1096              /* Enable the main output */
   1097              __HAL_TIM_MOE_ENABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6C40             LDR      R0,[R0, #+68]
   \   0000001A   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6448             STR      R0,[R1, #+68]
   1098            }
   1099          
   1100            /* Enable the Peripheral */
   1101            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_0:
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1102          
   1103            /* Return function status */
   1104            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1105          }
   1106          
   1107          /**
   1108            * @brief  Stops the PWM signal generation.
   1109            * @param  htim : TIM handle
   1110            * @param  Channel : TIM Channels to be disabled
   1111            *          This parameter can be one of the following values:
   1112            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1113            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1114            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1115            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1116            * @retval HAL status
   1117          */

   \                                 In section .text, align 2, keep-with-next
   1118          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1119          {
   \                     HAL_TIM_PWM_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1120            /* Check the parameters */
   1121            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1122          
   1123            /* Disable the Capture compare channel */
   1124            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1125          
   1126            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD111             BNE.N    ??HAL_TIM_PWM_Stop_0
   1127            {
   1128              /* Disable the Main Ouput */
   1129              __HAL_TIM_MOE_DISABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_1
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6A00             LDR      R0,[R0, #+32]
   \   00000026   0xF240 0x4144      MOVW     R1,#+1092
   \   0000002A   0x4208             TST      R0,R1
   \   0000002C   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_1
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6C40             LDR      R0,[R0, #+68]
   \   00000032   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x6448             STR      R0,[R1, #+68]
   1130            }
   1131          
   1132            /* Disable the Peripheral */
   1133            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_1:
   \                     ??HAL_TIM_PWM_Stop_0:
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6A00             LDR      R0,[R0, #+32]
   \   0000003E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000042   0x4208             TST      R0,R1
   \   00000044   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_2
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6A00             LDR      R0,[R0, #+32]
   \   0000004A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000004E   0x4208             TST      R0,R1
   \   00000050   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_2
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x0840             LSRS     R0,R0,#+1
   \   00000058   0x0040             LSLS     R0,R0,#+1
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   1134          
   1135            /* Change the htim state */
   1136            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_2:
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xF884 0x003D      STRB     R0,[R4, #+61]
   1137          
   1138            /* Return function status */
   1139            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD10             POP      {R4,PC}          ;; return
   1140          }
   1141          
   1142          /**
   1143            * @brief  Starts the PWM signal generation in interrupt mode.
   1144            * @param  htim : TIM handle
   1145            * @param  Channel : TIM Channel to be enabled
   1146            *          This parameter can be one of the following values:
   1147            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1148            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1149            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1150            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1151            * @retval HAL status
   1152          */

   \                                 In section .text, align 2, keep-with-next
   1153          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1154          {
   \                     HAL_TIM_PWM_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1155            /* Check the parameters */
   1156            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1157          
   1158            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_IT_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_PWM_Start_IT_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_PWM_Start_IT_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_PWM_Start_IT_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_PWM_Start_IT_4
   1159            {
   1160              case TIM_CHANNEL_1:
   1161              {
   1162                /* Enable the TIM Capture/Compare 1 interrupt */
   1163                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
   1164              }
   1165              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_PWM_Start_IT_5
   1166          
   1167              case TIM_CHANNEL_2:
   1168              {
   1169                /* Enable the TIM Capture/Compare 2 interrupt */
   1170                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
   1171              }
   1172              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_PWM_Start_IT_5
   1173          
   1174              case TIM_CHANNEL_3:
   1175              {
   1176                /* Enable the TIM Capture/Compare 3 interrupt */
   1177                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
   1178              }
   1179              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_PWM_Start_IT_5
   1180          
   1181              case TIM_CHANNEL_4:
   1182              {
   1183                /* Enable the TIM Capture/Compare 4 interrupt */
   1184                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
   1185              }
   1186              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_PWM_Start_IT_5
   1187          
   1188              default:
   1189              break;
   1190            }
   1191          
   1192            /* Enable the Capture compare channel */
   1193            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_4:
   \                     ??HAL_TIM_PWM_Start_IT_5:
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
   1194          
   1195            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD105             BNE.N    ??HAL_TIM_PWM_Start_IT_6
   1196            {
   1197              /* Enable the main output */
   1198              __HAL_TIM_MOE_ENABLE(htim);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6C40             LDR      R0,[R0, #+68]
   \   00000066   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x6448             STR      R0,[R1, #+68]
   1199            }
   1200          
   1201            /* Enable the Peripheral */
   1202            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_IT_6:
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x6008             STR      R0,[R1, #+0]
   1203          
   1204            /* Return function status */
   1205            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
   1206          }
   1207          
   1208          /**
   1209            * @brief  Stops the PWM signal generation in interrupt mode.
   1210            * @param  htim : TIM handle
   1211            * @param  Channel : TIM Channels to be disabled
   1212            *          This parameter can be one of the following values:
   1213            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1214            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1215            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1216            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1217            * @retval HAL status
   1218          */

   \                                 In section .text, align 2, keep-with-next
   1219          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1220          {
   \                     HAL_TIM_PWM_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1221            /* Check the parameters */
   1222            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1223          
   1224            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_IT_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_IT_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_PWM_Stop_IT_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_PWM_Stop_IT_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1225            {
   1226              case TIM_CHANNEL_1:
   1227              {
   1228                /* Disable the TIM Capture/Compare 1 interrupt */
   1229                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
   1230              }
   1231              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1232          
   1233              case TIM_CHANNEL_2:
   1234              {
   1235                /* Disable the TIM Capture/Compare 2 interrupt */
   1236                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
   1237              }
   1238              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1239          
   1240              case TIM_CHANNEL_3:
   1241              {
   1242                /* Disable the TIM Capture/Compare 3 interrupt */
   1243                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
   1244              }
   1245              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1246          
   1247              case TIM_CHANNEL_4:
   1248              {
   1249                /* Disable the TIM Capture/Compare 4 interrupt */
   1250                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
   1251              }
   1252              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1253          
   1254              default:
   1255              break;
   1256            }
   1257          
   1258            /* Disable the Capture compare channel */
   1259            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_4:
   \                     ??HAL_TIM_PWM_Stop_IT_5:
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
   1260          
   1261            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD111             BNE.N    ??HAL_TIM_PWM_Stop_IT_6
   1262            {
   1263              /* Disable the Main Ouput */
   1264              __HAL_TIM_MOE_DISABLE(htim);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6A00             LDR      R0,[R0, #+32]
   \   00000066   0xF241 0x1111      MOVW     R1,#+4369
   \   0000006A   0x4208             TST      R0,R1
   \   0000006C   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_IT_7
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6A00             LDR      R0,[R0, #+32]
   \   00000072   0xF240 0x4144      MOVW     R1,#+1092
   \   00000076   0x4208             TST      R0,R1
   \   00000078   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_IT_7
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6C40             LDR      R0,[R0, #+68]
   \   0000007E   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6448             STR      R0,[R1, #+68]
   1265            }
   1266          
   1267            /* Disable the Peripheral */
   1268            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_IT_7:
   \                     ??HAL_TIM_PWM_Stop_IT_6:
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6A00             LDR      R0,[R0, #+32]
   \   0000008A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000008E   0x4208             TST      R0,R1
   \   00000090   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_IT_8
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6A00             LDR      R0,[R0, #+32]
   \   00000096   0xF240 0x4144      MOVW     R1,#+1092
   \   0000009A   0x4208             TST      R0,R1
   \   0000009C   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_IT_8
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x0840             LSRS     R0,R0,#+1
   \   000000A4   0x0040             LSLS     R0,R0,#+1
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   1269          
   1270            /* Return function status */
   1271            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_8:
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xBD10             POP      {R4,PC}          ;; return
   1272          }
   1273          
   1274          /**
   1275            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1276            * @param  htim : TIM handle
   1277            * @param  Channel : TIM Channels to be enabled
   1278            *          This parameter can be one of the following values:
   1279            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1280            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1281            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1282            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1283            * @param  pData : The source Buffer address.
   1284            * @param  Length : The length of data to be transferred from memory to TIM peripheral
   1285            * @retval HAL status
   1286          */

   \                                 In section .text, align 2, keep-with-next
   1287          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1288          {
   \                     HAL_TIM_PWM_Start_DMA:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0011             MOVS     R1,R2
   1289            /* Check the parameters */
   1290            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1291          
   1292            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_0
   1293            {
   1294               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE087             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1295            }
   1296            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_PWM_Start_DMA_0:
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD109             BNE.N    ??HAL_TIM_PWM_Start_DMA_2
   1297            {
   1298              if(((uint32_t)pData == 0U) && (Length > 0U))
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD104             BNE.N    ??HAL_TIM_PWM_Start_DMA_3
   \   00000020   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_3
   1299              {
   1300                return HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE07C             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1301              }
   1302              else
   1303              {
   1304                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_3:
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x003D      STRB     R0,[R4, #+61]
   1305              }
   1306            }
   1307            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_2:
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_DMA_4
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xD01B             BEQ.N    ??HAL_TIM_PWM_Start_DMA_5
   \   0000003A   0x2808             CMP      R0,#+8
   \   0000003C   0xD02F             BEQ.N    ??HAL_TIM_PWM_Start_DMA_6
   \   0000003E   0x280C             CMP      R0,#+12
   \   00000040   0xD043             BEQ.N    ??HAL_TIM_PWM_Start_DMA_7
   \   00000042   0xE058             B.N      ??HAL_TIM_PWM_Start_DMA_8
   1308            {
   1309              case TIM_CHANNEL_1:
   1310              {
   1311                /* Set the DMA Period elapsed callback */
   1312                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4:
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable18
   \   0000004A   0x6282             STR      R2,[R0, #+40]
   1313          
   1314                /* Set the DMA error callback */
   1315                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000004C   0x6A60             LDR      R0,[R4, #+36]
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \   00000052   0x6302             STR      R2,[R0, #+48]
   1316          
   1317                /* Enable the DMA channel */
   1318                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000054   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0xF110 0x0234      ADDS     R2,R0,#+52
   \   0000005C   0x6A60             LDR      R0,[R4, #+36]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Start_IT
   1319          
   1320                /* Enable the TIM Capture/Compare 1 DMA request */
   1321                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x68C0             LDR      R0,[R0, #+12]
   \   00000066   0xF44F 0x7100      MOV      R1,#+512
   \   0000006A   0x4308             ORRS     R0,R1,R0
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x60C8             STR      R0,[R1, #+12]
   1322              }
   1323              break;
   \   00000070   0xE041             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1324          
   1325              case TIM_CHANNEL_2:
   1326              {
   1327                /* Set the DMA Period elapsed callback */
   1328                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5:
   \   00000072   0x6AA0             LDR      R0,[R4, #+40]
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable18
   \   00000078   0x6282             STR      R2,[R0, #+40]
   1329          
   1330                /* Set the DMA error callback */
   1331                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   0000007A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000007C   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \   00000080   0x6302             STR      R2,[R0, #+48]
   1332          
   1333                /* Enable the DMA channel */
   1334                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000082   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0xF110 0x0238      ADDS     R2,R0,#+56
   \   0000008A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1335          
   1336                /* Enable the TIM Capture/Compare 2 DMA request */
   1337                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x68C0             LDR      R0,[R0, #+12]
   \   00000094   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x60C8             STR      R0,[R1, #+12]
   1338              }
   1339              break;
   \   0000009C   0xE02B             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1340          
   1341              case TIM_CHANNEL_3:
   1342              {
   1343                /* Set the DMA Period elapsed callback */
   1344                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_6:
   \   0000009E   0x6AE0             LDR      R0,[R4, #+44]
   \   000000A0   0x.... 0x....      LDR.W    R2,??DataTable18
   \   000000A4   0x6282             STR      R2,[R0, #+40]
   1345          
   1346                /* Set the DMA error callback */
   1347                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000A6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000A8   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \   000000AC   0x6302             STR      R2,[R0, #+48]
   1348          
   1349                /* Enable the DMA channel */
   1350                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000AE   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0xF110 0x023C      ADDS     R2,R0,#+60
   \   000000B6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1351          
   1352                /* Enable the TIM Output Capture/Compare 3 request */
   1353                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x68C0             LDR      R0,[R0, #+12]
   \   000000C0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x60C8             STR      R0,[R1, #+12]
   1354              }
   1355              break;
   \   000000C8   0xE015             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1356          
   1357              case TIM_CHANNEL_4:
   1358              {
   1359               /* Set the DMA Period elapsed callback */
   1360                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_7:
   \   000000CA   0x6B20             LDR      R0,[R4, #+48]
   \   000000CC   0x.... 0x....      LDR.W    R2,??DataTable18
   \   000000D0   0x6282             STR      R2,[R0, #+40]
   1361          
   1362                /* Set the DMA error callback */
   1363                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000D2   0x6B20             LDR      R0,[R4, #+48]
   \   000000D4   0x.... 0x....      LDR.W    R2,??DataTable15_1
   \   000000D8   0x6302             STR      R2,[R0, #+48]
   1364          
   1365                /* Enable the DMA channel */
   1366                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000DA   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0xF110 0x0240      ADDS     R2,R0,#+64
   \   000000E2   0x6B20             LDR      R0,[R4, #+48]
   \   000000E4   0x.... 0x....      BL       HAL_DMA_Start_IT
   1367          
   1368                /* Enable the TIM Capture/Compare 4 DMA request */
   1369                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x68C0             LDR      R0,[R0, #+12]
   \   000000EC   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000F0   0x6821             LDR      R1,[R4, #+0]
   \   000000F2   0x60C8             STR      R0,[R1, #+12]
   1370              }
   1371              break;
   \   000000F4   0xE7FF             B.N      ??HAL_TIM_PWM_Start_DMA_9
   1372          
   1373              default:
   1374              break;
   1375            }
   1376          
   1377            /* Enable the Capture compare channel */
   1378            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_8:
   \                     ??HAL_TIM_PWM_Start_DMA_9:
   \   000000F6   0x2201             MOVS     R2,#+1
   \   000000F8   0x0029             MOVS     R1,R5
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x.... 0x....      BL       TIM_CCxChannelCmd
   1379          
   1380            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   00000106   0x4288             CMP      R0,R1
   \   00000108   0xD105             BNE.N    ??HAL_TIM_PWM_Start_DMA_10
   1381            {
   1382              /* Enable the main output */
   1383              __HAL_TIM_MOE_ENABLE(htim);
   \   0000010A   0x6820             LDR      R0,[R4, #+0]
   \   0000010C   0x6C40             LDR      R0,[R0, #+68]
   \   0000010E   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000112   0x6821             LDR      R1,[R4, #+0]
   \   00000114   0x6448             STR      R0,[R1, #+68]
   1384            }
   1385          
   1386            /* Enable the Peripheral */
   1387            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_DMA_10:
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000011E   0x6821             LDR      R1,[R4, #+0]
   \   00000120   0x6008             STR      R0,[R1, #+0]
   1388          
   1389            /* Return function status */
   1390            return HAL_OK;
   \   00000122   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_1:
   \   00000124   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1391          }
   1392          
   1393          /**
   1394            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1395            * @param  htim : TIM handle
   1396            * @param  Channel : TIM Channels to be disabled
   1397            *          This parameter can be one of the following values:
   1398            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1399            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1400            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1401            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1402            * @retval HAL status
   1403          */

   \                                 In section .text, align 2, keep-with-next
   1404          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1405          {
   \                     HAL_TIM_PWM_Stop_DMA:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1406            /* Check the parameters */
   1407            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1408          
   1409            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1410            {
   1411              case TIM_CHANNEL_1:
   1412              {
   1413                /* Disable the TIM Capture/Compare 1 DMA request */
   1414                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
   1415              }
   1416              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1417          
   1418              case TIM_CHANNEL_2:
   1419              {
   1420                /* Disable the TIM Capture/Compare 2 DMA request */
   1421                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
   1422              }
   1423              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1424          
   1425              case TIM_CHANNEL_3:
   1426              {
   1427                /* Disable the TIM Capture/Compare 3 DMA request */
   1428                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
   1429              }
   1430              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1431          
   1432              case TIM_CHANNEL_4:
   1433              {
   1434                /* Disable the TIM Capture/Compare 4 interrupt */
   1435                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
   1436              }
   1437              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1438          
   1439              default:
   1440              break;
   1441            }
   1442          
   1443            /* Disable the Capture compare channel */
   1444            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4:
   \                     ??HAL_TIM_PWM_Stop_DMA_5:
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
   1445          
   1446            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40012c00
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD111             BNE.N    ??HAL_TIM_PWM_Stop_DMA_6
   1447            {
   1448              /* Disable the Main Ouput */
   1449              __HAL_TIM_MOE_DISABLE(htim);
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6A00             LDR      R0,[R0, #+32]
   \   00000066   0xF241 0x1111      MOVW     R1,#+4369
   \   0000006A   0x4208             TST      R0,R1
   \   0000006C   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_DMA_7
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6A00             LDR      R0,[R0, #+32]
   \   00000072   0xF240 0x4144      MOVW     R1,#+1092
   \   00000076   0x4208             TST      R0,R1
   \   00000078   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_DMA_7
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6C40             LDR      R0,[R0, #+68]
   \   0000007E   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6448             STR      R0,[R1, #+68]
   1450            }
   1451          
   1452            /* Disable the Peripheral */
   1453            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_DMA_7:
   \                     ??HAL_TIM_PWM_Stop_DMA_6:
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6A00             LDR      R0,[R0, #+32]
   \   0000008A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000008E   0x4208             TST      R0,R1
   \   00000090   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_DMA_8
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6A00             LDR      R0,[R0, #+32]
   \   00000096   0xF240 0x4144      MOVW     R1,#+1092
   \   0000009A   0x4208             TST      R0,R1
   \   0000009C   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_DMA_8
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x0840             LSRS     R0,R0,#+1
   \   000000A4   0x0040             LSLS     R0,R0,#+1
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   1454          
   1455            /* Change the htim state */
   1456            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_8:
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xF884 0x003D      STRB     R0,[R4, #+61]
   1457          
   1458            /* Return function status */
   1459            return HAL_OK;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xBD10             POP      {R4,PC}          ;; return
   1460          }
   1461          
   1462          /**
   1463            * @}
   1464            */
   1465          
   1466          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1467           *  @brief    Time Input Capture functions 
   1468           *
   1469          @verbatim 
   1470            ==============================================================================
   1471                        ##### Time Input Capture functions #####
   1472            ==============================================================================
   1473           [..]
   1474             This section provides functions allowing to:
   1475             (+) Initialize and configure the TIM Input Capture.
   1476             (+) De-initialize the TIM Input Capture.
   1477             (+) Start the Time Input Capture.
   1478             (+) Stop the Time Input Capture.
   1479             (+) Start the Time Input Capture and enable interrupt.
   1480             (+) Stop the Time Input Capture and disable interrupt.
   1481             (+) Start the Time Input Capture and enable DMA transfer.
   1482             (+) Stop the Time Input Capture and disable DMA transfer.
   1483          
   1484          @endverbatim
   1485            * @{
   1486            */
   1487          /**
   1488            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1489            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1490            * @param  htim : TIM Input Capture handle
   1491            * @retval HAL status
   1492            */

   \                                 In section .text, align 2, keep-with-next
   1493          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1494          {
   \                     HAL_TIM_IC_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1495            /* Check the TIM handle allocation */
   1496            if(htim == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_TIM_IC_Init_0
   1497            {
   1498              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE014             B.N      ??HAL_TIM_IC_Init_1
   1499            }
   1500          
   1501            /* Check the parameters */
   1502            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1503            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1504            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1505            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1506          
   1507            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0:
   \   0000000C   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_TIM_IC_Init_2
   1508            {
   1509              /* Allocate lock resource and initialize it */
   1510              htim->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x003C      STRB     R0,[R4, #+60]
   1511              
   1512              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1513              HAL_TIM_IC_MspInit(htim);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1514            }
   1515          
   1516            /* Set the TIM state */
   1517            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Init_2:
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x003D      STRB     R0,[R4, #+61]
   1518          
   1519            /* Init the base time for the input capture */
   1520            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_Base_SetConfig
   1521          
   1522            /* Initialize the TIM state*/
   1523            htim->State= HAL_TIM_STATE_READY;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x003D      STRB     R0,[R4, #+61]
   1524          
   1525            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Init_1:
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1526          }
   1527          
   1528          /**
   1529            * @brief  DeInitializes the TIM peripheral 
   1530            * @param  htim : TIM Input Capture handle
   1531            * @retval HAL status
   1532            */

   \                                 In section .text, align 2, keep-with-next
   1533          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1534          {
   \                     HAL_TIM_IC_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1535            /* Check the parameters */
   1536            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1537          
   1538            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x003D      STRB     R0,[R4, #+61]
   1539          
   1540            /* Disable the TIM Peripheral Clock */
   1541            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1542          
   1543            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1544            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1545          
   1546            /* Change TIM state */
   1547            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x003D      STRB     R0,[R4, #+61]
   1548          
   1549            /* Release Lock */
   1550            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x003C      STRB     R0,[R4, #+60]
   1551          
   1552            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   1553          }
   1554          
   1555          /**
   1556            * @brief  Initializes the TIM Input Capture MSP.
   1557            * @param  htim : TIM handle
   1558            * @retval None
   1559            */

   \                                 In section .text, align 2, keep-with-next
   1560          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1561          {
   1562            /* Prevent unused argument(s) compilation warning */
   1563            UNUSED(htim);
   1564            /* NOTE : This function Should not be modified, when the callback is needed,
   1565                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1566             */
   1567          }
   \                     HAL_TIM_IC_MspInit:
   \   00000000   0x4770             BX       LR               ;; return
   1568          
   1569          /**
   1570            * @brief  DeInitializes TIM Input Capture MSP.
   1571            * @param  htim : TIM handle
   1572            * @retval None
   1573            */

   \                                 In section .text, align 2, keep-with-next
   1574          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1575          {
   1576            /* Prevent unused argument(s) compilation warning */
   1577            UNUSED(htim);
   1578            /* NOTE : This function Should not be modified, when the callback is needed,
   1579                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1580             */
   1581          }
   \                     HAL_TIM_IC_MspDeInit:
   \   00000000   0x4770             BX       LR               ;; return
   1582          
   1583          /**
   1584            * @brief  Starts the TIM Input Capture measurement.
   1585            * @param  htim : TIM Input Capture handle
   1586            * @param  Channel : TIM Channels to be enabled
   1587            *          This parameter can be one of the following values:
   1588            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1589            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1590            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1591            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1592            * @retval HAL status
   1593          */

   \                                 In section .text, align 2, keep-with-next
   1594          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1595          {
   \                     HAL_TIM_IC_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1596            /* Check the parameters */
   1597            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1598          
   1599            /* Enable the Input Capture channel */
   1600            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1601          
   1602            /* Enable the Peripheral */
   1603            __HAL_TIM_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6008             STR      R0,[R1, #+0]
   1604          
   1605            /* Return function status */
   1606            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   1607          }
   1608          
   1609          /**
   1610            * @brief  Stops the TIM Input Capture measurement.
   1611            * @param  htim : TIM handle
   1612            * @param  Channel : TIM Channels to be disabled
   1613            *          This parameter can be one of the following values:
   1614            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1615            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1616            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1617            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1618            * @retval HAL status
   1619          */

   \                                 In section .text, align 2, keep-with-next
   1620          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1621          {
   \                     HAL_TIM_IC_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1622            /* Check the parameters */
   1623            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1624          
   1625            /* Disable the Input Capture channel */
   1626            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1627          
   1628            /* Disable the Peripheral */
   1629            __HAL_TIM_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6A00             LDR      R0,[R0, #+32]
   \   00000010   0xF241 0x1111      MOVW     R1,#+4369
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6A00             LDR      R0,[R0, #+32]
   \   0000001C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD105             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x0040             LSLS     R0,R0,#+1
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   1630          
   1631            /* Return function status */
   1632            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0:
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   1633          }
   1634          
   1635          /**
   1636            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1637            * @param  htim : TIM Input Capture handle
   1638            * @param  Channel : TIM Channels to be enabled
   1639            *          This parameter can be one of the following values:
   1640            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1641            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1642            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1643            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1644            * @retval HAL status
   1645          */

   \                                 In section .text, align 2, keep-with-next
   1646          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1647          {
   \                     HAL_TIM_IC_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1648            /* Check the parameters */
   1649            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1650          
   1651            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_IC_Start_IT_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_IC_Start_IT_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_IC_Start_IT_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_IC_Start_IT_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_IC_Start_IT_4
   1652            {
   1653              case TIM_CHANNEL_1:
   1654              {
   1655                /* Enable the TIM Capture/Compare 1 interrupt */
   1656                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
   1657              }
   1658              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_IC_Start_IT_5
   1659          
   1660              case TIM_CHANNEL_2:
   1661              {
   1662                /* Enable the TIM Capture/Compare 2 interrupt */
   1663                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
   1664              }
   1665              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_IC_Start_IT_5
   1666          
   1667              case TIM_CHANNEL_3:
   1668              {
   1669                /* Enable the TIM Capture/Compare 3 interrupt */
   1670                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
   1671              }
   1672              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_IC_Start_IT_5
   1673          
   1674              case TIM_CHANNEL_4:
   1675              {
   1676                /* Enable the TIM Capture/Compare 4 interrupt */
   1677                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
   1678              }
   1679              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_IC_Start_IT_5
   1680          
   1681              default:
   1682              break;
   1683            }
   1684            /* Enable the Input Capture channel */
   1685            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_4:
   \                     ??HAL_TIM_IC_Start_IT_5:
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
   1686          
   1687            /* Enable the Peripheral */
   1688            __HAL_TIM_ENABLE(htim);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6008             STR      R0,[R1, #+0]
   1689          
   1690            /* Return function status */
   1691            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD10             POP      {R4,PC}          ;; return
   1692          }
   1693          
   1694          /**
   1695            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1696            * @param  htim : TIM handle
   1697            * @param  Channel : TIM Channels to be disabled
   1698            *          This parameter can be one of the following values:
   1699            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1700            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1701            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1702            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1703            * @retval HAL status
   1704          */

   \                                 In section .text, align 2, keep-with-next
   1705          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1706          {
   \                     HAL_TIM_IC_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1707            /* Check the parameters */
   1708            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1709          
   1710            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_IT_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_IC_Stop_IT_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_IC_Stop_IT_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_IC_Stop_IT_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_IC_Stop_IT_4
   1711            {
   1712              case TIM_CHANNEL_1:
   1713              {
   1714                /* Disable the TIM Capture/Compare 1 interrupt */
   1715                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
   1716              }
   1717              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_IC_Stop_IT_5
   1718          
   1719              case TIM_CHANNEL_2:
   1720              {
   1721                /* Disable the TIM Capture/Compare 2 interrupt */
   1722                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
   1723              }
   1724              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_IC_Stop_IT_5
   1725          
   1726              case TIM_CHANNEL_3:
   1727              {
   1728                /* Disable the TIM Capture/Compare 3 interrupt */
   1729                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
   1730              }
   1731              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_IC_Stop_IT_5
   1732          
   1733              case TIM_CHANNEL_4:
   1734              {
   1735                /* Disable the TIM Capture/Compare 4 interrupt */
   1736                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
   1737              }
   1738              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_IC_Stop_IT_5
   1739          
   1740              default:
   1741              break;
   1742            }
   1743          
   1744            /* Disable the Input Capture channel */
   1745            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_IT_4:
   \                     ??HAL_TIM_IC_Stop_IT_5:
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
   1746          
   1747            /* Disable the Peripheral */
   1748            __HAL_TIM_DISABLE(htim);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6A00             LDR      R0,[R0, #+32]
   \   0000005C   0xF241 0x1111      MOVW     R1,#+4369
   \   00000060   0x4208             TST      R0,R1
   \   00000062   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_IT_6
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6A00             LDR      R0,[R0, #+32]
   \   00000068   0xF240 0x4144      MOVW     R1,#+1092
   \   0000006C   0x4208             TST      R0,R1
   \   0000006E   0xD105             BNE.N    ??HAL_TIM_IC_Stop_IT_6
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0840             LSRS     R0,R0,#+1
   \   00000076   0x0040             LSLS     R0,R0,#+1
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1749          
   1750            /* Return function status */
   1751            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_6:
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
   1752          }
   1753          
   1754          /**
   1755            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   1756            * @param  htim : TIM Input Capture handle
   1757            * @param  Channel : TIM Channels to be enabled
   1758            *          This parameter can be one of the following values:
   1759            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1760            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1761            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1762            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1763            * @param  pData : The destination Buffer address.
   1764            * @param  Length : The length of data to be transferred from TIM peripheral to memory.
   1765            * @retval HAL status
   1766          */

   \                                 In section .text, align 2, keep-with-next
   1767          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1768          {
   \                     HAL_TIM_IC_Start_DMA:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1769            /* Check the parameters */
   1770            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1771            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1772          
   1773            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000006   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_IC_Start_DMA_0
   1774            {
   1775               return HAL_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE07B             B.N      ??HAL_TIM_IC_Start_DMA_1
   1776            }
   1777            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_IC_Start_DMA_0:
   \   00000012   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD109             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   1778            {
   1779              if((pData == 0U) && (Length > 0U))
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD104             BNE.N    ??HAL_TIM_IC_Start_DMA_3
   \   0000001E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_3
   1780              {
   1781                return HAL_ERROR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE070             B.N      ??HAL_TIM_IC_Start_DMA_1
   1782              }
   1783              else
   1784              {
   1785                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_3:
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x003D      STRB     R0,[R4, #+61]
   1786              }
   1787            }
   1788          
   1789            switch (Channel)
   \                     ??HAL_TIM_IC_Start_DMA_2:
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD006             BEQ.N    ??HAL_TIM_IC_Start_DMA_4
   \   00000034   0x2804             CMP      R0,#+4
   \   00000036   0xD01B             BEQ.N    ??HAL_TIM_IC_Start_DMA_5
   \   00000038   0x2808             CMP      R0,#+8
   \   0000003A   0xD02F             BEQ.N    ??HAL_TIM_IC_Start_DMA_6
   \   0000003C   0x280C             CMP      R0,#+12
   \   0000003E   0xD043             BEQ.N    ??HAL_TIM_IC_Start_DMA_7
   \   00000040   0xE057             B.N      ??HAL_TIM_IC_Start_DMA_8
   1790            {
   1791              case TIM_CHANNEL_1:
   1792              {
   1793                /* Set the DMA Period elapsed callback */
   1794                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4:
   \   00000042   0x6A60             LDR      R0,[R4, #+36]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000048   0x6281             STR      R1,[R0, #+40]
   1795          
   1796                /* Set the DMA error callback */
   1797                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000004A   0x6A60             LDR      R0,[R4, #+36]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   00000050   0x6301             STR      R1,[R0, #+48]
   1798          
   1799                /* Enable the DMA channel */
   1800                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
   \   00000052   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0xF110 0x0134      ADDS     R1,R0,#+52
   \   0000005A   0x6A60             LDR      R0,[R4, #+36]
   \   0000005C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1801          
   1802                /* Enable the TIM Capture/Compare 1 DMA request */
   1803                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x68C0             LDR      R0,[R0, #+12]
   \   00000064   0xF44F 0x7100      MOV      R1,#+512
   \   00000068   0x4308             ORRS     R0,R1,R0
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x60C8             STR      R0,[R1, #+12]
   1804              }
   1805              break;
   \   0000006E   0xE040             B.N      ??HAL_TIM_IC_Start_DMA_9
   1806          
   1807              case TIM_CHANNEL_2:
   1808              {
   1809                /* Set the DMA Period elapsed callback */
   1810                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5:
   \   00000070   0x6AA0             LDR      R0,[R4, #+40]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000076   0x6281             STR      R1,[R0, #+40]
   1811          
   1812                /* Set the DMA error callback */
   1813                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000078   0x6AA0             LDR      R0,[R4, #+40]
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   0000007E   0x6301             STR      R1,[R0, #+48]
   1814          
   1815                /* Enable the DMA channel */
   1816                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   \   00000080   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0xF110 0x0138      ADDS     R1,R0,#+56
   \   00000088   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1817          
   1818                /* Enable the TIM Capture/Compare 2  DMA request */
   1819                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x68C0             LDR      R0,[R0, #+12]
   \   00000092   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x60C8             STR      R0,[R1, #+12]
   1820              }
   1821              break;
   \   0000009A   0xE02A             B.N      ??HAL_TIM_IC_Start_DMA_9
   1822          
   1823              case TIM_CHANNEL_3:
   1824              {
   1825                /* Set the DMA Period elapsed callback */
   1826                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6:
   \   0000009C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000A2   0x6281             STR      R1,[R0, #+40]
   1827          
   1828                /* Set the DMA error callback */
   1829                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000A4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   000000AA   0x6301             STR      R1,[R0, #+48]
   1830          
   1831                /* Enable the DMA channel */
   1832                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   \   000000AC   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0xF110 0x013C      ADDS     R1,R0,#+60
   \   000000B4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B6   0x.... 0x....      BL       HAL_DMA_Start_IT
   1833          
   1834                /* Enable the TIM Capture/Compare 3  DMA request */
   1835                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x68C0             LDR      R0,[R0, #+12]
   \   000000BE   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0x60C8             STR      R0,[R1, #+12]
   1836              }
   1837              break;
   \   000000C6   0xE014             B.N      ??HAL_TIM_IC_Start_DMA_9
   1838          
   1839              case TIM_CHANNEL_4:
   1840              {
   1841                /* Set the DMA Period elapsed callback */
   1842                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_7:
   \   000000C8   0x6B20             LDR      R0,[R4, #+48]
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000CE   0x6281             STR      R1,[R0, #+40]
   1843          
   1844                /* Set the DMA error callback */
   1845                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000D0   0x6B20             LDR      R0,[R4, #+48]
   \   000000D2   0x....             LDR.N    R1,??DataTable18_1
   \   000000D4   0x6301             STR      R1,[R0, #+48]
   1846          
   1847                /* Enable the DMA channel */
   1848                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   \   000000D6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0xF110 0x0140      ADDS     R1,R0,#+64
   \   000000DE   0x6B20             LDR      R0,[R4, #+48]
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   1849          
   1850                /* Enable the TIM Capture/Compare 4  DMA request */
   1851                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x68C0             LDR      R0,[R0, #+12]
   \   000000E8   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000EC   0x6821             LDR      R1,[R4, #+0]
   \   000000EE   0x60C8             STR      R0,[R1, #+12]
   1852              }
   1853              break;
   \   000000F0   0xE7FF             B.N      ??HAL_TIM_IC_Start_DMA_9
   1854          
   1855              default:
   1856              break;
   1857            }
   1858          
   1859            /* Enable the Input Capture channel */
   1860            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_8:
   \                     ??HAL_TIM_IC_Start_DMA_9:
   \   000000F2   0x2201             MOVS     R2,#+1
   \   000000F4   0x0029             MOVS     R1,R5
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x.... 0x....      BL       TIM_CCxChannelCmd
   1861          
   1862            /* Enable the Peripheral */
   1863            __HAL_TIM_ENABLE(htim);
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000104   0x6821             LDR      R1,[R4, #+0]
   \   00000106   0x6008             STR      R0,[R1, #+0]
   1864          
   1865            /* Return function status */
   1866            return HAL_OK;
   \   00000108   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_1:
   \   0000010A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1867          }
   1868          
   1869          /**
   1870            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   1871            * @param  htim : TIM Input Capture handle
   1872            * @param  Channel : TIM Channels to be disabled
   1873            *          This parameter can be one of the following values:
   1874            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1875            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1876            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1877            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1878            * @retval HAL status
   1879          */

   \                                 In section .text, align 2, keep-with-next
   1880          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1881          {
   \                     HAL_TIM_IC_Stop_DMA:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1882            /* Check the parameters */
   1883            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1884            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1885          
   1886            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_DMA_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD00B             BEQ.N    ??HAL_TIM_IC_Stop_DMA_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD010             BEQ.N    ??HAL_TIM_IC_Stop_DMA_2
   \   00000012   0x280C             CMP      R0,#+12
   \   00000014   0xD015             BEQ.N    ??HAL_TIM_IC_Stop_DMA_3
   \   00000016   0xE01B             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1887            {
   1888              case TIM_CHANNEL_1:
   1889              {
   1890                /* Disable the TIM Capture/Compare 1 DMA request */
   1891                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x60D0             STR      R0,[R2, #+12]
   1892              }
   1893              break;
   \   00000024   0xE014             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1894          
   1895              case TIM_CHANNEL_2:
   1896              {
   1897                /* Disable the TIM Capture/Compare 2 DMA request */
   1898                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1:
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000002E   0x6822             LDR      R2,[R4, #+0]
   \   00000030   0x60D0             STR      R0,[R2, #+12]
   1899              }
   1900              break;
   \   00000032   0xE00D             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1901          
   1902              case TIM_CHANNEL_3:
   1903              {
   1904                /* Disable the TIM Capture/Compare 3  DMA request */
   1905                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x68C0             LDR      R0,[R0, #+12]
   \   00000038   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000003C   0x6822             LDR      R2,[R4, #+0]
   \   0000003E   0x60D0             STR      R0,[R2, #+12]
   1906              }
   1907              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1908          
   1909              case TIM_CHANNEL_4:
   1910              {
   1911                /* Disable the TIM Capture/Compare 4  DMA request */
   1912                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3:
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x68C0             LDR      R0,[R0, #+12]
   \   00000046   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x60D0             STR      R0,[R2, #+12]
   1913              }
   1914              break;
   \   0000004E   0xE7FF             B.N      ??HAL_TIM_IC_Stop_DMA_5
   1915          
   1916              default:
   1917              break;
   1918            }
   1919          
   1920            /* Disable the Input Capture channel */
   1921            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4:
   \                     ??HAL_TIM_IC_Stop_DMA_5:
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_CCxChannelCmd
   1922          
   1923            /* Disable the Peripheral */
   1924            __HAL_TIM_DISABLE(htim);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6A00             LDR      R0,[R0, #+32]
   \   0000005C   0xF241 0x1111      MOVW     R1,#+4369
   \   00000060   0x4208             TST      R0,R1
   \   00000062   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_DMA_6
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6A00             LDR      R0,[R0, #+32]
   \   00000068   0xF240 0x4144      MOVW     R1,#+1092
   \   0000006C   0x4208             TST      R0,R1
   \   0000006E   0xD105             BNE.N    ??HAL_TIM_IC_Stop_DMA_6
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0840             LSRS     R0,R0,#+1
   \   00000076   0x0040             LSLS     R0,R0,#+1
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   1925          
   1926            /* Change the htim state */
   1927            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_6:
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF884 0x003D      STRB     R0,[R4, #+61]
   1928          
   1929            /* Return function status */
   1930            return HAL_OK;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xBD10             POP      {R4,PC}          ;; return
   1931          }
   1932          /**
   1933            * @}
   1934            */
   1935          
   1936          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1937           *  @brief    Time One Pulse functions 
   1938           *
   1939          @verbatim 
   1940            ==============================================================================
   1941                                  ##### Time One Pulse functions #####
   1942            ==============================================================================
   1943            [..]
   1944              This section provides functions allowing to:
   1945              (+) Initialize and configure the TIM One Pulse.
   1946              (+) De-initialize the TIM One Pulse.
   1947              (+) Start the Time One Pulse.
   1948              (+) Stop the Time One Pulse.
   1949              (+) Start the Time One Pulse and enable interrupt.
   1950              (+) Stop the Time One Pulse and disable interrupt.
   1951              (+) Start the Time One Pulse and enable DMA transfer.
   1952              (+) Stop the Time One Pulse and disable DMA transfer.
   1953          
   1954          @endverbatim
   1955            * @{
   1956            */
   1957          /**
   1958            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1959            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1960            * @param  htim : TIM OnePulse handle
   1961            * @param  OnePulseMode : Select the One pulse mode.
   1962            *         This parameter can be one of the following values:
   1963            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1964            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses wil be generated.
   1965            * @retval HAL status
   1966            */

   \                                 In section .text, align 2, keep-with-next
   1967          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   1968          {
   \                     HAL_TIM_OnePulse_Init:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1969            /* Check the TIM handle allocation */
   1970            if(htim == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   1971            {
   1972              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE01F             B.N      ??HAL_TIM_OnePulse_Init_1
   1973            }
   1974          
   1975            /* Check the parameters */
   1976            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1977            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1978            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1979            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1980            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   1981          
   1982            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0:
   \   0000000E   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_TIM_OnePulse_Init_2
   1983            {
   1984              /* Allocate lock resource and initialize it */
   1985              htim->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x003C      STRB     R0,[R4, #+60]
   1986              
   1987              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1988              HAL_TIM_OnePulse_MspInit(htim);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   1989            }
   1990          
   1991            /* Set the TIM state */
   1992            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OnePulse_Init_2:
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x003D      STRB     R0,[R4, #+61]
   1993          
   1994            /* Configure the Time base in the One Pulse Mode */
   1995            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000028   0x1D21             ADDS     R1,R4,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_Base_SetConfig
   1996          
   1997            /* Reset the OPM Bit */
   1998            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   1999          
   2000            /* Configure the OPM Mode */
   2001            htim->Instance->CR1 |= OnePulseMode;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4328             ORRS     R0,R5,R0
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6008             STR      R0,[R1, #+0]
   2002          
   2003            /* Initialize the TIM state*/
   2004            htim->State= HAL_TIM_STATE_READY;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xF884 0x003D      STRB     R0,[R4, #+61]
   2005          
   2006            return HAL_OK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Init_1:
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2007          }
   2008          
   2009          /**
   2010            * @brief  DeInitializes the TIM One Pulse 
   2011            * @param  htim : TIM One Pulse handle
   2012            * @retval HAL status
   2013            */

   \                                 In section .text, align 2, keep-with-next
   2014          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2015          {
   \                     HAL_TIM_OnePulse_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2016            /* Check the parameters */
   2017            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2018          
   2019            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x003D      STRB     R0,[R4, #+61]
   2020          
   2021            /* Disable the TIM Peripheral Clock */
   2022            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2023          
   2024            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2025            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   2026          
   2027            /* Change TIM state */
   2028            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x003D      STRB     R0,[R4, #+61]
   2029          
   2030            /* Release Lock */
   2031            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x003C      STRB     R0,[R4, #+60]
   2032          
   2033            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   2034          }
   2035          
   2036          /**
   2037            * @brief  Initializes the TIM One Pulse MSP.
   2038            * @param  htim : TIM handle
   2039            * @retval None
   2040            */

   \                                 In section .text, align 2, keep-with-next
   2041          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2042          {
   2043            /* Prevent unused argument(s) compilation warning */
   2044            UNUSED(htim);
   2045            /* NOTE : This function Should not be modified, when the callback is needed,
   2046                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2047             */
   2048          }
   \                     HAL_TIM_OnePulse_MspInit:
   \   00000000   0x4770             BX       LR               ;; return
   2049          
   2050          /**
   2051            * @brief  DeInitializes TIM One Pulse MSP.
   2052            * @param  htim : TIM handle
   2053            * @retval None
   2054            */

   \                                 In section .text, align 2, keep-with-next
   2055          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2056          {
   2057            /* Prevent unused argument(s) compilation warning */
   2058            UNUSED(htim);
   2059            /* NOTE : This function Should not be modified, when the callback is needed,
   2060                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2061             */
   2062          }
   \                     HAL_TIM_OnePulse_MspDeInit:
   \   00000000   0x4770             BX       LR               ;; return
   2063          
   2064          /**
   2065            * @brief  Starts the TIM One Pulse signal generation.
   2066            * @param  htim : TIM One Pulse handle
   2067            * @param  OutputChannel : TIM Channels to be enabled
   2068            *          This parameter can be one of the following values:
   2069            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2070            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2071            * @retval HAL status
   2072          */

   \                                 In section .text, align 2, keep-with-next
   2073          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2074          {
   \                     HAL_TIM_OnePulse_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2075            /* Prevent unused argument(s) compilation warning */
   2076            UNUSED(OutputChannel);
   2077          
   2078            /* Enable the Capture compare and the Input Capture channels 
   2079              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2080              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2081              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2082              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2083          
   2084              No need to enable the counter, it's enabled automatically by hardware 
   2085              (the counter starts in response to a stimulus and generate a pulse */
   2086          
   2087            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2088            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2089          
   2090            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable17  ;; 0x40012c00
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD105             BNE.N    ??HAL_TIM_OnePulse_Start_0
   2091            {
   2092              /* Enable the main output */
   2093              __HAL_TIM_MOE_ENABLE(htim);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6C40             LDR      R0,[R0, #+68]
   \   00000024   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x6448             STR      R0,[R1, #+68]
   2094            }
   2095          
   2096            /* Return function status */
   2097            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_0:
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2098          }
   2099          
   2100          /**
   2101            * @brief  Stops the TIM One Pulse signal generation.
   2102            * @param  htim : TIM One Pulse handle
   2103            * @param  OutputChannel : TIM Channels to be disable
   2104            *          This parameter can be one of the following values:
   2105            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2106            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2107            * @retval HAL status
   2108          */

   \                                 In section .text, align 2, keep-with-next
   2109          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2110          {
   \                     HAL_TIM_OnePulse_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2111            /* Prevent unused argument(s) compilation warning */
   2112            UNUSED(OutputChannel);
   2113          
   2114            /* Disable the Capture compare and the Input Capture channels
   2115            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2116            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2117            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2118            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2119          
   2120            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2121            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2122          
   2123            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable17  ;; 0x40012c00
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD111             BNE.N    ??HAL_TIM_OnePulse_Stop_0
   2124            {
   2125              /* Disable the Main Ouput */
   2126              __HAL_TIM_MOE_DISABLE(htim);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6A00             LDR      R0,[R0, #+32]
   \   00000024   0xF241 0x1111      MOVW     R1,#+4369
   \   00000028   0x4208             TST      R0,R1
   \   0000002A   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_1
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6A00             LDR      R0,[R0, #+32]
   \   00000030   0xF240 0x4144      MOVW     R1,#+1092
   \   00000034   0x4208             TST      R0,R1
   \   00000036   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_1
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6C40             LDR      R0,[R0, #+68]
   \   0000003C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6448             STR      R0,[R1, #+68]
   2127            }
   2128          
   2129            /* Disable the Peripheral */
   2130            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OnePulse_Stop_1:
   \                     ??HAL_TIM_OnePulse_Stop_0:
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6A00             LDR      R0,[R0, #+32]
   \   00000048   0xF241 0x1111      MOVW     R1,#+4369
   \   0000004C   0x4208             TST      R0,R1
   \   0000004E   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_2
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6A00             LDR      R0,[R0, #+32]
   \   00000054   0xF240 0x4144      MOVW     R1,#+1092
   \   00000058   0x4208             TST      R0,R1
   \   0000005A   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_2
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x0840             LSRS     R0,R0,#+1
   \   00000062   0x0040             LSLS     R0,R0,#+1
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
   2131          
   2132            /* Return function status */
   2133            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_2:
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD10             POP      {R4,PC}          ;; return
   2134          }
   2135          
   2136          /**
   2137            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2138            * @param  htim : TIM One Pulse handle
   2139            * @param  OutputChannel : TIM Channels to be enabled
   2140            *          This parameter can be one of the following values:
   2141            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2142            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2143            * @retval HAL status
   2144          */

   \                                 In section .text, align 2, keep-with-next
   2145          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2146          {
   \                     HAL_TIM_OnePulse_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2147            /* Prevent unused argument(s) compilation warning */
   2148            UNUSED(OutputChannel);
   2149          
   2150            /* Enable the Capture compare and the Input Capture channels 
   2151              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2152              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2153              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2154              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2155          
   2156              No need to enable the counter, it's enabled automatically by hardware 
   2157              (the counter starts in response to a stimulus and generate a pulse */
   2158          
   2159            /* Enable the TIM Capture/Compare 1 interrupt */
   2160            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
   2161          
   2162            /* Enable the TIM Capture/Compare 2 interrupt */
   2163            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x60C8             STR      R0,[R1, #+12]
   2164          
   2165            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x.... 0x....      BL       TIM_CCxChannelCmd
   2166            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2167          
   2168            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable17  ;; 0x40012c00
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD105             BNE.N    ??HAL_TIM_OnePulse_Start_IT_0
   2169            {
   2170              /* Enable the main output */
   2171              __HAL_TIM_MOE_ENABLE(htim);
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6C40             LDR      R0,[R0, #+68]
   \   0000003C   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6448             STR      R0,[R1, #+68]
   2172            }
   2173          
   2174            /* Return function status */
   2175            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_IT_0:
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   2176          }
   2177          
   2178          /**
   2179            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2180            * @param  htim : TIM One Pulse handle
   2181            * @param  OutputChannel : TIM Channels to be enabled
   2182            *          This parameter can be one of the following values:
   2183            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2184            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2185            * @retval HAL status
   2186          */

   \                                 In section .text, align 2, keep-with-next
   2187          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2188          {
   \                     HAL_TIM_OnePulse_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2189            /* Prevent unused argument(s) compilation warning */
   2190            UNUSED(OutputChannel);
   2191          
   2192            /* Disable the TIM Capture/Compare 1 interrupt */
   2193            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
   2194          
   2195            /* Disable the TIM Capture/Compare 2 interrupt */
   2196            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x60C8             STR      R0,[R1, #+12]
   2197          
   2198            /* Disable the Capture compare and the Input Capture channels 
   2199            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2200            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2201            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2202            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2203            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x.... 0x....      BL       TIM_CCxChannelCmd
   2204            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2205          
   2206            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable17  ;; 0x40012c00
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD111             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_0
   2207            {
   2208              /* Disable the Main Ouput */
   2209              __HAL_TIM_MOE_DISABLE(htim);
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6A00             LDR      R0,[R0, #+32]
   \   0000003C   0xF241 0x1111      MOVW     R1,#+4369
   \   00000040   0x4208             TST      R0,R1
   \   00000042   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_1
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6A00             LDR      R0,[R0, #+32]
   \   00000048   0xF240 0x4144      MOVW     R1,#+1092
   \   0000004C   0x4208             TST      R0,R1
   \   0000004E   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_1
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6C40             LDR      R0,[R0, #+68]
   \   00000054   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6448             STR      R0,[R1, #+68]
   2210            }
   2211          
   2212            /* Disable the Peripheral */
   2213             __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OnePulse_Stop_IT_1:
   \                     ??HAL_TIM_OnePulse_Stop_IT_0:
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A00             LDR      R0,[R0, #+32]
   \   00000060   0xF241 0x1111      MOVW     R1,#+4369
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_2
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6A00             LDR      R0,[R0, #+32]
   \   0000006C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_2
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x0840             LSRS     R0,R0,#+1
   \   0000007A   0x0040             LSLS     R0,R0,#+1
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   2214          
   2215            /* Return function status */
   2216            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_2:
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
   2217          }
   2218          
   2219          /**
   2220            * @}
   2221            */
   2222          
   2223          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2224           *  @brief    Time Encoder functions 
   2225           *
   2226          @verbatim 
   2227            ==============================================================================
   2228                                    ##### Time Encoder functions #####
   2229            ==============================================================================
   2230            [..]
   2231              This section provides functions allowing to:
   2232              (+) Initialize and configure the TIM Encoder.
   2233              (+) De-initialize the TIM Encoder.
   2234              (+) Start the Time Encoder.
   2235              (+) Stop the Time Encoder.
   2236              (+) Start the Time Encoder and enable interrupt.
   2237              (+) Stop the Time Encoder and disable interrupt.
   2238              (+) Start the Time Encoder and enable DMA transfer.
   2239              (+) Stop the Time Encoder and disable DMA transfer.
   2240          
   2241          @endverbatim
   2242            * @{
   2243            */
   2244          /**
   2245            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2246            * @param  htim : TIM Encoder Interface handle
   2247            * @param  sConfig : TIM Encoder Interface configuration structure
   2248            * @retval HAL status
   2249            */

   \                                 In section .text, align 2, keep-with-next
   2250          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2251          {
   \                     HAL_TIM_Encoder_Init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2252            uint32_t tmpsmcr = 0U;
   \   00000006   0x2000             MOVS     R0,#+0
   2253            uint32_t tmpccmr1 = 0U;
   \   00000008   0x2100             MOVS     R1,#+0
   2254            uint32_t tmpccer = 0U;
   \   0000000A   0x2200             MOVS     R2,#+0
   2255          
   2256            /* Check the TIM handle allocation */
   2257            if(htim == NULL)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2258            {
   2259              return HAL_ERROR;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE04A             B.N      ??HAL_TIM_Encoder_Init_1
   2260            }
   2261          
   2262            /* Check the parameters */
   2263            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2264            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2265            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2266            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2267            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2268            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2269            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2270            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2271            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2272            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2273            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2274            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2275            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2276          
   2277            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0:
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD105             BNE.N    ??HAL_TIM_Encoder_Init_2
   2278            {
   2279              /* Allocate lock resource and initialize it */
   2280              htim->Lock = HAL_UNLOCKED;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x003C      STRB     R0,[R4, #+60]
   2281              
   2282              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2283              HAL_TIM_Encoder_MspInit(htim);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2284            }
   2285          
   2286            /* Set the TIM state */
   2287            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Init_2:
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x003D      STRB     R0,[R4, #+61]
   2288          
   2289            /* Reset the SMS bits */
   2290            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6880             LDR      R0,[R0, #+8]
   \   00000032   0x08C0             LSRS     R0,R0,#+3
   \   00000034   0x00C0             LSLS     R0,R0,#+3
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x6088             STR      R0,[R1, #+8]
   2291          
   2292            /* Configure the Time base in the Encoder Mode */
   2293            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000003A   0x1D21             ADDS     R1,R4,#+4
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      BL       TIM_Base_SetConfig
   2294          
   2295            /* Get the TIMx SMCR register value */
   2296            tmpsmcr = htim->Instance->SMCR;
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6880             LDR      R0,[R0, #+8]
   2297          
   2298            /* Get the TIMx CCMR1 register value */
   2299            tmpccmr1 = htim->Instance->CCMR1;
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6989             LDR      R1,[R1, #+24]
   2300          
   2301            /* Get the TIMx CCER register value */
   2302            tmpccer = htim->Instance->CCER;
   \   0000004A   0x6822             LDR      R2,[R4, #+0]
   \   0000004C   0x6A12             LDR      R2,[R2, #+32]
   2303          
   2304            /* Set the encoder Mode */
   2305            tmpsmcr |= sConfig->EncoderMode;
   \   0000004E   0x682B             LDR      R3,[R5, #+0]
   \   00000050   0x4318             ORRS     R0,R3,R0
   2306          
   2307            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2308            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   \   00000052   0x.... 0x....      LDR.W    R3,??DataTable21  ;; 0xfffffcfc
   \   00000056   0x4019             ANDS     R1,R3,R1
   2309            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   \   00000058   0x68AB             LDR      R3,[R5, #+8]
   \   0000005A   0x69AE             LDR      R6,[R5, #+24]
   \   0000005C   0xEA53 0x2306      ORRS     R3,R3,R6, LSL #+8
   \   00000060   0x4319             ORRS     R1,R3,R1
   2310          
   2311            /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2312            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable21_1  ;; 0xfffff3f3
   \   00000066   0x4019             ANDS     R1,R3,R1
   2313            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   \   00000068   0x.... 0x....      LDR.W    R3,??DataTable21_2  ;; 0xffff0f0f
   \   0000006C   0x4019             ANDS     R1,R3,R1
   2314            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   \   0000006E   0x68EB             LDR      R3,[R5, #+12]
   \   00000070   0x69EE             LDR      R6,[R5, #+28]
   \   00000072   0xEA53 0x2306      ORRS     R3,R3,R6, LSL #+8
   \   00000076   0x4319             ORRS     R1,R3,R1
   2315            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   \   00000078   0x692B             LDR      R3,[R5, #+16]
   \   0000007A   0x6A2E             LDR      R6,[R5, #+32]
   \   0000007C   0x0336             LSLS     R6,R6,#+12
   \   0000007E   0xEA56 0x1303      ORRS     R3,R6,R3, LSL #+4
   \   00000082   0x4319             ORRS     R1,R3,R1
   2316          
   2317            /* Set the TI1 and the TI2 Polarities */
   2318            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   \   00000084   0xF032 0x0222      BICS     R2,R2,#0x22
   2319            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   \   00000088   0xF032 0x0288      BICS     R2,R2,#0x88
   2320            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   \   0000008C   0x686B             LDR      R3,[R5, #+4]
   \   0000008E   0x696D             LDR      R5,[R5, #+20]
   \   00000090   0xEA53 0x1305      ORRS     R3,R3,R5, LSL #+4
   \   00000094   0x431A             ORRS     R2,R3,R2
   2321          
   2322            /* Write to TIMx SMCR */
   2323            htim->Instance->SMCR = tmpsmcr;
   \   00000096   0x6823             LDR      R3,[R4, #+0]
   \   00000098   0x6098             STR      R0,[R3, #+8]
   2324          
   2325            /* Write to TIMx CCMR1 */
   2326            htim->Instance->CCMR1 = tmpccmr1;
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6181             STR      R1,[R0, #+24]
   2327          
   2328            /* Write to TIMx CCER */
   2329            htim->Instance->CCER = tmpccer;
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6202             STR      R2,[R0, #+32]
   2330          
   2331            /* Initialize the TIM state*/
   2332            htim->State= HAL_TIM_STATE_READY;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xF884 0x003D      STRB     R0,[R4, #+61]
   2333          
   2334            return HAL_OK;
   \   000000A8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Init_1:
   \   000000AA   0xBD70             POP      {R4-R6,PC}       ;; return
   2335          }
   2336          
   2337          
   2338          /**
   2339            * @brief  DeInitializes the TIM Encoder interface 
   2340            * @param  htim : TIM Encoder handle
   2341            * @retval HAL status
   2342            */

   \                                 In section .text, align 2, keep-with-next
   2343          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2344          {
   \                     HAL_TIM_Encoder_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2345            /* Check the parameters */
   2346            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2347          
   2348            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x003D      STRB     R0,[R4, #+61]
   2349          
   2350            /* Disable the TIM Peripheral Clock */
   2351            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   2352          
   2353            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2354            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2355          
   2356            /* Change TIM state */
   2357            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x003D      STRB     R0,[R4, #+61]
   2358          
   2359            /* Release Lock */
   2360            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x003C      STRB     R0,[R4, #+60]
   2361          
   2362            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   2363          }
   2364          
   2365          /**
   2366            * @brief  Initializes the TIM Encoder Interface MSP.
   2367            * @param  htim : TIM handle
   2368            * @retval None
   2369            */

   \                                 In section .text, align 2, keep-with-next
   2370          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2371          {
   2372            /* Prevent unused argument(s) compilation warning */
   2373            UNUSED(htim);
   2374            /* NOTE : This function Should not be modified, when the callback is needed,
   2375                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2376             */
   2377          }
   \                     HAL_TIM_Encoder_MspInit:
   \   00000000   0x4770             BX       LR               ;; return
   2378          
   2379          /**
   2380            * @brief  DeInitializes TIM Encoder Interface MSP.
   2381            * @param  htim : TIM handle
   2382            * @retval None
   2383            */

   \                                 In section .text, align 2, keep-with-next
   2384          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2385          {
   2386            /* Prevent unused argument(s) compilation warning */
   2387            UNUSED(htim);
   2388            /* NOTE : This function Should not be modified, when the callback is needed,
   2389                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2390             */
   2391          }
   \                     HAL_TIM_Encoder_MspDeInit:
   \   00000000   0x4770             BX       LR               ;; return
   2392          
   2393          /**
   2394            * @brief  Starts the TIM Encoder Interface.
   2395            * @param  htim : TIM Encoder Interface handle
   2396            * @param  Channel : TIM Channels to be enabled
   2397            *          This parameter can be one of the following values:
   2398            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2399            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2400            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2401            * @retval HAL status
   2402          */

   \                                 In section .text, align 2, keep-with-next
   2403          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2404          {
   \                     HAL_TIM_Encoder_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2405            /* Check the parameters */
   2406            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2407          
   2408            /* Enable the encoder interface channels */
   2409            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_Encoder_Start_1
   \   0000000C   0xE00B             B.N      ??HAL_TIM_Encoder_Start_2
   2410            {
   2411              case TIM_CHANNEL_1:
   2412            {
   2413              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0:
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2414                break;
   \   00000018   0xE00F             B.N      ??HAL_TIM_Encoder_Start_3
   2415            }
   2416              case TIM_CHANNEL_2:
   2417            {
   2418              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_1:
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_CCxChannelCmd
   2419                break;
   \   00000024   0xE009             B.N      ??HAL_TIM_Encoder_Start_3
   2420            }
   2421              default :
   2422            {
   2423               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2:
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2424               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_CCxChannelCmd
   2425               break;
   2426              }
   2427            }
   2428            /* Enable the Peripheral */
   2429            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_3:
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6008             STR      R0,[R1, #+0]
   2430          
   2431            /* Return function status */
   2432            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
   2433          }
   2434          
   2435          /**
   2436            * @brief  Stops the TIM Encoder Interface.
   2437            * @param  htim : TIM Encoder Interface handle
   2438            * @param  Channel : TIM Channels to be disabled
   2439            *          This parameter can be one of the following values:
   2440            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2441            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2442            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2443            * @retval HAL status
   2444          */

   \                                 In section .text, align 2, keep-with-next
   2445          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2446          {
   \                     HAL_TIM_Encoder_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2447            /* Check the parameters */
   2448              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2449          
   2450             /* Disable the Input Capture channels 1 and 2
   2451              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2452            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Stop_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_Encoder_Stop_1
   \   0000000C   0xE00B             B.N      ??HAL_TIM_Encoder_Stop_2
   2453            {
   2454              case TIM_CHANNEL_1:
   2455            {
   2456               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0:
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2457                break;
   \   00000018   0xE00F             B.N      ??HAL_TIM_Encoder_Stop_3
   2458            }
   2459              case TIM_CHANNEL_2:
   2460            {
   2461              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_1:
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_CCxChannelCmd
   2462                break;
   \   00000024   0xE009             B.N      ??HAL_TIM_Encoder_Stop_3
   2463            }
   2464              default :
   2465            {
   2466              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2:
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2467              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_CCxChannelCmd
   2468               break;
   2469              }
   2470            }
   2471          
   2472            /* Disable the Peripheral */
   2473            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_3:
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6A00             LDR      R0,[R0, #+32]
   \   0000003E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000042   0x4208             TST      R0,R1
   \   00000044   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6A00             LDR      R0,[R0, #+32]
   \   0000004A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000004E   0x4208             TST      R0,R1
   \   00000050   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x0840             LSRS     R0,R0,#+1
   \   00000058   0x0040             LSLS     R0,R0,#+1
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   2474          
   2475            /* Return function status */
   2476            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_4:
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
   2477          }
   2478          
   2479          /**
   2480            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2481            * @param  htim : TIM Encoder Interface handle
   2482            * @param  Channel : TIM Channels to be enabled
   2483            *          This parameter can be one of the following values:
   2484            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2485            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2486            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2487            * @retval HAL status
   2488          */

   \                                 In section .text, align 2, keep-with-next
   2489          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2490          {
   \                     HAL_TIM_Encoder_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2491            /* Check the parameters */
   2492            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2493          
   2494            /* Enable the encoder interface channels */
   2495            /* Enable the capture compare Interrupts 1 and/or 2 */
   2496            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD00C             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \   0000000C   0xE017             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2497            {
   2498              case TIM_CHANNEL_1:
   2499            {
   2500              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0:
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2501              __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x60C8             STR      R0,[R1, #+12]
   2502                break;
   \   00000024   0xE021             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2503            }
   2504              case TIM_CHANNEL_2:
   2505            {
   2506              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1:
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2507              __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x60C8             STR      R0,[R1, #+12]
   2508                break;
   \   0000003C   0xE015             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2509            }
   2510              default :
   2511            {
   2512               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2:
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2513               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2514               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C0             LDR      R0,[R0, #+12]
   \   00000056   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x60C8             STR      R0,[R1, #+12]
   2515               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x60C8             STR      R0,[R1, #+12]
   2516               break;
   2517              }
   2518            }
   2519          
   2520            /* Enable the Peripheral */
   2521            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_IT_3:
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6008             STR      R0,[R1, #+0]
   2522          
   2523            /* Return function status */
   2524            return HAL_OK;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
   2525          }
   2526          
   2527          /**
   2528            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2529            * @param  htim : TIM Encoder Interface handle
   2530            * @param  Channel : TIM Channels to be disabled
   2531            *          This parameter can be one of the following values:
   2532            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2533            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2534            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2535            * @retval HAL status
   2536          */

   \                                 In section .text, align 2, keep-with-next
   2537          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2538          {
   \                     HAL_TIM_Encoder_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2539            /* Check the parameters */
   2540            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2541          
   2542            /* Disable the Input Capture channels 1 and 2
   2543              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2544            if(Channel == TIM_CHANNEL_1)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_0
   2545            {
   2546              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2547          
   2548              /* Disable the capture compare Interrupts 1 */
   2549            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
   \   0000001E   0xE023             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2550            }
   2551            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0:
   \   00000020   0x2904             CMP      R1,#+4
   \   00000022   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2552            {
   2553              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2554          
   2555              /* Disable the capture compare Interrupts 2 */
   2556            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C0             LDR      R0,[R0, #+12]
   \   00000032   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x60C8             STR      R0,[R1, #+12]
   \   0000003A   0xE015             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2557            }
   2558            else
   2559            {
   2560              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_IT_2:
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       TIM_CCxChannelCmd
   2561              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x2104             MOVS     R1,#+4
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2562          
   2563              /* Disable the capture compare Interrupts 1 and 2 */
   2564              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x68C0             LDR      R0,[R0, #+12]
   \   00000054   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x60C8             STR      R0,[R1, #+12]
   2565              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
   2566            }
   2567          
   2568            /* Disable the Peripheral */
   2569            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_IT_1:
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6A00             LDR      R0,[R0, #+32]
   \   0000006C   0xF241 0x1111      MOVW     R1,#+4369
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6A00             LDR      R0,[R0, #+32]
   \   00000078   0xF240 0x4144      MOVW     R1,#+1092
   \   0000007C   0x4208             TST      R0,R1
   \   0000007E   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x0840             LSRS     R0,R0,#+1
   \   00000086   0x0040             LSLS     R0,R0,#+1
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   2570          
   2571            /* Change the htim state */
   2572            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_3:
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xF884 0x003D      STRB     R0,[R4, #+61]
   2573          
   2574            /* Return function status */
   2575            return HAL_OK;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBD10             POP      {R4,PC}          ;; return
   2576          }
   2577          
   2578          /**
   2579            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2580            * @param  htim : TIM Encoder Interface handle
   2581            * @param  Channel : TIM Channels to be enabled
   2582            *          This parameter can be one of the following values:
   2583            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2584            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2585            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2586            * @param  pData1 : The destination Buffer address for IC1.
   2587            * @param  pData2 : The destination Buffer address for IC2.
   2588            * @param  Length : The length of data to be transferred from TIM peripheral to memory.
   2589            * @retval HAL status
   2590          */

   \                                 In section .text, align 2, keep-with-next
   2591          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2592          {
   \                     HAL_TIM_Encoder_Start_DMA:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x001E             MOVS     R6,R3
   \   00000006   0x9C04             LDR      R4,[SP, #+16]
   2593            /* Check the parameters */
   2594            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2595          
   2596            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_DMA_0
   2597            {
   2598               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE098             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2599            }
   2600            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_Encoder_Start_DMA_0:
   \   00000014   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD10B             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   2601            {
   2602              if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0U))
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_3
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD104             BNE.N    ??HAL_TIM_Encoder_Start_DMA_4
   \                     ??HAL_TIM_Encoder_Start_DMA_3:
   \   00000024   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   2603              {
   2604                return HAL_ERROR;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE08B             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2605              }
   2606              else
   2607              {
   2608                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_4:
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF885 0x003D      STRB     R0,[R5, #+61]
   2609              }
   2610            }
   2611          
   2612            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_2:
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD004             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \   00000038   0x2904             CMP      R1,#+4
   \   0000003A   0xD024             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_6
   \   0000003C   0x2918             CMP      R1,#+24
   \   0000003E   0xD044             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_7
   \   00000040   0xE080             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2613            {
   2614              case TIM_CHANNEL_1:
   2615              {
   2616                /* Set the DMA Period elapsed callback */
   2617                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5:
   \   00000042   0x6A68             LDR      R0,[R5, #+36]
   \   00000044   0x....             LDR.N    R1,??DataTable19
   \   00000046   0x6281             STR      R1,[R0, #+40]
   2618          
   2619                /* Set the DMA error callback */
   2620                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x6A68             LDR      R0,[R5, #+36]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \   0000004E   0x6301             STR      R1,[R0, #+48]
   2621          
   2622                /* Enable the DMA channel */
   2623                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
   \   00000050   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000052   0x0023             MOVS     R3,R4
   \   00000054   0x6828             LDR      R0,[R5, #+0]
   \   00000056   0xF110 0x0134      ADDS     R1,R0,#+52
   \   0000005A   0x6A68             LDR      R0,[R5, #+36]
   \   0000005C   0x.... 0x....      BL       HAL_DMA_Start_IT
   2624          
   2625                /* Enable the TIM Input Capture DMA request */
   2626                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0x68C0             LDR      R0,[R0, #+12]
   \   00000064   0xF44F 0x7100      MOV      R1,#+512
   \   00000068   0x4308             ORRS     R0,R1,R0
   \   0000006A   0x6829             LDR      R1,[R5, #+0]
   \   0000006C   0x60C8             STR      R0,[R1, #+12]
   2627          
   2628                /* Enable the Peripheral */
   2629                __HAL_TIM_ENABLE(htim);
   \   0000006E   0x6828             LDR      R0,[R5, #+0]
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000076   0x6829             LDR      R1,[R5, #+0]
   \   00000078   0x6008             STR      R0,[R1, #+0]
   2630          
   2631                /* Enable the Capture compare channel */
   2632                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   0000007A   0x2201             MOVS     R2,#+1
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x6828             LDR      R0,[R5, #+0]
   \   00000080   0x.... 0x....      BL       TIM_CCxChannelCmd
   2633              }
   2634              break;
   \   00000084   0xE05E             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2635          
   2636              case TIM_CHANNEL_2:
   2637              {
   2638                /* Set the DMA Period elapsed callback */
   2639                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6:
   \   00000086   0x6AA8             LDR      R0,[R5, #+40]
   \   00000088   0x....             LDR.N    R1,??DataTable19
   \   0000008A   0x6281             STR      R1,[R0, #+40]
   2640          
   2641                /* Set the DMA error callback */
   2642                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   \   0000008C   0x6AA8             LDR      R0,[R5, #+40]
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \   00000092   0x6301             STR      R1,[R0, #+48]
   2643                /* Enable the DMA channel */
   2644                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   00000094   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000096   0x0023             MOVS     R3,R4
   \   00000098   0x0032             MOVS     R2,R6
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0xF110 0x0138      ADDS     R1,R0,#+56
   \   000000A0   0x6AA8             LDR      R0,[R5, #+40]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
   2645          
   2646                /* Enable the TIM Input Capture  DMA request */
   2647                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   000000A6   0x6828             LDR      R0,[R5, #+0]
   \   000000A8   0x68C0             LDR      R0,[R0, #+12]
   \   000000AA   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000AE   0x6829             LDR      R1,[R5, #+0]
   \   000000B0   0x60C8             STR      R0,[R1, #+12]
   2648          
   2649                /* Enable the Peripheral */
   2650                __HAL_TIM_ENABLE(htim);
   \   000000B2   0x6828             LDR      R0,[R5, #+0]
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000BA   0x6829             LDR      R1,[R5, #+0]
   \   000000BC   0x6008             STR      R0,[R1, #+0]
   2651          
   2652                /* Enable the Capture compare channel */
   2653                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   000000BE   0x2201             MOVS     R2,#+1
   \   000000C0   0x2104             MOVS     R1,#+4
   \   000000C2   0x6828             LDR      R0,[R5, #+0]
   \   000000C4   0x.... 0x....      BL       TIM_CCxChannelCmd
   2654              }
   2655              break;
   \   000000C8   0xE03C             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2656          
   2657              case TIM_CHANNEL_ALL:
   2658              {
   2659                /* Set the DMA Period elapsed callback */
   2660                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_7:
   \   000000CA   0x6A68             LDR      R0,[R5, #+36]
   \   000000CC   0x....             LDR.N    R1,??DataTable19
   \   000000CE   0x6281             STR      R1,[R0, #+40]
   2661          
   2662                /* Set the DMA error callback */
   2663                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   000000D0   0x6A68             LDR      R0,[R5, #+36]
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \   000000D6   0x6301             STR      R1,[R0, #+48]
   2664          
   2665                /* Enable the DMA channel */
   2666                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   \   000000D8   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000DA   0x0023             MOVS     R3,R4
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0xF110 0x0134      ADDS     R1,R0,#+52
   \   000000E2   0x6A68             LDR      R0,[R5, #+36]
   \   000000E4   0x.... 0x....      BL       HAL_DMA_Start_IT
   2667          
   2668                /* Set the DMA Period elapsed callback */
   2669                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \   000000E8   0x6AA8             LDR      R0,[R5, #+40]
   \   000000EA   0x....             LDR.N    R1,??DataTable19
   \   000000EC   0x6281             STR      R1,[R0, #+40]
   2670          
   2671                /* Set the DMA error callback */
   2672                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000EE   0x6AA8             LDR      R0,[R5, #+40]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \   000000F4   0x6301             STR      R1,[R0, #+48]
   2673          
   2674                /* Enable the DMA channel */
   2675                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   000000F6   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000F8   0x0023             MOVS     R3,R4
   \   000000FA   0x0032             MOVS     R2,R6
   \   000000FC   0x6828             LDR      R0,[R5, #+0]
   \   000000FE   0xF110 0x0138      ADDS     R1,R0,#+56
   \   00000102   0x6AA8             LDR      R0,[R5, #+40]
   \   00000104   0x.... 0x....      BL       HAL_DMA_Start_IT
   2676          
   2677               /* Enable the Peripheral */
   2678                __HAL_TIM_ENABLE(htim);
   \   00000108   0x6828             LDR      R0,[R5, #+0]
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000110   0x6829             LDR      R1,[R5, #+0]
   \   00000112   0x6008             STR      R0,[R1, #+0]
   2679          
   2680                /* Enable the Capture compare channel */
   2681                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000114   0x2201             MOVS     R2,#+1
   \   00000116   0x2100             MOVS     R1,#+0
   \   00000118   0x6828             LDR      R0,[R5, #+0]
   \   0000011A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2682                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000011E   0x2201             MOVS     R2,#+1
   \   00000120   0x2104             MOVS     R1,#+4
   \   00000122   0x6828             LDR      R0,[R5, #+0]
   \   00000124   0x.... 0x....      BL       TIM_CCxChannelCmd
   2683          
   2684                /* Enable the TIM Input Capture  DMA request */
   2685                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000128   0x6828             LDR      R0,[R5, #+0]
   \   0000012A   0x68C0             LDR      R0,[R0, #+12]
   \   0000012C   0xF44F 0x7100      MOV      R1,#+512
   \   00000130   0x4308             ORRS     R0,R1,R0
   \   00000132   0x6829             LDR      R1,[R5, #+0]
   \   00000134   0x60C8             STR      R0,[R1, #+12]
   2686                /* Enable the TIM Input Capture  DMA request */
   2687                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000136   0x6828             LDR      R0,[R5, #+0]
   \   00000138   0x68C0             LDR      R0,[R0, #+12]
   \   0000013A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000013E   0x6829             LDR      R1,[R5, #+0]
   \   00000140   0x60C8             STR      R0,[R1, #+12]
   2688              }
   2689              break;
   \   00000142   0xE7FF             B.N      ??HAL_TIM_Encoder_Start_DMA_9
   2690          
   2691              default:
   2692              break;
   2693            }
   2694            /* Return function status */
   2695            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_8:
   \                     ??HAL_TIM_Encoder_Start_DMA_9:
   \   00000144   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_1:
   \   00000146   0xBD70             POP      {R4-R6,PC}       ;; return
   2696          }
   2697          
   2698          /**
   2699            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2700            * @param  htim : TIM Encoder Interface handle
   2701            * @param  Channel : TIM Channels to be enabled
   2702            *          This parameter can be one of the following values:
   2703            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2704            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2705            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2706            * @retval HAL status
   2707          */

   \                                 In section .text, align 2, keep-with-next
   2708          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2709          {
   \                     HAL_TIM_Encoder_Stop_DMA:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2710            /* Check the parameters */
   2711            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2712          
   2713            /* Disable the Input Capture channels 1 and 2
   2714              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2715            if(Channel == TIM_CHANNEL_1)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_0
   2716            {
   2717              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2718          
   2719              /* Disable the capture compare DMA Request 1 */
   2720              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
   \   0000001E   0xE023             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2721            }
   2722            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0:
   \   00000020   0x2904             CMP      R1,#+4
   \   00000022   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   2723            {
   2724              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2725          
   2726              /* Disable the capture compare DMA Request 2 */
   2727              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C0             LDR      R0,[R0, #+12]
   \   00000032   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x60C8             STR      R0,[R1, #+12]
   \   0000003A   0xE015             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2728            }
   2729            else
   2730            {
   2731              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_DMA_2:
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       TIM_CCxChannelCmd
   2732              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x2104             MOVS     R1,#+4
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2733          
   2734              /* Disable the capture compare DMA Request 1 and 2 */
   2735              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x68C0             LDR      R0,[R0, #+12]
   \   00000054   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x60C8             STR      R0,[R1, #+12]
   2736              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0xF430 0x6080      BICS     R0,R0,#0x400
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
   2737            }
   2738          
   2739            /* Disable the Peripheral */
   2740            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_DMA_1:
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6A00             LDR      R0,[R0, #+32]
   \   0000006C   0xF241 0x1111      MOVW     R1,#+4369
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6A00             LDR      R0,[R0, #+32]
   \   00000078   0xF240 0x4144      MOVW     R1,#+1092
   \   0000007C   0x4208             TST      R0,R1
   \   0000007E   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x0840             LSRS     R0,R0,#+1
   \   00000086   0x0040             LSLS     R0,R0,#+1
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   2741          
   2742            /* Change the htim state */
   2743            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_3:
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xF884 0x003D      STRB     R0,[R4, #+61]
   2744          
   2745            /* Return function status */
   2746            return HAL_OK;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBD10             POP      {R4,PC}          ;; return
   2747          }
   2748          
   2749          /**
   2750            * @}
   2751            */
   2752          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2753           *  @brief    IRQ handler management 
   2754           *
   2755          @verbatim 
   2756            ==============================================================================
   2757                                  ##### IRQ handler management #####
   2758            ==============================================================================
   2759            [..]
   2760              This section provides Timer IRQ handler function.
   2761          
   2762          @endverbatim
   2763            * @{
   2764            */
   2765          /**
   2766            * @brief  This function handles TIM interrupts requests.
   2767            * @param  htim : TIM  handle
   2768            * @retval None
   2769            */

   \                                 In section .text, align 2, keep-with-next
   2770          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2771          {
   \                     HAL_TIM_IRQHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2772            /* Capture compare 1 event */
   2773            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x0780             LSLS     R0,R0,#+30
   \   0000000A   0xD51B             BPL.N    ??HAL_TIM_IRQHandler_0
   2774            {
   2775              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x68C0             LDR      R0,[R0, #+12]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD517             BPL.N    ??HAL_TIM_IRQHandler_0
   2776              {
   2777                {
   2778                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0xF07F 0x0102      MVNS     R1,#+2
   \   0000001A   0x6101             STR      R1,[R0, #+16]
   2779                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x7720             STRB     R0,[R4, #+28]
   2780          
   2781                  /* Input capture event */
   2782                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_1
   2783                  {
   2784                    HAL_TIM_IC_CaptureCallback(htim);
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000032   0xE005             B.N      ??HAL_TIM_IRQHandler_2
   2785                  }
   2786                  /* Output compare event */
   2787                  else
   2788                  {
   2789                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1:
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2790                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2791                  }
   2792                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7720             STRB     R0,[R4, #+28]
   2793                }
   2794              }
   2795            }
   2796            /* Capture compare 2 event */
   2797            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0:
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6900             LDR      R0,[R0, #+16]
   \   00000048   0x0740             LSLS     R0,R0,#+29
   \   0000004A   0xD51B             BPL.N    ??HAL_TIM_IRQHandler_3
   2798            {
   2799              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x68C0             LDR      R0,[R0, #+12]
   \   00000050   0x0740             LSLS     R0,R0,#+29
   \   00000052   0xD517             BPL.N    ??HAL_TIM_IRQHandler_3
   2800              {
   2801                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0xF07F 0x0104      MVNS     R1,#+4
   \   0000005A   0x6101             STR      R1,[R0, #+16]
   2802                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0x7720             STRB     R0,[R4, #+28]
   2803                /* Input capture event */
   2804                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6980             LDR      R0,[R0, #+24]
   \   00000064   0xF44F 0x7140      MOV      R1,#+768
   \   00000068   0x4208             TST      R0,R1
   \   0000006A   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_4
   2805                {
   2806                  HAL_TIM_IC_CaptureCallback(htim);
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000072   0xE005             B.N      ??HAL_TIM_IRQHandler_5
   2807                }
   2808                /* Output compare event */
   2809                else
   2810                {
   2811                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4:
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2812                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2813                }
   2814                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5:
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x7720             STRB     R0,[R4, #+28]
   2815              }
   2816            }
   2817            /* Capture compare 3 event */
   2818            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3:
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6900             LDR      R0,[R0, #+16]
   \   00000088   0x0700             LSLS     R0,R0,#+28
   \   0000008A   0xD51B             BPL.N    ??HAL_TIM_IRQHandler_6
   2819            {
   2820              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x68C0             LDR      R0,[R0, #+12]
   \   00000090   0x0700             LSLS     R0,R0,#+28
   \   00000092   0xD517             BPL.N    ??HAL_TIM_IRQHandler_6
   2821              {
   2822                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0xF07F 0x0108      MVNS     R1,#+8
   \   0000009A   0x6101             STR      R1,[R0, #+16]
   2823                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   0000009C   0x2004             MOVS     R0,#+4
   \   0000009E   0x7720             STRB     R0,[R4, #+28]
   2824                /* Input capture event */
   2825                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x69C0             LDR      R0,[R0, #+28]
   \   000000A4   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_7
   2826                {
   2827                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000B2   0xE005             B.N      ??HAL_TIM_IRQHandler_8
   2828                }
   2829                /* Output compare event */
   2830                else
   2831                {
   2832                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7:
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2833                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2834                }
   2835                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8:
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x7720             STRB     R0,[R4, #+28]
   2836              }
   2837            }
   2838            /* Capture compare 4 event */
   2839            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6:
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6900             LDR      R0,[R0, #+16]
   \   000000C8   0x06C0             LSLS     R0,R0,#+27
   \   000000CA   0xD51B             BPL.N    ??HAL_TIM_IRQHandler_9
   2840            {
   2841              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x68C0             LDR      R0,[R0, #+12]
   \   000000D0   0x06C0             LSLS     R0,R0,#+27
   \   000000D2   0xD517             BPL.N    ??HAL_TIM_IRQHandler_9
   2842              {
   2843                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0xF07F 0x0110      MVNS     R1,#+16
   \   000000DA   0x6101             STR      R1,[R0, #+16]
   2844                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   000000DC   0x2008             MOVS     R0,#+8
   \   000000DE   0x7720             STRB     R0,[R4, #+28]
   2845                /* Input capture event */
   2846                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x69C0             LDR      R0,[R0, #+28]
   \   000000E4   0xF44F 0x7140      MOV      R1,#+768
   \   000000E8   0x4208             TST      R0,R1
   \   000000EA   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_10
   2847                {
   2848                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000F2   0xE005             B.N      ??HAL_TIM_IRQHandler_11
   2849                }
   2850                /* Output compare event */
   2851                else
   2852                {
   2853                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10:
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2854                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2855                }
   2856                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11:
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x7720             STRB     R0,[R4, #+28]
   2857              }
   2858            }
   2859            /* TIM Update event */
   2860            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9:
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6900             LDR      R0,[R0, #+16]
   \   00000108   0x07C0             LSLS     R0,R0,#+31
   \   0000010A   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_12
   2861            {
   2862              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x68C0             LDR      R0,[R0, #+12]
   \   00000110   0x07C0             LSLS     R0,R0,#+31
   \   00000112   0xD506             BPL.N    ??HAL_TIM_IRQHandler_12
   2863              {
   2864                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0xF07F 0x0101      MVNS     R1,#+1
   \   0000011A   0x6101             STR      R1,[R0, #+16]
   2865                HAL_TIM_PeriodElapsedCallback(htim);
   \   0000011C   0x0020             MOVS     R0,R4
   \   0000011E   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   2866              }
   2867            }
   2868            /* TIM Break input event */
   2869            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12:
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6900             LDR      R0,[R0, #+16]
   \   00000126   0x0600             LSLS     R0,R0,#+24
   \   00000128   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_13
   2870            {
   2871              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x68C0             LDR      R0,[R0, #+12]
   \   0000012E   0x0600             LSLS     R0,R0,#+24
   \   00000130   0xD506             BPL.N    ??HAL_TIM_IRQHandler_13
   2872              {
   2873                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   00000132   0x6820             LDR      R0,[R4, #+0]
   \   00000134   0xF07F 0x0180      MVNS     R1,#+128
   \   00000138   0x6101             STR      R1,[R0, #+16]
   2874                HAL_TIMEx_BreakCallback(htim);
   \   0000013A   0x0020             MOVS     R0,R4
   \   0000013C   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2875              }
   2876            }
   2877            /* TIM Trigger detection event */
   2878            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_13:
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x6900             LDR      R0,[R0, #+16]
   \   00000144   0x0640             LSLS     R0,R0,#+25
   \   00000146   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_14
   2879            {
   2880              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   \   00000148   0x6820             LDR      R0,[R4, #+0]
   \   0000014A   0x68C0             LDR      R0,[R0, #+12]
   \   0000014C   0x0640             LSLS     R0,R0,#+25
   \   0000014E   0xD506             BPL.N    ??HAL_TIM_IRQHandler_14
   2881              {
   2882                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \   00000150   0x6820             LDR      R0,[R4, #+0]
   \   00000152   0xF07F 0x0140      MVNS     R1,#+64
   \   00000156   0x6101             STR      R1,[R0, #+16]
   2883                HAL_TIM_TriggerCallback(htim);
   \   00000158   0x0020             MOVS     R0,R4
   \   0000015A   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   2884              }
   2885            }
   2886            /* TIM commutation event */
   2887            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_14:
   \   0000015E   0x6820             LDR      R0,[R4, #+0]
   \   00000160   0x6900             LDR      R0,[R0, #+16]
   \   00000162   0x0680             LSLS     R0,R0,#+26
   \   00000164   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_15
   2888            {
   2889              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   \   00000166   0x6820             LDR      R0,[R4, #+0]
   \   00000168   0x68C0             LDR      R0,[R0, #+12]
   \   0000016A   0x0680             LSLS     R0,R0,#+26
   \   0000016C   0xD506             BPL.N    ??HAL_TIM_IRQHandler_15
   2890              {
   2891                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \   0000016E   0x6820             LDR      R0,[R4, #+0]
   \   00000170   0xF07F 0x0120      MVNS     R1,#+32
   \   00000174   0x6101             STR      R1,[R0, #+16]
   2892                HAL_TIMEx_CommutationCallback(htim);
   \   00000176   0x0020             MOVS     R0,R4
   \   00000178   0x.... 0x....      BL       HAL_TIMEx_CommutationCallback
   2893              }
   2894            }
   2895          }
   \                     ??HAL_TIM_IRQHandler_15:
   \   0000017C   0xBD10             POP      {R4,PC}          ;; return
   2896          
   2897          /**
   2898            * @}
   2899            */
   2900          
   2901          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2902           *  @brief   	Peripheral Control functions 
   2903           *
   2904          @verbatim 
   2905            ==============================================================================
   2906                             ##### Peripheral Control functions #####
   2907            ==============================================================================
   2908           [..]
   2909             This section provides functions allowing to:
   2910                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   2911                (+) Configure External Clock source.
   2912                (+) Configure Complementary channels, break features and dead time.
   2913                (+) Configure Master and the Slave synchronization.
   2914                (+) Configure the DMA Burst Mode.
   2915          
   2916          @endverbatim
   2917            * @{
   2918            */
   2919          
   2920          /**
   2921            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2922            *         parameters in the TIM_OC_InitTypeDef.
   2923            * @param  htim : TIM Output Compare handle
   2924            * @param  sConfig : TIM Output Compare configuration structure
   2925            * @param  Channel : TIM Channels to be enabled
   2926            *          This parameter can be one of the following values:
   2927            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2928            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2929            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2930            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2931            * @retval HAL status
   2932            */

   \                                 In section .text, align 2, keep-with-next
   2933          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2934          {
   \                     HAL_TIM_OC_ConfigChannel:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2935            /* Check the parameters */
   2936            assert_param(IS_TIM_CHANNELS(Channel));
   2937            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2938            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2939          
   2940            /* Check input state */
   2941            __HAL_LOCK(htim);
   \   00000004   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE025             B.N      ??HAL_TIM_OC_ConfigChannel_1
   \                     ??HAL_TIM_OC_ConfigChannel_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x003C      STRB     R0,[R4, #+60]
   2942          
   2943            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x003D      STRB     R0,[R4, #+61]
   2944          
   2945            switch (Channel)
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD006             BEQ.N    ??HAL_TIM_OC_ConfigChannel_2
   \   00000020   0x2A04             CMP      R2,#+4
   \   00000022   0xD008             BEQ.N    ??HAL_TIM_OC_ConfigChannel_3
   \   00000024   0x2A08             CMP      R2,#+8
   \   00000026   0xD00A             BEQ.N    ??HAL_TIM_OC_ConfigChannel_4
   \   00000028   0x2A0C             CMP      R2,#+12
   \   0000002A   0xD00C             BEQ.N    ??HAL_TIM_OC_ConfigChannel_5
   \   0000002C   0xE00F             B.N      ??HAL_TIM_OC_ConfigChannel_6
   2946            {
   2947              case TIM_CHANNEL_1:
   2948              {
   2949                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2950                /* Configure the TIM Channel 1 in Output Compare */
   2951                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_2:
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       TIM_OC1_SetConfig
   2952              }
   2953              break;
   \   00000034   0xE00B             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2954          
   2955              case TIM_CHANNEL_2:
   2956              {
   2957                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2958                /* Configure the TIM Channel 2 in Output Compare */
   2959                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3:
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC2_SetConfig
   2960              }
   2961              break;
   \   0000003C   0xE007             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2962          
   2963              case TIM_CHANNEL_3:
   2964              {
   2965                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2966                /* Configure the TIM Channel 3 in Output Compare */
   2967                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4:
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       TIM_OC3_SetConfig
   2968              }
   2969              break;
   \   00000044   0xE003             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2970          
   2971              case TIM_CHANNEL_4:
   2972              {
   2973                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2974                 /* Configure the TIM Channel 4 in Output Compare */
   2975                 TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_5:
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_OC4_SetConfig
   2976              }
   2977              break;
   \   0000004C   0xE7FF             B.N      ??HAL_TIM_OC_ConfigChannel_7
   2978          
   2979              default:
   2980              break;
   2981            }
   2982            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_6:
   \                     ??HAL_TIM_OC_ConfigChannel_7:
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF884 0x003D      STRB     R0,[R4, #+61]
   2983          
   2984            __HAL_UNLOCK(htim);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF884 0x003C      STRB     R0,[R4, #+60]
   2985          
   2986            return HAL_OK;
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_ConfigChannel_1:
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   2987          }
   2988          
   2989          /**
   2990            * @brief  Initializes the TIM Input Capture Channels according to the specified
   2991            *         parameters in the TIM_IC_InitTypeDef.
   2992            * @param  htim : TIM IC handle
   2993            * @param  sConfig : TIM Input Capture configuration structure
   2994            * @param  Channel : TIM Channels to be enabled
   2995            *          This parameter can be one of the following values:
   2996            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2997            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2998            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2999            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   3000            * @retval HAL status
   3001            */

   \                                 In section .text, align 2, keep-with-next
   3002          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   3003          {
   \                     HAL_TIM_IC_ConfigChannel:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3004            /* Check the parameters */
   3005            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3006            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3007            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3008            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3009            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3010          
   3011            __HAL_LOCK(htim);
   \   00000006   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE05F             B.N      ??HAL_TIM_IC_ConfigChannel_1
   \                     ??HAL_TIM_IC_ConfigChannel_0:
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x003C      STRB     R0,[R4, #+60]
   3012          
   3013            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x003D      STRB     R0,[R4, #+61]
   3014          
   3015            if (Channel == TIM_CHANNEL_1)
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD112             BNE.N    ??HAL_TIM_IC_ConfigChannel_2
   3016            {
   3017              /* TI1 Configuration */
   3018              TIM_TI1_SetConfig(htim->Instance,
   3019                         sConfig->ICPolarity,
   3020                         sConfig->ICSelection,
   3021                         sConfig->ICFilter);
   \   00000022   0x68EB             LDR      R3,[R5, #+12]
   \   00000024   0x686A             LDR      R2,[R5, #+4]
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_TI1_SetConfig
   3022          
   3023              /* Reset the IC1PSC Bits */
   3024              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6980             LDR      R0,[R0, #+24]
   \   00000032   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x6188             STR      R0,[R1, #+24]
   3025          
   3026              /* Set the IC1PSC value */
   3027              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6980             LDR      R0,[R0, #+24]
   \   0000003E   0x68A9             LDR      R1,[R5, #+8]
   \   00000040   0x4308             ORRS     R0,R1,R0
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6188             STR      R0,[R1, #+24]
   \   00000046   0xE03D             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3028            }
   3029            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_2:
   \   00000048   0x2A04             CMP      R2,#+4
   \   0000004A   0xD113             BNE.N    ??HAL_TIM_IC_ConfigChannel_4
   3030            {
   3031              /* TI2 Configuration */
   3032              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3033          
   3034              TIM_TI2_SetConfig(htim->Instance,
   3035                                sConfig->ICPolarity,
   3036                                sConfig->ICSelection,
   3037                                sConfig->ICFilter);
   \   0000004C   0x68EB             LDR      R3,[R5, #+12]
   \   0000004E   0x686A             LDR      R2,[R5, #+4]
   \   00000050   0x6829             LDR      R1,[R5, #+0]
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       TIM_TI2_SetConfig
   3038          
   3039              /* Reset the IC2PSC Bits */
   3040              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6980             LDR      R0,[R0, #+24]
   \   0000005C   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6188             STR      R0,[R1, #+24]
   3041          
   3042              /* Set the IC2PSC value */
   3043              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6980             LDR      R0,[R0, #+24]
   \   00000068   0x68A9             LDR      R1,[R5, #+8]
   \   0000006A   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x6188             STR      R0,[R1, #+24]
   \   00000072   0xE027             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3044            }
   3045            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_4:
   \   00000074   0x2A08             CMP      R2,#+8
   \   00000076   0xD112             BNE.N    ??HAL_TIM_IC_ConfigChannel_5
   3046            {
   3047              /* TI3 Configuration */
   3048              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3049          
   3050              TIM_TI3_SetConfig(htim->Instance,
   3051                         sConfig->ICPolarity,
   3052                         sConfig->ICSelection,
   3053                         sConfig->ICFilter);
   \   00000078   0x68EB             LDR      R3,[R5, #+12]
   \   0000007A   0x686A             LDR      R2,[R5, #+4]
   \   0000007C   0x6829             LDR      R1,[R5, #+0]
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x.... 0x....      BL       TIM_TI3_SetConfig
   3054          
   3055              /* Reset the IC3PSC Bits */
   3056              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x69C0             LDR      R0,[R0, #+28]
   \   00000088   0xF030 0x000C      BICS     R0,R0,#0xC
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x61C8             STR      R0,[R1, #+28]
   3057          
   3058              /* Set the IC3PSC value */
   3059              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x69C0             LDR      R0,[R0, #+28]
   \   00000094   0x68A9             LDR      R1,[R5, #+8]
   \   00000096   0x4308             ORRS     R0,R1,R0
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x61C8             STR      R0,[R1, #+28]
   \   0000009C   0xE012             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3060            }
   3061            else
   3062            {
   3063              /* TI4 Configuration */
   3064              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3065          
   3066              TIM_TI4_SetConfig(htim->Instance,
   3067                         sConfig->ICPolarity,
   3068                         sConfig->ICSelection,
   3069                         sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_5:
   \   0000009E   0x68EB             LDR      R3,[R5, #+12]
   \   000000A0   0x686A             LDR      R2,[R5, #+4]
   \   000000A2   0x6829             LDR      R1,[R5, #+0]
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       TIM_TI4_SetConfig
   3070          
   3071              /* Reset the IC4PSC Bits */
   3072              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x69C0             LDR      R0,[R0, #+28]
   \   000000AE   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   000000B2   0x6821             LDR      R1,[R4, #+0]
   \   000000B4   0x61C8             STR      R0,[R1, #+28]
   3073          
   3074              /* Set the IC4PSC value */
   3075              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x69C0             LDR      R0,[R0, #+28]
   \   000000BA   0x68A9             LDR      R1,[R5, #+8]
   \   000000BC   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x61C8             STR      R0,[R1, #+28]
   3076            }
   3077          
   3078            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_3:
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0xF884 0x003D      STRB     R0,[R4, #+61]
   3079          
   3080            __HAL_UNLOCK(htim);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF884 0x003C      STRB     R0,[R4, #+60]
   3081          
   3082            return HAL_OK;
   \   000000D0   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_ConfigChannel_1:
   \   000000D2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3083          }
   3084          
   3085          /**
   3086            * @brief  Initializes the TIM PWM  channels according to the specified
   3087            *         parameters in the TIM_OC_InitTypeDef.
   3088            * @param  htim : TIM handle
   3089            * @param  sConfig : TIM PWM configuration structure
   3090            * @param  Channel : TIM Channels to be enabled
   3091            *          This parameter can be one of the following values:
   3092            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3093            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3094            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3095            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3096            * @retval HAL status
   3097            */

   \                                 In section .text, align 2, keep-with-next
   3098          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3099          {
   \                     HAL_TIM_PWM_ConfigChannel:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3100            __HAL_LOCK(htim);
   \   00000006   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_PWM_ConfigChannel_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE073             B.N      ??HAL_TIM_PWM_ConfigChannel_1
   \                     ??HAL_TIM_PWM_ConfigChannel_0:
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x003C      STRB     R0,[R4, #+60]
   3101          
   3102            /* Check the parameters */
   3103            assert_param(IS_TIM_CHANNELS(Channel));
   3104            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3105            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3106            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3107          
   3108            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x003D      STRB     R0,[R4, #+61]
   3109          
   3110            switch (Channel)
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD006             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000022   0x2A04             CMP      R2,#+4
   \   00000024   0xD01B             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_3
   \   00000026   0x2A08             CMP      R2,#+8
   \   00000028   0xD031             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_4
   \   0000002A   0x2A0C             CMP      R2,#+12
   \   0000002C   0xD046             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_5
   \   0000002E   0xE05D             B.N      ??HAL_TIM_PWM_ConfigChannel_6
   3111            {
   3112              case TIM_CHANNEL_1:
   3113              {
   3114                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3115                /* Configure the Channel 1 in PWM mode */
   3116                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2:
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       TIM_OC1_SetConfig
   3117          
   3118                /* Set the Preload enable bit for channel1 */
   3119                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6980             LDR      R0,[R0, #+24]
   \   0000003C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6188             STR      R0,[R1, #+24]
   3120          
   3121                /* Configure the Output Fast mode */
   3122                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6980             LDR      R0,[R0, #+24]
   \   00000048   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x6188             STR      R0,[R1, #+24]
   3123                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6980             LDR      R0,[R0, #+24]
   \   00000054   0x6929             LDR      R1,[R5, #+16]
   \   00000056   0x4308             ORRS     R0,R1,R0
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6188             STR      R0,[R1, #+24]
   3124              }
   3125              break;
   \   0000005C   0xE046             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3126          
   3127              case TIM_CHANNEL_2:
   3128              {
   3129                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3130                /* Configure the Channel 2 in PWM mode */
   3131                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3:
   \   0000005E   0x0029             MOVS     R1,R5
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x.... 0x....      BL       TIM_OC2_SetConfig
   3132          
   3133                /* Set the Preload enable bit for channel2 */
   3134                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6980             LDR      R0,[R0, #+24]
   \   0000006A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x6188             STR      R0,[R1, #+24]
   3135          
   3136                /* Configure the Output Fast mode */
   3137                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6980             LDR      R0,[R0, #+24]
   \   00000076   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x6188             STR      R0,[R1, #+24]
   3138                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6980             LDR      R0,[R0, #+24]
   \   00000082   0x6929             LDR      R1,[R5, #+16]
   \   00000084   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6188             STR      R0,[R1, #+24]
   3139              }
   3140              break;
   \   0000008C   0xE02E             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3141          
   3142              case TIM_CHANNEL_3:
   3143              {
   3144                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3145                /* Configure the Channel 3 in PWM mode */
   3146                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4:
   \   0000008E   0x0029             MOVS     R1,R5
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x.... 0x....      BL       TIM_OC3_SetConfig
   3147          
   3148                /* Set the Preload enable bit for channel3 */
   3149                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x69C0             LDR      R0,[R0, #+28]
   \   0000009A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x61C8             STR      R0,[R1, #+28]
   3150          
   3151               /* Configure the Output Fast mode */
   3152                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x69C0             LDR      R0,[R0, #+28]
   \   000000A6   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x61C8             STR      R0,[R1, #+28]
   3153                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x69C0             LDR      R0,[R0, #+28]
   \   000000B2   0x6929             LDR      R1,[R5, #+16]
   \   000000B4   0x4308             ORRS     R0,R1,R0
   \   000000B6   0x6821             LDR      R1,[R4, #+0]
   \   000000B8   0x61C8             STR      R0,[R1, #+28]
   3154              }
   3155              break;
   \   000000BA   0xE017             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3156          
   3157              case TIM_CHANNEL_4:
   3158              {
   3159                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3160                /* Configure the Channel 4 in PWM mode */
   3161                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_5:
   \   000000BC   0x0029             MOVS     R1,R5
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x.... 0x....      BL       TIM_OC4_SetConfig
   3162          
   3163                /* Set the Preload enable bit for channel4 */
   3164                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x69C0             LDR      R0,[R0, #+28]
   \   000000C8   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000CC   0x6821             LDR      R1,[R4, #+0]
   \   000000CE   0x61C8             STR      R0,[R1, #+28]
   3165          
   3166               /* Configure the Output Fast mode */
   3167                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x69C0             LDR      R0,[R0, #+28]
   \   000000D4   0xF430 0x6080      BICS     R0,R0,#0x400
   \   000000D8   0x6821             LDR      R1,[R4, #+0]
   \   000000DA   0x61C8             STR      R0,[R1, #+28]
   3168                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x69C0             LDR      R0,[R0, #+28]
   \   000000E0   0x6929             LDR      R1,[R5, #+16]
   \   000000E2   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \   000000E6   0x6821             LDR      R1,[R4, #+0]
   \   000000E8   0x61C8             STR      R0,[R1, #+28]
   3169              }
   3170              break;
   \   000000EA   0xE7FF             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3171          
   3172              default:
   3173              break;
   3174            }
   3175          
   3176            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_6:
   \                     ??HAL_TIM_PWM_ConfigChannel_7:
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xF884 0x003D      STRB     R0,[R4, #+61]
   3177          
   3178            __HAL_UNLOCK(htim);
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF884 0x003C      STRB     R0,[R4, #+60]
   3179          
   3180            return HAL_OK;
   \   000000F8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_ConfigChannel_1:
   \   000000FA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3181          }
   3182          
   3183          /**
   3184            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3185            *         parameters in the TIM_OnePulse_InitTypeDef.
   3186            * @param  htim : TIM One Pulse handle
   3187            * @param  sConfig : TIM One Pulse configuration structure
   3188            * @param  OutputChannel : TIM Channels to be enabled
   3189            *          This parameter can be one of the following values:
   3190            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3191            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3192            * @param  InputChannel : TIM Channels to be enabled
   3193            *          This parameter can be one of the following values:
   3194            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3195            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3196            * @retval HAL status
   3197            */

   \                                 In section .text, align 2, keep-with-next
   3198          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3199          {
   \                     HAL_TIM_OnePulse_ConfigChannel:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x001E             MOVS     R6,R3
   3200            TIM_OC_InitTypeDef temp1;
   3201          
   3202            /* Check the parameters */
   3203            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3204            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3205          
   3206            if(OutputChannel != InputChannel)
   \   0000000A   0x42B2             CMP      R2,R6
   \   0000000C   0xD07D             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_0
   3207            {
   3208            __HAL_LOCK(htim);
   \   0000000E   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD101             BNE.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE078             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1:
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF884 0x003C      STRB     R0,[R4, #+60]
   3209          
   3210            htim->State = HAL_TIM_STATE_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x003D      STRB     R0,[R4, #+61]
   3211          
   3212            /* Extract the Ouput compare configuration from sConfig structure */
   3213            temp1.OCMode = sConfig->OCMode;
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x9000             STR      R0,[SP, #+0]
   3214            temp1.Pulse = sConfig->Pulse;
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   3215            temp1.OCPolarity = sConfig->OCPolarity;
   \   0000002E   0x68A8             LDR      R0,[R5, #+8]
   \   00000030   0x9002             STR      R0,[SP, #+8]
   3216            temp1.OCNPolarity = sConfig->OCNPolarity;
   \   00000032   0x68E8             LDR      R0,[R5, #+12]
   \   00000034   0x9003             STR      R0,[SP, #+12]
   3217            temp1.OCIdleState = sConfig->OCIdleState;
   \   00000036   0x6928             LDR      R0,[R5, #+16]
   \   00000038   0x9005             STR      R0,[SP, #+20]
   3218            temp1.OCNIdleState = sConfig->OCNIdleState;
   \   0000003A   0x6968             LDR      R0,[R5, #+20]
   \   0000003C   0x9006             STR      R0,[SP, #+24]
   3219          
   3220              switch (OutputChannel)
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_3
   \   00000042   0x2A04             CMP      R2,#+4
   \   00000044   0xD005             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_4
   \   00000046   0xE009             B.N      ??HAL_TIM_OnePulse_ConfigChannel_5
   3221            {
   3222              case TIM_CHANNEL_1:
   3223              {
   3224                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3225          
   3226                TIM_OC1_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3:
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_OC1_SetConfig
   3227              }
   3228              break;
   \   00000050   0xE004             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3229              case TIM_CHANNEL_2:
   3230              {
   3231                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3232          
   3233                TIM_OC2_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4:
   \   00000052   0xA900             ADD      R1,SP,#+0
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       TIM_OC2_SetConfig
   3234              }
   3235              break;
   \   0000005A   0xE7FF             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3236              default:
   3237              break;
   3238            }
   3239            switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5:
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6:
   \   0000005C   0x2E00             CMP      R6,#+0
   \   0000005E   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_7
   \   00000060   0x2E04             CMP      R6,#+4
   \   00000062   0xD025             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_8
   \   00000064   0xE049             B.N      ??HAL_TIM_OnePulse_ConfigChannel_9
   3240            {
   3241              case TIM_CHANNEL_1:
   3242              {
   3243                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3244          
   3245                TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3246                                  sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7:
   \   00000066   0x6A2B             LDR      R3,[R5, #+32]
   \   00000068   0x69EA             LDR      R2,[R5, #+28]
   \   0000006A   0x69A9             LDR      R1,[R5, #+24]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x.... 0x....      BL       TIM_TI1_SetConfig
   3247          
   3248                /* Reset the IC1PSC Bits */
   3249              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6980             LDR      R0,[R0, #+24]
   \   00000076   0xF030 0x000C      BICS     R0,R0,#0xC
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x6188             STR      R0,[R1, #+24]
   3250          
   3251                /* Select the Trigger source */
   3252                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6880             LDR      R0,[R0, #+8]
   \   00000082   0xF030 0x0070      BICS     R0,R0,#0x70
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x6088             STR      R0,[R1, #+8]
   3253                htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6880             LDR      R0,[R0, #+8]
   \   0000008E   0xF050 0x0050      ORRS     R0,R0,#0x50
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x6088             STR      R0,[R1, #+8]
   3254          
   3255                /* Select the Slave Mode */
   3256                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6880             LDR      R0,[R0, #+8]
   \   0000009A   0x08C0             LSRS     R0,R0,#+3
   \   0000009C   0x00C0             LSLS     R0,R0,#+3
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x6088             STR      R0,[R1, #+8]
   3257                htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6880             LDR      R0,[R0, #+8]
   \   000000A6   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x6088             STR      R0,[R1, #+8]
   3258              }
   3259              break;
   \   000000AE   0xE024             B.N      ??HAL_TIM_OnePulse_ConfigChannel_10
   3260              case TIM_CHANNEL_2:
   3261              {
   3262                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3263          
   3264                TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3265                           sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_8:
   \   000000B0   0x6A2B             LDR      R3,[R5, #+32]
   \   000000B2   0x69EA             LDR      R2,[R5, #+28]
   \   000000B4   0x69A9             LDR      R1,[R5, #+24]
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x.... 0x....      BL       TIM_TI2_SetConfig
   3266          
   3267                /* Reset the IC2PSC Bits */
   3268                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x6980             LDR      R0,[R0, #+24]
   \   000000C0   0xF430 0x6040      BICS     R0,R0,#0xC00
   \   000000C4   0x6821             LDR      R1,[R4, #+0]
   \   000000C6   0x6188             STR      R0,[R1, #+24]
   3269          
   3270                /* Select the Trigger source */
   3271                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6880             LDR      R0,[R0, #+8]
   \   000000CC   0xF030 0x0070      BICS     R0,R0,#0x70
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x6088             STR      R0,[R1, #+8]
   3272                htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6880             LDR      R0,[R0, #+8]
   \   000000D8   0xF050 0x0060      ORRS     R0,R0,#0x60
   \   000000DC   0x6821             LDR      R1,[R4, #+0]
   \   000000DE   0x6088             STR      R0,[R1, #+8]
   3273          
   3274                /* Select the Slave Mode */
   3275                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x6880             LDR      R0,[R0, #+8]
   \   000000E4   0x08C0             LSRS     R0,R0,#+3
   \   000000E6   0x00C0             LSLS     R0,R0,#+3
   \   000000E8   0x6821             LDR      R1,[R4, #+0]
   \   000000EA   0x6088             STR      R0,[R1, #+8]
   3276                htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6880             LDR      R0,[R0, #+8]
   \   000000F0   0xF050 0x0006      ORRS     R0,R0,#0x6
   \   000000F4   0x6821             LDR      R1,[R4, #+0]
   \   000000F6   0x6088             STR      R0,[R1, #+8]
   3277              }
   3278              break;
   \   000000F8   0xE7FF             B.N      ??HAL_TIM_OnePulse_ConfigChannel_10
   3279          
   3280              default:
   3281              break;
   3282            }
   3283          
   3284            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_9:
   \                     ??HAL_TIM_OnePulse_ConfigChannel_10:
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0xF884 0x003D      STRB     R0,[R4, #+61]
   3285          
   3286            __HAL_UNLOCK(htim);
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xF884 0x003C      STRB     R0,[R4, #+60]
   3287          
   3288            return HAL_OK;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xE000             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   3289          }
   3290            else
   3291            {
   3292              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0:
   \   0000010A   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2:
   \   0000010C   0xB008             ADD      SP,SP,#+32
   \   0000010E   0xBD70             POP      {R4-R6,PC}       ;; return
   3293            }
   3294          }
   3295          
   3296          /**
   3297            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral 
   3298            * @param  htim : TIM handle
   3299            * @param  BurstBaseAddress : TIM Base address from where the DMA will start the Data write
   3300            *         This parameter can be one of the following values:
   3301            *            @arg TIM_DMABASE_CR1 
   3302            *            @arg TIM_DMABASE_CR2
   3303            *            @arg TIM_DMABASE_SMCR
   3304            *            @arg TIM_DMABASE_DIER
   3305            *            @arg TIM_DMABASE_SR
   3306            *            @arg TIM_DMABASE_EGR
   3307            *            @arg TIM_DMABASE_CCMR1
   3308            *            @arg TIM_DMABASE_CCMR2
   3309            *            @arg TIM_DMABASE_CCER
   3310            *            @arg TIM_DMABASE_CNT 
   3311            *            @arg TIM_DMABASE_PSC 
   3312            *            @arg TIM_DMABASE_ARR
   3313            *            @arg TIM_DMABASE_RCR
   3314            *            @arg TIM_DMABASE_CCR1
   3315            *            @arg TIM_DMABASE_CCR2
   3316            *            @arg TIM_DMABASE_CCR3 
   3317            *            @arg TIM_DMABASE_CCR4
   3318            *            @arg TIM_DMABASE_BDTR
   3319            *            @arg TIM_DMABASE_DCR
   3320            * @param  BurstRequestSrc : TIM DMA Request sources
   3321            *         This parameter can be one of the following values:
   3322            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3323            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3324            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3325            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3326            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3327            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3328            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3329            * @param  BurstBuffer : The Buffer address.
   3330            * @param  BurstLength : DMA Burst length. This parameter can be one value
   3331            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3332            * @retval HAL status
   3333            */

   \                                 In section .text, align 2, keep-with-next
   3334          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3335                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3336          {
   \                     HAL_TIM_DMABurst_WriteStart:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x0019             MOVS     R1,R3
   \   0000000A   0x9F06             LDR      R7,[SP, #+24]
   3337            /* Check the parameters */
   3338            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3339            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3340            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3341            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3342          
   3343            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000C   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD101             BNE.N    ??HAL_TIM_DMABurst_WriteStart_0
   3344            {
   3345               return HAL_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE0A7             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3346            }
   3347            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_DMABurst_WriteStart_0:
   \   00000018   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD108             BNE.N    ??HAL_TIM_DMABurst_WriteStart_2
   3348            {
   3349              if((BurstBuffer == 0U) && (BurstLength > 0U))
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD103             BNE.N    ??HAL_TIM_DMABurst_WriteStart_3
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   3350              {
   3351                return HAL_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE09D             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3352              }
   3353              else
   3354              {
   3355                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_3:
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x003D      STRB     R0,[R4, #+61]
   3356              }
   3357            }
   3358            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_2:
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \   0000003A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000003E   0xD020             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \   00000040   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000044   0xD02E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \   00000046   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004A   0xD03C             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \   0000004C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000050   0xD04A             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \   00000052   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000056   0xD058             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_9
   \   00000058   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005C   0xD066             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_10
   \   0000005E   0xE076             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3359            {
   3360              case TIM_DMA_UPDATE:
   3361              {
   3362                /* Set the DMA Period elapsed callback */
   3363                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4:
   \   00000060   0x6A20             LDR      R0,[R4, #+32]
   \   00000062   0x.... 0x....      ADR.W    R2,TIM_DMAPeriodElapsedCplt
   \   00000066   0x6282             STR      R2,[R0, #+40]
   3364          
   3365                /* Set the DMA error callback */
   3366                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000068   0x6A20             LDR      R0,[R4, #+32]
   \   0000006A   0x.... 0x....      ADR.W    R2,TIM_DMAError
   \   0000006E   0x6302             STR      R2,[R0, #+48]
   3367          
   3368                /* Enable the DMA channel */
   3369                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   \   00000070   0x0A38             LSRS     R0,R7,#+8
   \   00000072   0x1C43             ADDS     R3,R0,#+1
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF110 0x024C      ADDS     R2,R0,#+76
   \   0000007A   0x6A20             LDR      R0,[R4, #+32]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
   3370              }
   3371              break;
   \   00000080   0xE065             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3372              case TIM_DMA_CC1:
   3373              {
   3374                /* Set the DMA Period elapsed callback */
   3375                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5:
   \   00000082   0x6A60             LDR      R0,[R4, #+36]
   \   00000084   0x.... 0x....      ADR.W    R2,TIM_DMADelayPulseCplt
   \   00000088   0x6282             STR      R2,[R0, #+40]
   3376          
   3377                /* Set the DMA error callback */
   3378                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000008A   0x6A60             LDR      R0,[R4, #+36]
   \   0000008C   0x.... 0x....      ADR.W    R2,TIM_DMAError
   \   00000090   0x6302             STR      R2,[R0, #+48]
   3379          
   3380                /* Enable the DMA channel */
   3381                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   \   00000092   0x0A38             LSRS     R0,R7,#+8
   \   00000094   0x1C43             ADDS     R3,R0,#+1
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0xF110 0x024C      ADDS     R2,R0,#+76
   \   0000009C   0x6A60             LDR      R0,[R4, #+36]
   \   0000009E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3382              }
   3383              break;
   \   000000A2   0xE054             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3384              case TIM_DMA_CC2:
   3385              {
   3386                /* Set the DMA Period elapsed callback */
   3387                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6:
   \   000000A4   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A6   0x.... 0x....      ADR.W    R2,TIM_DMADelayPulseCplt
   \   000000AA   0x6282             STR      R2,[R0, #+40]
   3388          
   3389                /* Set the DMA error callback */
   3390                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000AC   0x6AA0             LDR      R0,[R4, #+40]
   \   000000AE   0x.... 0x....      ADR.W    R2,TIM_DMAError
   \   000000B2   0x6302             STR      R2,[R0, #+48]
   3391          
   3392                /* Enable the DMA channel */
   3393                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   \   000000B4   0x0A38             LSRS     R0,R7,#+8
   \   000000B6   0x1C43             ADDS     R3,R0,#+1
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0xF110 0x024C      ADDS     R2,R0,#+76
   \   000000BE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3394              }
   3395              break;
   \   000000C4   0xE043             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3396              case TIM_DMA_CC3:
   3397              {
   3398                /* Set the DMA Period elapsed callback */
   3399                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7:
   \   000000C6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C8   0x.... 0x....      ADR.W    R2,TIM_DMADelayPulseCplt
   \   000000CC   0x6282             STR      R2,[R0, #+40]
   3400          
   3401                /* Set the DMA error callback */
   3402                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000CE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D0   0x.... 0x....      ADR.W    R2,TIM_DMAError
   \   000000D4   0x6302             STR      R2,[R0, #+48]
   3403          
   3404                /* Enable the DMA channel */
   3405                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   \   000000D6   0x0A38             LSRS     R0,R7,#+8
   \   000000D8   0x1C43             ADDS     R3,R0,#+1
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0xF110 0x024C      ADDS     R2,R0,#+76
   \   000000E0   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E2   0x.... 0x....      BL       HAL_DMA_Start_IT
   3406              }
   3407              break;
   \   000000E6   0xE032             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3408              case TIM_DMA_CC4:
   3409              {
   3410                /* Set the DMA Period elapsed callback */
   3411                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8:
   \   000000E8   0x6B20             LDR      R0,[R4, #+48]
   \   000000EA   0x.... 0x....      ADR.W    R2,TIM_DMADelayPulseCplt
   \   000000EE   0x6282             STR      R2,[R0, #+40]
   3412          
   3413                /* Set the DMA error callback */
   3414                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000F0   0x6B20             LDR      R0,[R4, #+48]
   \   000000F2   0x.... 0x....      ADR.W    R2,TIM_DMAError
   \   000000F6   0x6302             STR      R2,[R0, #+48]
   3415          
   3416                /* Enable the DMA channel */
   3417                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   \   000000F8   0x0A38             LSRS     R0,R7,#+8
   \   000000FA   0x1C43             ADDS     R3,R0,#+1
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0xF110 0x024C      ADDS     R2,R0,#+76
   \   00000102   0x6B20             LDR      R0,[R4, #+48]
   \   00000104   0x.... 0x....      BL       HAL_DMA_Start_IT
   3418              }
   3419              break;
   \   00000108   0xE021             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3420              case TIM_DMA_COM:
   3421              {
   3422                /* Set the DMA Period elapsed callback */
   3423                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9:
   \   0000010A   0x6B60             LDR      R0,[R4, #+52]
   \   0000010C   0x.... 0x....      LDR.W    R2,??DataTable27
   \   00000110   0x6282             STR      R2,[R0, #+40]
   3424          
   3425                /* Set the DMA error callback */
   3426                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \   00000112   0x6B60             LDR      R0,[R4, #+52]
   \   00000114   0x.... 0x....      ADR.W    R2,TIM_DMAError
   \   00000118   0x6302             STR      R2,[R0, #+48]
   3427          
   3428                /* Enable the DMA channel */
   3429                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   \   0000011A   0x0A38             LSRS     R0,R7,#+8
   \   0000011C   0x1C43             ADDS     R3,R0,#+1
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0xF110 0x024C      ADDS     R2,R0,#+76
   \   00000124   0x6B60             LDR      R0,[R4, #+52]
   \   00000126   0x.... 0x....      BL       HAL_DMA_Start_IT
   3430              }
   3431              break;
   \   0000012A   0xE010             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3432              case TIM_DMA_TRIGGER:
   3433              {
   3434                /* Set the DMA Period elapsed callback */
   3435                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_10:
   \   0000012C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000012E   0x.... 0x....      ADR.W    R2,TIM_DMATriggerCplt
   \   00000132   0x6282             STR      R2,[R0, #+40]
   3436          
   3437                /* Set the DMA error callback */
   3438                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \   00000134   0x6BA0             LDR      R0,[R4, #+56]
   \   00000136   0x.... 0x....      ADR.W    R2,TIM_DMAError
   \   0000013A   0x6302             STR      R2,[R0, #+48]
   3439          
   3440                /* Enable the DMA channel */
   3441                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   \   0000013C   0x0A38             LSRS     R0,R7,#+8
   \   0000013E   0x1C43             ADDS     R3,R0,#+1
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0xF110 0x024C      ADDS     R2,R0,#+76
   \   00000146   0x6BA0             LDR      R0,[R4, #+56]
   \   00000148   0x.... 0x....      BL       HAL_DMA_Start_IT
   3442              }
   3443              break;
   \   0000014C   0xE7FF             B.N      ??HAL_TIM_DMABurst_WriteStart_12
   3444              default:
   3445              break;
   3446            }
   3447             /* configure the DMA Burst Mode */
   3448             htim->Instance->DCR = BurstBaseAddress | BurstLength;
   \                     ??HAL_TIM_DMABurst_WriteStart_11:
   \                     ??HAL_TIM_DMABurst_WriteStart_12:
   \   0000014E   0xEA57 0x0005      ORRS     R0,R7,R5
   \   00000152   0x6821             LDR      R1,[R4, #+0]
   \   00000154   0x6488             STR      R0,[R1, #+72]
   3449          
   3450             /* Enable the TIM DMA Request */
   3451             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000156   0x6820             LDR      R0,[R4, #+0]
   \   00000158   0x68C0             LDR      R0,[R0, #+12]
   \   0000015A   0x4330             ORRS     R0,R6,R0
   \   0000015C   0x6821             LDR      R1,[R4, #+0]
   \   0000015E   0x60C8             STR      R0,[R1, #+12]
   3452          
   3453             htim->State = HAL_TIM_STATE_READY;
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0xF884 0x003D      STRB     R0,[R4, #+61]
   3454          
   3455            /* Return function status */
   3456            return HAL_OK;
   \   00000166   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_1:
   \   00000168   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3457          }
   3458          
   3459          /**
   3460            * @brief  Stops the TIM DMA Burst mode 
   3461            * @param  htim : TIM handle
   3462            * @param  BurstRequestSrc : TIM DMA Request sources to disable
   3463            * @retval HAL status
   3464            */

   \                                 In section .text, align 2, keep-with-next
   3465          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3466          {
   \                     HAL_TIM_DMABurst_WriteStop:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3467            /* Check the parameters */
   3468            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3469          
   3470            /* Abort the DMA transfer (at least disable the DMA channel) */
   3471            switch(BurstRequestSrc)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD013             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD014             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD015             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD016             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_4
   \   00000026   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002A   0xD017             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_5
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD018             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_6
   \   00000032   0xE01B             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3472            {
   3473              case TIM_DMA_UPDATE:
   3474              {
   3475                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0:
   \   00000034   0x6A20             LDR      R0,[R4, #+32]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
   3476              }
   3477              break;
   \   0000003A   0xE017             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3478              case TIM_DMA_CC1:
   3479              {
   3480                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1:
   \   0000003C   0x6A60             LDR      R0,[R4, #+36]
   \   0000003E   0x.... 0x....      BL       HAL_DMA_Abort
   3481              }
   3482              break;
   \   00000042   0xE013             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3483              case TIM_DMA_CC2:
   3484              {
   3485                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2:
   \   00000044   0x6AA0             LDR      R0,[R4, #+40]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   3486              }
   3487              break;
   \   0000004A   0xE00F             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3488              case TIM_DMA_CC3:
   3489              {
   3490                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3:
   \   0000004C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3491              }
   3492              break;
   \   00000052   0xE00B             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3493              case TIM_DMA_CC4:
   3494              {
   3495                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4:
   \   00000054   0x6B20             LDR      R0,[R4, #+48]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   3496              }
   3497              break;
   \   0000005A   0xE007             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3498              case TIM_DMA_COM:
   3499              {
   3500                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5:
   \   0000005C   0x6B60             LDR      R0,[R4, #+52]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Abort
   3501              }
   3502              break;
   \   00000062   0xE003             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3503              case TIM_DMA_TRIGGER:
   3504              {
   3505                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_6:
   \   00000064   0x6BA0             LDR      R0,[R4, #+56]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort
   3506              }
   3507              break;
   \   0000006A   0xE7FF             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3508              default:
   3509              break;
   3510            }
   3511          
   3512            /* Disable the TIM Update DMA request */
   3513            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_WriteStop_7:
   \                     ??HAL_TIM_DMABurst_WriteStop_8:
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0x43A8             BICS     R0,R0,R5
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x60C8             STR      R0,[R1, #+12]
   3514          
   3515            /* Return function status */
   3516            return HAL_OK;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3517          }
   3518          
   3519          /**
   3520            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3521            * @param  htim : TIM handle
   3522            * @param  BurstBaseAddress : TIM Base address from where the DMA will starts the Data read
   3523            *         This parameter can be one of the following values:
   3524            *            @arg TIM_DMABASE_CR1 
   3525            *            @arg TIM_DMABASE_CR2
   3526            *            @arg TIM_DMABASE_SMCR
   3527            *            @arg TIM_DMABASE_DIER
   3528            *            @arg TIM_DMABASE_SR
   3529            *            @arg TIM_DMABASE_EGR
   3530            *            @arg TIM_DMABASE_CCMR1
   3531            *            @arg TIM_DMABASE_CCMR2
   3532            *            @arg TIM_DMABASE_CCER
   3533            *            @arg TIM_DMABASE_CNT 
   3534            *            @arg TIM_DMABASE_PSC 
   3535            *            @arg TIM_DMABASE_ARR
   3536            *            @arg TIM_DMABASE_RCR
   3537            *            @arg TIM_DMABASE_CCR1
   3538            *            @arg TIM_DMABASE_CCR2
   3539            *            @arg TIM_DMABASE_CCR3 
   3540            *            @arg TIM_DMABASE_CCR4
   3541            *            @arg TIM_DMABASE_BDTR
   3542            *            @arg TIM_DMABASE_DCR
   3543            * @param  BurstRequestSrc : TIM DMA Request sources
   3544            *         This parameter can be one of the following values:
   3545            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3546            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3547            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3548            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3549            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3550            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3551            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3552            * @param  BurstBuffer : The Buffer address.
   3553            * @param  BurstLength : DMA Burst length. This parameter can be one value
   3554            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3555            * @retval HAL status
   3556            */

   \                                 In section .text, align 2, keep-with-next
   3557          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3558                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3559          {
   \                     HAL_TIM_DMABurst_ReadStart:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001A             MOVS     R2,R3
   \   0000000A   0x9F06             LDR      R7,[SP, #+24]
   3560            /* Check the parameters */
   3561            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3562            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3563            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3564            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3565          
   3566            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000C   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD101             BNE.N    ??HAL_TIM_DMABurst_ReadStart_0
   3567            {
   3568               return HAL_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE0A7             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   3569            }
   3570            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_DMABurst_ReadStart_0:
   \   00000018   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD108             BNE.N    ??HAL_TIM_DMABurst_ReadStart_2
   3571            {
   3572              if((BurstBuffer == 0U) && (BurstLength > 0U))
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD103             BNE.N    ??HAL_TIM_DMABurst_ReadStart_3
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   3573              {
   3574                return HAL_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE09D             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   3575              }
   3576              else
   3577              {
   3578                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_3:
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF884 0x003D      STRB     R0,[R4, #+61]
   3579              }
   3580            }
   3581            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_2:
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \   0000003A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000003E   0xD020             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \   00000040   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000044   0xD02E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \   00000046   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004A   0xD03C             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \   0000004C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000050   0xD04A             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \   00000052   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000056   0xD058             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_9
   \   00000058   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005C   0xD066             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_10
   \   0000005E   0xE076             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3582            {
   3583              case TIM_DMA_UPDATE:
   3584              {
   3585                /* Set the DMA Period elapsed callback */
   3586                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4:
   \   00000060   0x6A20             LDR      R0,[R4, #+32]
   \   00000062   0x.... 0x....      ADR.W    R1,TIM_DMAPeriodElapsedCplt
   \   00000066   0x6281             STR      R1,[R0, #+40]
   3587          
   3588                /* Set the DMA error callback */
   3589                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000068   0x6A20             LDR      R0,[R4, #+32]
   \   0000006A   0x.... 0x....      ADR.W    R1,TIM_DMAError
   \   0000006E   0x6301             STR      R1,[R0, #+48]
   3590          
   3591                /* Enable the DMA channel */
   3592                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   \   00000070   0x0A38             LSRS     R0,R7,#+8
   \   00000072   0x1C43             ADDS     R3,R0,#+1
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF110 0x014C      ADDS     R1,R0,#+76
   \   0000007A   0x6A20             LDR      R0,[R4, #+32]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
   3593              }
   3594              break;
   \   00000080   0xE065             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3595              case TIM_DMA_CC1:
   3596              {
   3597                /* Set the DMA Period elapsed callback */
   3598                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5:
   \   00000082   0x6A60             LDR      R0,[R4, #+36]
   \   00000084   0x.... 0x....      ADR.W    R1,TIM_DMACaptureCplt
   \   00000088   0x6281             STR      R1,[R0, #+40]
   3599          
   3600                /* Set the DMA error callback */
   3601                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000008A   0x6A60             LDR      R0,[R4, #+36]
   \   0000008C   0x.... 0x....      ADR.W    R1,TIM_DMAError
   \   00000090   0x6301             STR      R1,[R0, #+48]
   3602          
   3603                /* Enable the DMA channel */
   3604                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   \   00000092   0x0A38             LSRS     R0,R7,#+8
   \   00000094   0x1C43             ADDS     R3,R0,#+1
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0xF110 0x014C      ADDS     R1,R0,#+76
   \   0000009C   0x6A60             LDR      R0,[R4, #+36]
   \   0000009E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3605              }
   3606              break;
   \   000000A2   0xE054             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3607              case TIM_DMA_CC2:
   3608              {
   3609                /* Set the DMA Period elapsed callback */
   3610                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6:
   \   000000A4   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A6   0x.... 0x....      ADR.W    R1,TIM_DMACaptureCplt
   \   000000AA   0x6281             STR      R1,[R0, #+40]
   3611          
   3612                /* Set the DMA error callback */
   3613                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000AC   0x6AA0             LDR      R0,[R4, #+40]
   \   000000AE   0x.... 0x....      ADR.W    R1,TIM_DMAError
   \   000000B2   0x6301             STR      R1,[R0, #+48]
   3614          
   3615                /* Enable the DMA channel */
   3616                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   \   000000B4   0x0A38             LSRS     R0,R7,#+8
   \   000000B6   0x1C43             ADDS     R3,R0,#+1
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0xF110 0x014C      ADDS     R1,R0,#+76
   \   000000BE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3617              }
   3618              break;
   \   000000C4   0xE043             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3619              case TIM_DMA_CC3:
   3620              {
   3621                /* Set the DMA Period elapsed callback */
   3622                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7:
   \   000000C6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C8   0x.... 0x....      ADR.W    R1,TIM_DMACaptureCplt
   \   000000CC   0x6281             STR      R1,[R0, #+40]
   3623          
   3624                /* Set the DMA error callback */
   3625                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000CE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D0   0x.... 0x....      ADR.W    R1,TIM_DMAError
   \   000000D4   0x6301             STR      R1,[R0, #+48]
   3626          
   3627                /* Enable the DMA channel */
   3628                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   \   000000D6   0x0A38             LSRS     R0,R7,#+8
   \   000000D8   0x1C43             ADDS     R3,R0,#+1
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0xF110 0x014C      ADDS     R1,R0,#+76
   \   000000E0   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E2   0x.... 0x....      BL       HAL_DMA_Start_IT
   3629              }
   3630              break;
   \   000000E6   0xE032             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3631              case TIM_DMA_CC4:
   3632              {
   3633                /* Set the DMA Period elapsed callback */
   3634                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8:
   \   000000E8   0x6B20             LDR      R0,[R4, #+48]
   \   000000EA   0x.... 0x....      ADR.W    R1,TIM_DMACaptureCplt
   \   000000EE   0x6281             STR      R1,[R0, #+40]
   3635          
   3636                /* Set the DMA error callback */
   3637                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000F0   0x6B20             LDR      R0,[R4, #+48]
   \   000000F2   0x.... 0x....      ADR.W    R1,TIM_DMAError
   \   000000F6   0x6301             STR      R1,[R0, #+48]
   3638          
   3639                /* Enable the DMA channel */
   3640                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   \   000000F8   0x0A38             LSRS     R0,R7,#+8
   \   000000FA   0x1C43             ADDS     R3,R0,#+1
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0xF110 0x014C      ADDS     R1,R0,#+76
   \   00000102   0x6B20             LDR      R0,[R4, #+48]
   \   00000104   0x.... 0x....      BL       HAL_DMA_Start_IT
   3641              }
   3642              break;
   \   00000108   0xE021             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3643              case TIM_DMA_COM:
   3644              {
   3645                /* Set the DMA Period elapsed callback */
   3646                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9:
   \   0000010A   0x6B60             LDR      R0,[R4, #+52]
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000110   0x6281             STR      R1,[R0, #+40]
   3647          
   3648                /* Set the DMA error callback */
   3649                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \   00000112   0x6B60             LDR      R0,[R4, #+52]
   \   00000114   0x.... 0x....      ADR.W    R1,TIM_DMAError
   \   00000118   0x6301             STR      R1,[R0, #+48]
   3650          
   3651                /* Enable the DMA channel */
   3652                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   \   0000011A   0x0A38             LSRS     R0,R7,#+8
   \   0000011C   0x1C43             ADDS     R3,R0,#+1
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0xF110 0x014C      ADDS     R1,R0,#+76
   \   00000124   0x6B60             LDR      R0,[R4, #+52]
   \   00000126   0x.... 0x....      BL       HAL_DMA_Start_IT
   3653              }
   3654              break;
   \   0000012A   0xE010             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3655              case TIM_DMA_TRIGGER:
   3656              {
   3657                /* Set the DMA Period elapsed callback */
   3658                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_10:
   \   0000012C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000012E   0x.... 0x....      ADR.W    R1,TIM_DMATriggerCplt
   \   00000132   0x6281             STR      R1,[R0, #+40]
   3659          
   3660                /* Set the DMA error callback */
   3661                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \   00000134   0x6BA0             LDR      R0,[R4, #+56]
   \   00000136   0x.... 0x....      ADR.W    R1,TIM_DMAError
   \   0000013A   0x6301             STR      R1,[R0, #+48]
   3662          
   3663                /* Enable the DMA channel */
   3664                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   \   0000013C   0x0A38             LSRS     R0,R7,#+8
   \   0000013E   0x1C43             ADDS     R3,R0,#+1
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0xF110 0x014C      ADDS     R1,R0,#+76
   \   00000146   0x6BA0             LDR      R0,[R4, #+56]
   \   00000148   0x.... 0x....      BL       HAL_DMA_Start_IT
   3665              }
   3666              break;
   \   0000014C   0xE7FF             B.N      ??HAL_TIM_DMABurst_ReadStart_12
   3667              default:
   3668              break;
   3669            }
   3670          
   3671            /* configure the DMA Burst Mode */
   3672            htim->Instance->DCR = BurstBaseAddress | BurstLength;
   \                     ??HAL_TIM_DMABurst_ReadStart_11:
   \                     ??HAL_TIM_DMABurst_ReadStart_12:
   \   0000014E   0xEA57 0x0005      ORRS     R0,R7,R5
   \   00000152   0x6821             LDR      R1,[R4, #+0]
   \   00000154   0x6488             STR      R0,[R1, #+72]
   3673          
   3674            /* Enable the TIM DMA Request */
   3675            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000156   0x6820             LDR      R0,[R4, #+0]
   \   00000158   0x68C0             LDR      R0,[R0, #+12]
   \   0000015A   0x4330             ORRS     R0,R6,R0
   \   0000015C   0x6821             LDR      R1,[R4, #+0]
   \   0000015E   0x60C8             STR      R0,[R1, #+12]
   3676          
   3677            htim->State = HAL_TIM_STATE_READY;
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0xF884 0x003D      STRB     R0,[R4, #+61]
   3678          
   3679            /* Return function status */
   3680            return HAL_OK;
   \   00000166   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_1:
   \   00000168   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3681          }
   3682          
   3683          /**
   3684            * @brief  Stop the DMA burst reading 
   3685            * @param  htim : TIM handle
   3686            * @param  BurstRequestSrc : TIM DMA Request sources to disable.
   3687            * @retval HAL status
   3688            */

   \                                 In section .text, align 2, keep-with-next
   3689          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3690          {
   \                     HAL_TIM_DMABurst_ReadStop:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3691            /* Check the parameters */
   3692            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3693          
   3694            /* Abort the DMA transfer (at least disable the DMA channel) */
   3695            switch(BurstRequestSrc)
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD013             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD014             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD015             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD016             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_4
   \   00000026   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002A   0xD017             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_5
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD018             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_6
   \   00000032   0xE01B             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3696            {
   3697              case TIM_DMA_UPDATE:
   3698              {
   3699                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0:
   \   00000034   0x6A20             LDR      R0,[R4, #+32]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
   3700              }
   3701              break;
   \   0000003A   0xE017             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3702              case TIM_DMA_CC1:
   3703              {
   3704                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1:
   \   0000003C   0x6A60             LDR      R0,[R4, #+36]
   \   0000003E   0x.... 0x....      BL       HAL_DMA_Abort
   3705              }
   3706              break;
   \   00000042   0xE013             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3707              case TIM_DMA_CC2:
   3708              {
   3709                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2:
   \   00000044   0x6AA0             LDR      R0,[R4, #+40]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   3710              }
   3711              break;
   \   0000004A   0xE00F             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3712              case TIM_DMA_CC3:
   3713              {
   3714                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3:
   \   0000004C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3715              }
   3716              break;
   \   00000052   0xE00B             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3717              case TIM_DMA_CC4:
   3718              {
   3719                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4:
   \   00000054   0x6B20             LDR      R0,[R4, #+48]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   3720              }
   3721              break;
   \   0000005A   0xE007             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3722              case TIM_DMA_COM:
   3723              {
   3724                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5:
   \   0000005C   0x6B60             LDR      R0,[R4, #+52]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Abort
   3725              }
   3726              break;
   \   00000062   0xE003             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3727              case TIM_DMA_TRIGGER:
   3728              {
   3729                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_6:
   \   00000064   0x6BA0             LDR      R0,[R4, #+56]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort
   3730              }
   3731              break;
   \   0000006A   0xE7FF             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3732              default:
   3733              break;
   3734            }
   3735          
   3736            /* Disable the TIM Update DMA request */
   3737            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_ReadStop_7:
   \                     ??HAL_TIM_DMABurst_ReadStop_8:
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0x43A8             BICS     R0,R0,R5
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x60C8             STR      R0,[R1, #+12]
   3738          
   3739            /* Return function status */
   3740            return HAL_OK;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3741          }
   3742          
   3743          /**
   3744            * @brief  Generate a software event
   3745            * @param  htim : TIM handle
   3746            * @param  EventSource : specifies the event source.
   3747            *          This parameter can be one of the following values:
   3748            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3749            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3750            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3751            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3752            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3753            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source 
   3754            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3755            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3756            * @note TIM6 and TIM7 can only generate an update event.
   3757            * @note TIM_EVENTSOURCE_COM and TIM_EVENTSOURCE_BREAK are used only with TIM1, TIM15, TIM16 and TIM17.
   3758            * @retval HAL status
   3759            */
   3760          

   \                                 In section .text, align 2, keep-with-next
   3761          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3762          {
   3763            /* Check the parameters */
   3764            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3765            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3766          
   3767            /* Process Locked */
   3768            __HAL_LOCK(htim);
   \                     HAL_TIM_GenerateEvent:
   \   00000000   0xF890 0x203C      LDRB     R2,[R0, #+60]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xE00E             B.N      ??HAL_TIM_GenerateEvent_1
   \                     ??HAL_TIM_GenerateEvent_0:
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x203C      STRB     R2,[R0, #+60]
   3769          
   3770            /* Change the TIM state */
   3771            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x203D      STRB     R2,[R0, #+61]
   3772          
   3773            /* Set the event sources */
   3774            htim->Instance->EGR = EventSource;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6151             STR      R1,[R2, #+20]
   3775          
   3776            /* Change the TIM state */
   3777            htim->State = HAL_TIM_STATE_READY;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF880 0x103D      STRB     R1,[R0, #+61]
   3778          
   3779            __HAL_UNLOCK(htim);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF880 0x103C      STRB     R1,[R0, #+60]
   3780          
   3781            /* Return function status */
   3782            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_GenerateEvent_1:
   \   0000002A   0x4770             BX       LR               ;; return
   3783          }
   3784          
   3785          /**
   3786            * @brief  Configures the OCRef clear feature
   3787            * @param  htim : TIM handle
   3788            * @param  sClearInputConfig : pointer to a TIM_ClearInputConfigTypeDef structure that
   3789            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   3790            * @param  Channel : specifies the TIM Channel
   3791            *          This parameter can be one of the following values:
   3792            *            @arg TIM_CHANNEL_1: TIM Channel 1
   3793            *            @arg TIM_CHANNEL_2: TIM Channel 2
   3794            *            @arg TIM_CHANNEL_3: TIM Channel 3
   3795            *            @arg TIM_CHANNEL_4: TIM Channel 4
   3796            * @retval HAL status
   3797            */ 

   \                                 In section .text, align 2, keep-with-next
   3798          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3799          {
   \                     HAL_TIM_ConfigOCrefClear:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   3800            uint32_t tmpsmcr = 0U;
   \   00000008   0x2000             MOVS     R0,#+0
   3801          
   3802            /* Check the parameters */
   3803            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   3804            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3805            assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3806            assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3807            assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3808          
   3809            /* Process Locked */
   3810            __HAL_LOCK(htim);
   \   0000000A   0xF894 0x103C      LDRB     R1,[R4, #+60]
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD101             BNE.N    ??HAL_TIM_ConfigOCrefClear_0
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xE06B             B.N      ??HAL_TIM_ConfigOCrefClear_1
   \                     ??HAL_TIM_ConfigOCrefClear_0:
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0xF884 0x103C      STRB     R1,[R4, #+60]
   3811          
   3812            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001C   0x2102             MOVS     R1,#+2
   \   0000001E   0xF884 0x103D      STRB     R1,[R4, #+61]
   3813          
   3814            switch (sClearInputConfig->ClearInputSource)
   \   00000022   0x6869             LDR      R1,[R5, #+4]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD002             BEQ.N    ??HAL_TIM_ConfigOCrefClear_2
   \   00000028   0x2901             CMP      R1,#+1
   \   0000002A   0xD005             BEQ.N    ??HAL_TIM_ConfigOCrefClear_3
   \   0000002C   0xE00B             B.N      ??HAL_TIM_ConfigOCrefClear_4
   3815            {
   3816              case TIM_CLEARINPUTSOURCE_NONE:
   3817              {
   3818          
   3819                /* Clear the ETR Bits */
   3820                tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \                     ??HAL_TIM_ConfigOCrefClear_2:
   \   0000002E   0xF430 0x407F      BICS     R0,R0,#0xFF00
   3821          
   3822                /* Set TIMx_SMCR */
   3823                htim->Instance->SMCR = tmpsmcr;
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6088             STR      R0,[R1, #+8]
   3824             }
   3825              break;
   \   00000036   0xE006             B.N      ??HAL_TIM_ConfigOCrefClear_5
   3826          
   3827              case TIM_CLEARINPUTSOURCE_ETR:
   3828              {
   3829                TIM_ETR_SetConfig(htim->Instance,
   3830                                  sClearInputConfig->ClearInputPrescaler,
   3831                                  sClearInputConfig->ClearInputPolarity,
   3832                                  sClearInputConfig->ClearInputFilter);
   \                     ??HAL_TIM_ConfigOCrefClear_3:
   \   00000038   0x692B             LDR      R3,[R5, #+16]
   \   0000003A   0x68AA             LDR      R2,[R5, #+8]
   \   0000003C   0x68E9             LDR      R1,[R5, #+12]
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       TIM_ETR_SetConfig
   3833          
   3834              }
   3835              break;
   \   00000044   0xE7FF             B.N      ??HAL_TIM_ConfigOCrefClear_5
   3836              default:
   3837              break;
   3838            }
   3839          
   3840            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_4:
   \                     ??HAL_TIM_ConfigOCrefClear_5:
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_6
   \   0000004A   0x2E04             CMP      R6,#+4
   \   0000004C   0xD015             BEQ.N    ??HAL_TIM_ConfigOCrefClear_7
   \   0000004E   0x2E08             CMP      R6,#+8
   \   00000050   0xD024             BEQ.N    ??HAL_TIM_ConfigOCrefClear_8
   \   00000052   0x2E0C             CMP      R6,#+12
   \   00000054   0xD033             BEQ.N    ??HAL_TIM_ConfigOCrefClear_9
   \   00000056   0xE043             B.N      ??HAL_TIM_ConfigOCrefClear_10
   3841            {
   3842              case TIM_CHANNEL_1:
   3843                {
   3844                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_6:
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_11
   3845                  {
   3846                    /* Enable the Ocref clear feature for Channel 1 */
   3847                    htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6980             LDR      R0,[R0, #+24]
   \   00000062   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6188             STR      R0,[R1, #+24]
   \   0000006A   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_12
   3848                  }
   3849                  else
   3850                  {
   3851                    /* Disable the Ocref clear feature for Channel 1 */
   3852                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
   \                     ??HAL_TIM_ConfigOCrefClear_11:
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6980             LDR      R0,[R0, #+24]
   \   00000070   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6188             STR      R0,[R1, #+24]
   3853                  }
   3854                }
   3855                break;
   \                     ??HAL_TIM_ConfigOCrefClear_12:
   \   00000078   0xE032             B.N      ??HAL_TIM_ConfigOCrefClear_13
   3856              case TIM_CHANNEL_2:
   3857                {
   3858                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3859                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_7:
   \   0000007A   0x6828             LDR      R0,[R5, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_14
   3860                  {
   3861                    /* Enable the Ocref clear feature for Channel 2 */
   3862                    htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6980             LDR      R0,[R0, #+24]
   \   00000084   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6188             STR      R0,[R1, #+24]
   \   0000008C   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_15
   3863                  }
   3864                  else
   3865                  {
   3866                    /* Disable the Ocref clear feature for Channel 2 */
   3867                    htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
   \                     ??HAL_TIM_ConfigOCrefClear_14:
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6980             LDR      R0,[R0, #+24]
   \   00000092   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x6188             STR      R0,[R1, #+24]
   3868                  }
   3869                }
   3870              break;
   \                     ??HAL_TIM_ConfigOCrefClear_15:
   \   0000009A   0xE021             B.N      ??HAL_TIM_ConfigOCrefClear_13
   3871              case TIM_CHANNEL_3:
   3872                {
   3873                  assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3874                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_8:
   \   0000009C   0x6828             LDR      R0,[R5, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_16
   3875                  {
   3876                    /* Enable the Ocref clear feature for Channel 3 */
   3877                    htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x69C0             LDR      R0,[R0, #+28]
   \   000000A6   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x61C8             STR      R0,[R1, #+28]
   \   000000AE   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_17
   3878                  }
   3879                  else
   3880                  {
   3881                    /* Disable the Ocref clear feature for Channel 3 */
   3882                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
   \                     ??HAL_TIM_ConfigOCrefClear_16:
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x69C0             LDR      R0,[R0, #+28]
   \   000000B4   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x61C8             STR      R0,[R1, #+28]
   3883                  }
   3884                }
   3885              break;
   \                     ??HAL_TIM_ConfigOCrefClear_17:
   \   000000BC   0xE010             B.N      ??HAL_TIM_ConfigOCrefClear_13
   3886              case TIM_CHANNEL_4:
   3887                {
   3888                  assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3889                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_9:
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_18
   3890                  {
   3891                    /* Enable the Ocref clear feature for Channel 4 */
   3892                    htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x69C0             LDR      R0,[R0, #+28]
   \   000000C8   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000CC   0x6821             LDR      R1,[R4, #+0]
   \   000000CE   0x61C8             STR      R0,[R1, #+28]
   \   000000D0   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_19
   3893                  }
   3894                  else
   3895                  {
   3896                    /* Disable the Ocref clear feature for Channel 4 */
   3897                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
   \                     ??HAL_TIM_ConfigOCrefClear_18:
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x69C0             LDR      R0,[R0, #+28]
   \   000000D6   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x61C8             STR      R0,[R1, #+28]
   3898                  }
   3899                }
   3900              break;
   \                     ??HAL_TIM_ConfigOCrefClear_19:
   \   000000DE   0xE7FF             B.N      ??HAL_TIM_ConfigOCrefClear_13
   3901              default:
   3902              break;
   3903            }
   3904          
   3905            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_10:
   \                     ??HAL_TIM_ConfigOCrefClear_13:
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0xF884 0x003D      STRB     R0,[R4, #+61]
   3906          
   3907            __HAL_UNLOCK(htim);
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xF884 0x003C      STRB     R0,[R4, #+60]
   3908          
   3909            return HAL_OK;
   \   000000EC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigOCrefClear_1:
   \   000000EE   0xBD70             POP      {R4-R6,PC}       ;; return
   3910          }
   3911          
   3912          /**
   3913            * @brief   Configures the clock source to be used
   3914            * @param  htim : TIM handle
   3915            * @param  sClockSourceConfig : pointer to a TIM_ClockConfigTypeDef structure that
   3916            *         contains the clock source information for the TIM peripheral.
   3917            * @retval HAL status
   3918            */ 

   \                                 In section .text, align 2, keep-with-next
   3919          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
   3920          {
   \                     HAL_TIM_ConfigClockSource:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3921            uint32_t tmpsmcr = 0U;
   \   00000004   0x2000             MOVS     R0,#+0
   3922          
   3923            /* Process Locked */
   3924            __HAL_LOCK(htim);
   \   00000006   0xF894 0x203C      LDRB     R2,[R4, #+60]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_ConfigClockSource_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE081             B.N      ??HAL_TIM_ConfigClockSource_1
   \                     ??HAL_TIM_ConfigClockSource_0:
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x003C      STRB     R0,[R4, #+60]
   3925          
   3926            htim->State = HAL_TIM_STATE_BUSY;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x003D      STRB     R0,[R4, #+61]
   3927          
   3928            /* Check the parameters */
   3929            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3930          
   3931            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3932            tmpsmcr = htim->Instance->SMCR;
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6880             LDR      R0,[R0, #+8]
   3933            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   \   00000022   0xF030 0x0077      BICS     R0,R0,#0x77
   3934            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \   00000026   0xF430 0x407F      BICS     R0,R0,#0xFF00
   3935            htim->Instance->SMCR = tmpsmcr;
   \   0000002A   0x6822             LDR      R2,[R4, #+0]
   \   0000002C   0x6090             STR      R0,[R2, #+8]
   3936          
   3937            switch (sClockSourceConfig->ClockSource)
   \   0000002E   0x6808             LDR      R0,[R1, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD055             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \   00000034   0x2810             CMP      R0,#+16
   \   00000036   0xD058             BEQ.N    ??HAL_TIM_ConfigClockSource_3
   \   00000038   0x2820             CMP      R0,#+32
   \   0000003A   0xD05B             BEQ.N    ??HAL_TIM_ConfigClockSource_4
   \   0000003C   0x2830             CMP      R0,#+48
   \   0000003E   0xD05E             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \   00000040   0x2840             CMP      R0,#+64
   \   00000042   0xD043             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \   00000044   0x2850             CMP      R0,#+80
   \   00000046   0xD02D             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \   00000048   0x2860             CMP      R0,#+96
   \   0000004A   0xD035             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \   0000004C   0x2870             CMP      R0,#+112
   \   0000004E   0xD00D             BEQ.N    ??HAL_TIM_ConfigClockSource_9
   \   00000050   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_10
   \   00000056   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000005A   0xD016             BEQ.N    ??HAL_TIM_ConfigClockSource_11
   \   0000005C   0xE054             B.N      ??HAL_TIM_ConfigClockSource_12
   3938            {
   3939            case TIM_CLOCKSOURCE_INTERNAL:
   3940              {
   3941                assert_param(IS_TIM_INSTANCE(htim->Instance));
   3942                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3943                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \                     ??HAL_TIM_ConfigClockSource_10:
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6880             LDR      R0,[R0, #+8]
   \   00000062   0x08C0             LSRS     R0,R0,#+3
   \   00000064   0x00C0             LSLS     R0,R0,#+3
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6088             STR      R0,[R1, #+8]
   3944              }
   3945              break;
   \   0000006A   0xE04D             B.N      ??HAL_TIM_ConfigClockSource_13
   3946          
   3947            case TIM_CLOCKSOURCE_ETRMODE1:
   3948              {
   3949                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   3950                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   3951          
   3952                /* Check ETR input conditioning related parameters */
   3953                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3954                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3955                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3956                
   3957                /* Configure the ETR Clock source */
   3958                TIM_ETR_SetConfig(htim->Instance,
   3959                                  sClockSourceConfig->ClockPrescaler,
   3960                                  sClockSourceConfig->ClockPolarity,
   3961                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_9:
   \   0000006C   0x68CB             LDR      R3,[R1, #+12]
   \   0000006E   0x684A             LDR      R2,[R1, #+4]
   \   00000070   0x6889             LDR      R1,[R1, #+8]
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x.... 0x....      BL       TIM_ETR_SetConfig
   3962                /* Get the TIMx SMCR register value */
   3963                tmpsmcr = htim->Instance->SMCR;
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6880             LDR      R0,[R0, #+8]
   3964                /* Reset the SMS and TS Bits */
   3965                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   \   0000007C   0xF030 0x0077      BICS     R0,R0,#0x77
   3966                /* Select the External clock mode1 and the ETRF trigger */
   3967                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   \   00000080   0xF050 0x0077      ORRS     R0,R0,#0x77
   3968                /* Write to TIMx SMCR */
   3969                htim->Instance->SMCR = tmpsmcr;
   \   00000084   0x6821             LDR      R1,[R4, #+0]
   \   00000086   0x6088             STR      R0,[R1, #+8]
   3970              }
   3971              break;
   \   00000088   0xE03E             B.N      ??HAL_TIM_ConfigClockSource_13
   3972          
   3973            case TIM_CLOCKSOURCE_ETRMODE2:
   3974              {
   3975                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   3976                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   3977          
   3978                /* Check ETR input conditioning related parameters */
   3979                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3980                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3981                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3982                
   3983                /* Configure the ETR Clock source */
   3984                TIM_ETR_SetConfig(htim->Instance,
   3985                                  sClockSourceConfig->ClockPrescaler,
   3986                                  sClockSourceConfig->ClockPolarity,
   3987                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_11:
   \   0000008A   0x68CB             LDR      R3,[R1, #+12]
   \   0000008C   0x684A             LDR      R2,[R1, #+4]
   \   0000008E   0x6889             LDR      R1,[R1, #+8]
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x.... 0x....      BL       TIM_ETR_SetConfig
   3988                /* Enable the External clock mode2 */
   3989                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6880             LDR      R0,[R0, #+8]
   \   0000009A   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x6088             STR      R0,[R1, #+8]
   3990              }
   3991              break;
   \   000000A2   0xE031             B.N      ??HAL_TIM_ConfigClockSource_13
   3992          
   3993            case TIM_CLOCKSOURCE_TI1:
   3994              {
   3995                /* Check whether or not the timer instance supports external clock mode 1 */
   3996                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3997          
   3998                /* Check TI1 input conditioning related parameters */
   3999                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4000                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4001                
   4002                TIM_TI1_ConfigInputStage(htim->Instance,
   4003                                         sClockSourceConfig->ClockPolarity,
   4004                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_7:
   \   000000A4   0x68CA             LDR      R2,[R1, #+12]
   \   000000A6   0x6849             LDR      R1,[R1, #+4]
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4005                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \   000000AE   0x2150             MOVS     R1,#+80
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4006              }
   4007              break;
   \   000000B6   0xE027             B.N      ??HAL_TIM_ConfigClockSource_13
   4008            case TIM_CLOCKSOURCE_TI2:
   4009              {
   4010                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   4011                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4012          
   4013                 /* Check TI2 input conditioning related parameters */
   4014                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4015                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4016          
   4017                TIM_TI2_ConfigInputStage(htim->Instance,
   4018                                         sClockSourceConfig->ClockPolarity,
   4019                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8:
   \   000000B8   0x68CA             LDR      R2,[R1, #+12]
   \   000000BA   0x6849             LDR      R1,[R1, #+4]
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4020                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \   000000C2   0x2160             MOVS     R1,#+96
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4021              }
   4022              break;
   \   000000CA   0xE01D             B.N      ??HAL_TIM_ConfigClockSource_13
   4023            case TIM_CLOCKSOURCE_TI1ED:
   4024              {
   4025                /* Check whether or not the timer instance supports external clock mode 1 */
   4026                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4027          
   4028                /* Check TI1 input conditioning related parameters */
   4029                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4030                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4031          
   4032                TIM_TI1_ConfigInputStage(htim->Instance,
   4033                                         sClockSourceConfig->ClockPolarity,
   4034                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6:
   \   000000CC   0x68CA             LDR      R2,[R1, #+12]
   \   000000CE   0x6849             LDR      R1,[R1, #+4]
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4035                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \   000000D6   0x2140             MOVS     R1,#+64
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4036              }
   4037              break;
   \   000000DE   0xE013             B.N      ??HAL_TIM_ConfigClockSource_13
   4038            case TIM_CLOCKSOURCE_ITR0:
   4039              {
   4040                /* Check whether or not the timer instance supports external clock mode 1 */
   4041                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4042          
   4043                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   \                     ??HAL_TIM_ConfigClockSource_2:
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4044              }
   4045              break;
   \   000000E8   0xE00E             B.N      ??HAL_TIM_ConfigClockSource_13
   4046            case TIM_CLOCKSOURCE_ITR1:
   4047              {
   4048                /* Check whether or not the timer instance supports external clock mode 1 */
   4049                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4050          
   4051                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   \                     ??HAL_TIM_ConfigClockSource_3:
   \   000000EA   0x2110             MOVS     R1,#+16
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4052              }
   4053              break;
   \   000000F2   0xE009             B.N      ??HAL_TIM_ConfigClockSource_13
   4054            case TIM_CLOCKSOURCE_ITR2:
   4055              {
   4056                /* Check whether or not the timer instance supports external clock mode 1 */
   4057                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4058          
   4059                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   \                     ??HAL_TIM_ConfigClockSource_4:
   \   000000F4   0x2120             MOVS     R1,#+32
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4060              }
   4061              break;
   \   000000FC   0xE004             B.N      ??HAL_TIM_ConfigClockSource_13
   4062            case TIM_CLOCKSOURCE_ITR3:
   4063              {
   4064                /* Check whether or not the timer instance supports external clock mode 1 */
   4065                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4066          
   4067                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   \                     ??HAL_TIM_ConfigClockSource_5:
   \   000000FE   0x2130             MOVS     R1,#+48
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4068              }
   4069              break;
   \   00000106   0xE7FF             B.N      ??HAL_TIM_ConfigClockSource_13
   4070          
   4071            default:
   4072              break;
   4073            }
   4074            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_12:
   \                     ??HAL_TIM_ConfigClockSource_13:
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0xF884 0x003D      STRB     R0,[R4, #+61]
   4075          
   4076            __HAL_UNLOCK(htim);
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xF884 0x003C      STRB     R0,[R4, #+60]
   4077          
   4078            return HAL_OK;
   \   00000114   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigClockSource_1:
   \   00000116   0xBD10             POP      {R4,PC}          ;; return
   4079          }
   4080          
   4081          /**
   4082            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4083            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4084            * @param  htim : TIM handle.
   4085            * @param  TI1_Selection : Indicate whether or not channel 1 is connected to the
   4086            *         output of a XOR gate.
   4087            *          This parameter can be one of the following values:
   4088            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4089            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4090            *            pins are connected to the TI1 input (XOR combination)
   4091            * @retval HAL status
   4092            */

   \                                 In section .text, align 2, keep-with-next
   4093          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4094          {
   4095            uint32_t tmpcr2 = 0U;
   \                     HAL_TIM_ConfigTI1Input:
   \   00000000   0x2200             MOVS     R2,#+0
   4096          
   4097            /* Check the parameters */
   4098            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4099            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4100          
   4101            /* Get the TIMx CR2 register value */
   4102            tmpcr2 = htim->Instance->CR2;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x685B             LDR      R3,[R3, #+4]
   \   00000006   0x001A             MOVS     R2,R3
   4103          
   4104            /* Reset the TI1 selection */
   4105            tmpcr2 &= ~TIM_CR2_TI1S;
   \   00000008   0xF032 0x0280      BICS     R2,R2,#0x80
   4106          
   4107            /* Set the the TI1 selection */
   4108            tmpcr2 |= TI1_Selection;
   \   0000000C   0x430A             ORRS     R2,R1,R2
   4109          
   4110            /* Write to TIMxCR2 */
   4111            htim->Instance->CR2 = tmpcr2;
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x6042             STR      R2,[R0, #+4]
   4112          
   4113            return HAL_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
   4114          }
   4115          
   4116          /**
   4117            * @brief  Configures the TIM in Slave mode
   4118            * @param  htim : TIM handle.
   4119            * @param  sSlaveConfig : pointer to a TIM_SlaveConfigTypeDef structure that
   4120            *         contains the selected trigger (internal trigger input, filtered
   4121            *         timer input or external trigger input) and the ) and the Slave 
   4122            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1).
   4123            * @retval HAL status
   4124            */

   \                                 In section .text, align 2, keep-with-next
   4125          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4126          {
   \                     HAL_TIM_SlaveConfigSynchronization:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4127            /* Check the parameters */
   4128            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4129            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4130            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4131          
   4132            __HAL_LOCK(htim);
   \   00000004   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE01B             B.N      ??HAL_TIM_SlaveConfigSynchronization_1
   \                     ??HAL_TIM_SlaveConfigSynchronization_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x003C      STRB     R0,[R4, #+60]
   4133          
   4134            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x003D      STRB     R0,[R4, #+61]
   4135          
   4136            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   4137          
   4138            /* Disable Trigger Interrupt */
   4139            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x60C8             STR      R0,[R1, #+12]
   4140          
   4141            /* Disable Trigger DMA request */
   4142            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C0             LDR      R0,[R0, #+12]
   \   00000032   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x60C8             STR      R0,[R1, #+12]
   4143          
   4144            htim->State = HAL_TIM_STATE_READY;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x003D      STRB     R0,[R4, #+61]
   4145          
   4146            __HAL_UNLOCK(htim);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x003C      STRB     R0,[R4, #+60]
   4147          
   4148            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_1:
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
   4149              }
   4150          
   4151          /**
   4152            * @brief  Configures the TIM in Slave mode in interrupt mode
   4153            * @param  htim: TIM handle.
   4154            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4155            *         contains the selected trigger (internal trigger input, filtered
   4156            *         timer input or external trigger input) and the ) and the Slave 
   4157            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1).
   4158            * @retval HAL status
   4159            */

   \                                 In section .text, align 2, keep-with-next
   4160          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
   4161                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4162              {
   \                     HAL_TIM_SlaveConfigSynchronization_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4163                /* Check the parameters */
   4164            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4165            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4166            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4167          
   4168            __HAL_LOCK(htim);
   \   00000004   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_IT_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE01B             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_1
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x003C      STRB     R0,[R4, #+60]
   4169          
   4170            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x003D      STRB     R0,[R4, #+61]
   4171          
   4172            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   4173          
   4174            /* Enable Trigger Interrupt */
   4175            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x60C8             STR      R0,[R1, #+12]
   4176          
   4177            /* Disable Trigger DMA request */
   4178            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C0             LDR      R0,[R0, #+12]
   \   00000032   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000036   0x6821             LDR      R1,[R4, #+0]
   \   00000038   0x60C8             STR      R0,[R1, #+12]
   4179          
   4180            htim->State = HAL_TIM_STATE_READY;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x003D      STRB     R0,[R4, #+61]
   4181          
   4182            __HAL_UNLOCK(htim);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x003C      STRB     R0,[R4, #+60]
   4183          
   4184            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_1:
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
   4185          }
   4186          
   4187          /**
   4188            * @brief  Read the captured value from Capture Compare unit
   4189            * @param  htim : TIM handle.
   4190            * @param  Channel : TIM Channels to be enabled
   4191            *          This parameter can be one of the following values:
   4192            *            @arg TIM_CHANNEL_1 : TIM Channel 1 selected
   4193            *            @arg TIM_CHANNEL_2 : TIM Channel 2 selected
   4194            *            @arg TIM_CHANNEL_3 : TIM Channel 3 selected
   4195            *            @arg TIM_CHANNEL_4 : TIM Channel 4 selected
   4196            * @retval Captured value
   4197            */

   \                                 In section .text, align 2, keep-with-next
   4198          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4199          {
   4200            uint32_t tmpreg = 0U;
   \                     HAL_TIM_ReadCapturedValue:
   \   00000000   0x2200             MOVS     R2,#+0
   4201          
   4202            __HAL_LOCK(htim);
   \   00000002   0xF890 0x303C      LDRB     R3,[R0, #+60]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_ReadCapturedValue_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE01B             B.N      ??HAL_TIM_ReadCapturedValue_1
   \                     ??HAL_TIM_ReadCapturedValue_0:
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x303C      STRB     R3,[R0, #+60]
   4203          
   4204            switch (Channel)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD006             BEQ.N    ??HAL_TIM_ReadCapturedValue_2
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xD007             BEQ.N    ??HAL_TIM_ReadCapturedValue_3
   \   0000001C   0x2908             CMP      R1,#+8
   \   0000001E   0xD008             BEQ.N    ??HAL_TIM_ReadCapturedValue_4
   \   00000020   0x290C             CMP      R1,#+12
   \   00000022   0xD009             BEQ.N    ??HAL_TIM_ReadCapturedValue_5
   \   00000024   0xE00B             B.N      ??HAL_TIM_ReadCapturedValue_6
   4205            {
   4206            case TIM_CHANNEL_1:
   4207              {
   4208                /* Check the parameters */
   4209                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4210          
   4211                /* Return the capture 1 value */
   4212                tmpreg =  htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_2:
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x6B4A             LDR      R2,[R1, #+52]
   4213          
   4214                break;
   \   0000002A   0xE008             B.N      ??HAL_TIM_ReadCapturedValue_7
   4215              }
   4216            case TIM_CHANNEL_2:
   4217              {
   4218                /* Check the parameters */
   4219                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4220          
   4221                /* Return the capture 2 value */
   4222                tmpreg =   htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_3:
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x6B8A             LDR      R2,[R1, #+56]
   4223          
   4224                break;
   \   00000030   0xE005             B.N      ??HAL_TIM_ReadCapturedValue_7
   4225              }
   4226          
   4227            case TIM_CHANNEL_3:
   4228              {
   4229                /* Check the parameters */
   4230                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4231          
   4232                /* Return the capture 3 value */
   4233                tmpreg =   htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_4:
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x6BCA             LDR      R2,[R1, #+60]
   4234          
   4235                break;
   \   00000036   0xE002             B.N      ??HAL_TIM_ReadCapturedValue_7
   4236              }
   4237          
   4238            case TIM_CHANNEL_4:
   4239              {
   4240                /* Check the parameters */
   4241                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4242          
   4243                /* Return the capture 4 value */
   4244                tmpreg =   htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_5:
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6C0A             LDR      R2,[R1, #+64]
   4245          
   4246                break;
   \   0000003C   0xE7FF             B.N      ??HAL_TIM_ReadCapturedValue_7
   4247              }
   4248          
   4249            default:
   4250              break;
   4251            }
   4252          
   4253            __HAL_UNLOCK(htim);
   \                     ??HAL_TIM_ReadCapturedValue_6:
   \                     ??HAL_TIM_ReadCapturedValue_7:
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xF880 0x103C      STRB     R1,[R0, #+60]
   4254            return tmpreg;
   \   00000044   0x0010             MOVS     R0,R2
   \                     ??HAL_TIM_ReadCapturedValue_1:
   \   00000046   0x4770             BX       LR               ;; return
   4255          }
   4256          
   4257          /**
   4258            * @}
   4259            */
   4260          
   4261          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4262           *  @brief    TIM Callbacks functions 
   4263           *
   4264          @verbatim 
   4265            ==============================================================================
   4266                                  ##### TIM Callbacks functions #####
   4267            ==============================================================================
   4268           [..]
   4269             This section provides TIM callback functions:
   4270             (+) Timer Period elapsed callback
   4271             (+) Timer Output Compare callback
   4272             (+) Timer Input capture callback
   4273             (+) Timer Trigger callback
   4274             (+) Timer Error callback
   4275          
   4276          @endverbatim
   4277            * @{
   4278            */
   4279          
   4280          /**
   4281            * @brief  Period elapsed callback in non blocking mode 
   4282            * @param  htim : TIM handle
   4283            * @retval None
   4284            */

   \                                 In section .text, align 2, keep-with-next
   4285          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4286          {
   4287            /* Prevent unused argument(s) compilation warning */
   4288            UNUSED(htim);
   4289            /* NOTE : This function Should not be modified, when the callback is needed,
   4290                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4291             */
   4292          
   4293          }
   \                     HAL_TIM_PeriodElapsedCallback:
   \   00000000   0x4770             BX       LR               ;; return
   4294          /**
   4295            * @brief  Output Compare callback in non blocking mode 
   4296            * @param  htim : TIM OC handle
   4297            * @retval None
   4298            */

   \                                 In section .text, align 2, keep-with-next
   4299          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4300          {
   4301            /* Prevent unused argument(s) compilation warning */
   4302            UNUSED(htim);
   4303            /* NOTE : This function Should not be modified, when the callback is needed,
   4304                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4305             */
   4306          }
   \                     HAL_TIM_OC_DelayElapsedCallback:
   \   00000000   0x4770             BX       LR               ;; return
   4307          /**
   4308            * @brief  Input Capture callback in non blocking mode 
   4309            * @param  htim : TIM IC handle
   4310            * @retval None
   4311            */

   \                                 In section .text, align 2, keep-with-next
   4312          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4313          {
   4314            /* Prevent unused argument(s) compilation warning */
   4315            UNUSED(htim);
   4316            /* NOTE : This function Should not be modified, when the callback is needed,
   4317                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4318             */
   4319          }
   \                     HAL_TIM_IC_CaptureCallback:
   \   00000000   0x4770             BX       LR               ;; return
   4320          
   4321          /**
   4322            * @brief  PWM Pulse finished callback in non blocking mode 
   4323            * @param  htim : TIM handle
   4324            * @retval None
   4325            */

   \                                 In section .text, align 2, keep-with-next
   4326          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4327          {
   4328            /* Prevent unused argument(s) compilation warning */
   4329            UNUSED(htim);
   4330            /* NOTE : This function Should not be modified, when the callback is needed,
   4331                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4332             */
   4333          }
   \                     HAL_TIM_PWM_PulseFinishedCallback:
   \   00000000   0x4770             BX       LR               ;; return
   4334          
   4335          /**
   4336            * @brief  Hall Trigger detection callback in non blocking mode 
   4337            * @param  htim : TIM handle
   4338            * @retval None
   4339            */

   \                                 In section .text, align 2, keep-with-next
   4340          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4341          {
   4342            /* Prevent unused argument(s) compilation warning */
   4343            UNUSED(htim);
   4344            /* NOTE : This function Should not be modified, when the callback is needed,
   4345                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4346             */
   4347          }
   \                     HAL_TIM_TriggerCallback:
   \   00000000   0x4770             BX       LR               ;; return
   4348          
   4349          /**
   4350            * @brief  Timer error callback in non blocking mode 
   4351            * @param  htim : TIM handle
   4352            * @retval None
   4353            */

   \                                 In section .text, align 2, keep-with-next
   4354          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4355          {
   4356            /* Prevent unused argument(s) compilation warning */
   4357            UNUSED(htim);
   4358            /* NOTE : This function Should not be modified, when the callback is needed,
   4359                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4360             */
   4361          }
   \                     HAL_TIM_ErrorCallback:
   \   00000000   0x4770             BX       LR               ;; return
   4362          
   4363          /**
   4364            * @}
   4365            */
   4366          
   4367          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4368           *  @brief   Peripheral State functions 
   4369           *
   4370          @verbatim 
   4371            ==============================================================================
   4372                                  ##### Peripheral State functions #####
   4373            ==============================================================================
   4374              [..]
   4375              This subsection permit to get in run-time the status of the peripheral 
   4376              and the data flow.
   4377          
   4378          @endverbatim
   4379            * @{
   4380            */
   4381          
   4382          /**
   4383            * @brief  Return the TIM Base state
   4384            * @param  htim : TIM Base handle
   4385            * @retval HAL state
   4386            */

   \                                 In section .text, align 2, keep-with-next
   4387          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4388          {
   4389            return htim->State;
   \                     HAL_TIM_Base_GetState:
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   4390          }
   4391          
   4392          /**
   4393            * @brief  Return the TIM OC state
   4394            * @param  htim : TIM Ouput Compare handle
   4395            * @retval HAL state
   4396            */

   \                                 In section .text, align 2, keep-with-next
   4397          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4398          {
   4399            return htim->State;
   \                     HAL_TIM_OC_GetState:
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   4400          }
   4401          
   4402          /**
   4403            * @brief  Return the TIM PWM state
   4404            * @param  htim : TIM handle
   4405            * @retval HAL state
   4406            */

   \                                 In section .text, align 2, keep-with-next
   4407          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4408          {
   4409            return htim->State;
   \                     HAL_TIM_PWM_GetState:
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   4410          }
   4411          
   4412          /**
   4413            * @brief  Return the TIM Input Capture state
   4414            * @param  htim : TIM IC handle
   4415            * @retval HAL state
   4416            */

   \                                 In section .text, align 2, keep-with-next
   4417          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4418          {
   4419            return htim->State;
   \                     HAL_TIM_IC_GetState:
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   4420          }
   4421          
   4422          /**
   4423            * @brief  Return the TIM One Pulse Mode state
   4424            * @param  htim : TIM OPM handle
   4425            * @retval HAL state
   4426            */

   \                                 In section .text, align 2, keep-with-next
   4427          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4428          {
   4429            return htim->State;
   \                     HAL_TIM_OnePulse_GetState:
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   4430          }
   4431          
   4432          /**
   4433            * @brief  Return the TIM Encoder Mode state
   4434            * @param  htim : TIM Encoder handle
   4435            * @retval HAL state
   4436            */

   \                                 In section .text, align 2, keep-with-next
   4437          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4438          {
   4439            return htim->State;
   \                     HAL_TIM_Encoder_GetState:
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   4440          }
   4441          
   4442          /**
   4443            * @}
   4444            */
   4445          
   4446          /**
   4447            * @}
   4448            */
   4449          
   4450          /** @addtogroup TIM_Private_Functions
   4451            * @{
   4452            */
   4453          
   4454          /**
   4455            * @brief  TIM DMA error callback 
   4456            * @param  hdma : pointer to DMA handle.
   4457            * @retval None
   4458            */

   \                                 In section .text, align 4, keep-with-next
   4459          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   4460          {
   \                     TIM_DMAError:
   \   00000000   0xB580             PUSH     {R7,LR}
   4461            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   4462          
   4463            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF880 0x103D      STRB     R1,[R0, #+61]
   4464          
   4465            HAL_TIM_ErrorCallback(htim);
   \   0000000A   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   4466          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   4467          
   4468          /**
   4469            * @brief  TIM DMA Delay Pulse complete callback.
   4470            * @param  hdma : pointer to DMA handle.
   4471            * @retval None
   4472            */

   \                                 In section .text, align 4, keep-with-next
   4473          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4474          {
   \                     TIM_DMADelayPulseCplt:
   \   00000000   0xB510             PUSH     {R4,LR}
   4475            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A44             LDR      R4,[R0, #+36]
   4476          
   4477            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x103D      STRB     R1,[R4, #+61]
   4478          
   4479            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0x6A61             LDR      R1,[R4, #+36]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_0
   4480            {
   4481              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7720             STRB     R0,[R4, #+28]
   \   00000014   0xE010             B.N      ??TIM_DMADelayPulseCplt_1
   4482            }
   4483            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseCplt_0:
   \   00000016   0x6AA1             LDR      R1,[R4, #+40]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_2
   4484            {
   4485              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x7720             STRB     R0,[R4, #+28]
   \   00000020   0xE00A             B.N      ??TIM_DMADelayPulseCplt_1
   4486            }
   4487            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseCplt_2:
   \   00000022   0x6AE1             LDR      R1,[R4, #+44]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_3
   4488            {
   4489              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x7720             STRB     R0,[R4, #+28]
   \   0000002C   0xE004             B.N      ??TIM_DMADelayPulseCplt_1
   4490            }
   4491            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseCplt_3:
   \   0000002E   0x6B21             LDR      R1,[R4, #+48]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   4492            {
   4493              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x7720             STRB     R0,[R4, #+28]
   4494            }
   4495          
   4496            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1:
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   4497          
   4498            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7720             STRB     R0,[R4, #+28]
   4499          }
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   4500          /**
   4501            * @brief  TIM DMA Capture complete callback.
   4502            * @param  hdma : pointer to DMA handle.
   4503            * @retval None
   4504            */

   \                                 In section .text, align 4, keep-with-next
   4505          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4506          {
   \                     TIM_DMACaptureCplt:
   \   00000000   0xB510             PUSH     {R4,LR}
   4507            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A44             LDR      R4,[R0, #+36]
   4508          
   4509            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x103D      STRB     R1,[R4, #+61]
   4510          
   4511            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0x6A61             LDR      R1,[R4, #+36]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD102             BNE.N    ??TIM_DMACaptureCplt_0
   4512            {
   4513              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7720             STRB     R0,[R4, #+28]
   \   00000014   0xE010             B.N      ??TIM_DMACaptureCplt_1
   4514            }
   4515            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureCplt_0:
   \   00000016   0x6AA1             LDR      R1,[R4, #+40]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD102             BNE.N    ??TIM_DMACaptureCplt_2
   4516            {
   4517              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x7720             STRB     R0,[R4, #+28]
   \   00000020   0xE00A             B.N      ??TIM_DMACaptureCplt_1
   4518            }
   4519            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureCplt_2:
   \   00000022   0x6AE1             LDR      R1,[R4, #+44]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD102             BNE.N    ??TIM_DMACaptureCplt_3
   4520            {
   4521              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x7720             STRB     R0,[R4, #+28]
   \   0000002C   0xE004             B.N      ??TIM_DMACaptureCplt_1
   4522            }
   4523            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureCplt_3:
   \   0000002E   0x6B21             LDR      R1,[R4, #+48]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   4524            {
   4525              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x7720             STRB     R0,[R4, #+28]
   4526            }
   4527          
   4528            HAL_TIM_IC_CaptureCallback(htim);
   \                     ??TIM_DMACaptureCplt_1:
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   4529          
   4530            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7720             STRB     R0,[R4, #+28]
   4531          }
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   4532          
   4533          /**
   4534            * @brief  TIM DMA Period Elapse complete callback.
   4535            * @param  hdma : pointer to DMA handle.
   4536            * @retval None
   4537            */

   \                                 In section .text, align 4, keep-with-next
   4538          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4539          {
   \                     TIM_DMAPeriodElapsedCplt:
   \   00000000   0xB580             PUSH     {R7,LR}
   4540            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   4541          
   4542            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF880 0x103D      STRB     R1,[R0, #+61]
   4543          
   4544            HAL_TIM_PeriodElapsedCallback(htim);
   \   0000000A   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   4545          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   4546          
   4547          /**
   4548            * @brief  TIM DMA Trigger callback.
   4549            * @param  hdma : pointer to DMA handle.
   4550            * @retval None
   4551            */

   \                                 In section .text, align 4, keep-with-next
   4552          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4553          {
   \                     TIM_DMATriggerCplt:
   \   00000000   0xB580             PUSH     {R7,LR}
   4554            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   4555          
   4556            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF880 0x103D      STRB     R1,[R0, #+61]
   4557          
   4558            HAL_TIM_TriggerCallback(htim);
   \   0000000A   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   4559          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   4560          
   4561          /**
   4562            * @brief  Time Base configuration
   4563            * @param  TIMx : TIM periheral
   4564            * @param  Structure : TIM Base configuration structure
   4565            * @retval None
   4566            */

   \                                 In section .text, align 2, keep-with-next
   4567          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4568          {
   4569            uint32_t tmpcr1 = 0U;
   \                     TIM_Base_SetConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   4570            tmpcr1 = TIMx->CR1;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x001A             MOVS     R2,R3
   4571          
   4572            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4573            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \   00000006   0x....             LDR.N    R3,??DataTable27_1  ;; 0x40012c00
   \   00000008   0x4298             CMP      R0,R3
   \   0000000A   0xD008             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000000C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000010   0xD005             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000012   0x....             LDR.N    R3,??DataTable27_2  ;; 0x40000400
   \   00000014   0x4298             CMP      R0,R3
   \   00000016   0xD002             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000018   0x....             LDR.N    R3,??DataTable27_3  ;; 0x40000800
   \   0000001A   0x4298             CMP      R0,R3
   \   0000001C   0xD103             BNE.N    ??TIM_Base_SetConfig_1
   4574            {
   4575              /* Select the Counter Mode */
   4576              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   \                     ??TIM_Base_SetConfig_0:
   \   0000001E   0xF032 0x0270      BICS     R2,R2,#0x70
   4577              tmpcr1 |= Structure->CounterMode;
   \   00000022   0x684B             LDR      R3,[R1, #+4]
   \   00000024   0x431A             ORRS     R2,R3,R2
   4578            }
   4579          
   4580            if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \                     ??TIM_Base_SetConfig_1:
   \   00000026   0x....             LDR.N    R3,??DataTable27_1  ;; 0x40012c00
   \   00000028   0x4298             CMP      R0,R3
   \   0000002A   0xD008             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000002C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000030   0xD005             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000032   0x....             LDR.N    R3,??DataTable27_2  ;; 0x40000400
   \   00000034   0x4298             CMP      R0,R3
   \   00000036   0xD002             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000038   0x....             LDR.N    R3,??DataTable27_3  ;; 0x40000800
   \   0000003A   0x4298             CMP      R0,R3
   \   0000003C   0xD103             BNE.N    ??TIM_Base_SetConfig_3
   4581            {
   4582              /* Set the clock division */
   4583              tmpcr1 &= ~TIM_CR1_CKD;
   \                     ??TIM_Base_SetConfig_2:
   \   0000003E   0xF432 0x7240      BICS     R2,R2,#0x300
   4584              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \   00000042   0x68CB             LDR      R3,[R1, #+12]
   \   00000044   0x431A             ORRS     R2,R3,R2
   4585            }
   4586          
   4587            /* Set the auto-reload preload */
   4588            tmpcr1 &= ~TIM_CR1_ARPE;
   \                     ??TIM_Base_SetConfig_3:
   \   00000046   0xF032 0x0280      BICS     R2,R2,#0x80
   4589            tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
   \   0000004A   0x694B             LDR      R3,[R1, #+20]
   \   0000004C   0x431A             ORRS     R2,R3,R2
   4590          
   4591            TIMx->CR1 = tmpcr1;
   \   0000004E   0x6002             STR      R2,[R0, #+0]
   4592          
   4593            /* Set the Autoreload value */
   4594            TIMx->ARR = (uint32_t)Structure->Period ;
   \   00000050   0x688A             LDR      R2,[R1, #+8]
   \   00000052   0x62C2             STR      R2,[R0, #+44]
   4595          
   4596            /* Set the Prescaler value */
   4597            TIMx->PSC = (uint32_t)Structure->Prescaler;
   \   00000054   0x680A             LDR      R2,[R1, #+0]
   \   00000056   0x6282             STR      R2,[R0, #+40]
   4598          
   4599            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   \   00000058   0x....             LDR.N    R2,??DataTable27_1  ;; 0x40012c00
   \   0000005A   0x4290             CMP      R0,R2
   \   0000005C   0xD101             BNE.N    ??TIM_Base_SetConfig_4
   4600            {
   4601              /* Set the Repetition Counter value */
   4602              TIMx->RCR = Structure->RepetitionCounter;
   \   0000005E   0x6909             LDR      R1,[R1, #+16]
   \   00000060   0x6301             STR      R1,[R0, #+48]
   4603            }
   4604          
   4605            /* Generate an update event to reload the Prescaler 
   4606               and the repetition counter(only for TIM1 and TIM8) value immediatly */
   4607            TIMx->EGR = TIM_EGR_UG;
   \                     ??TIM_Base_SetConfig_4:
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x6141             STR      R1,[R0, #+20]
   4608          }
   \   00000066   0x4770             BX       LR               ;; return
   4609          
   4610          /**
   4611            * @brief  Time Ouput Compare 1 configuration
   4612            * @param  TIMx to select the TIM peripheral
   4613            * @param  OC_Config : The ouput configuration structure
   4614            * @retval None
   4615            */

   \                                 In section .text, align 2, keep-with-next
   4616          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4617          {
   \                     TIM_OC1_SetConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
   4618            uint32_t tmpccmrx = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   4619            uint32_t tmpccer = 0U;
   \   00000004   0x2400             MOVS     R4,#+0
   4620            uint32_t tmpcr2 = 0U;
   \   00000006   0x2200             MOVS     R2,#+0
   4621          
   4622             /* Disable the Channel 1: Reset the CC1E Bit */
   4623            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0x086D             LSRS     R5,R5,#+1
   \   0000000C   0x006D             LSLS     R5,R5,#+1
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4624          
   4625            /* Get the TIMx CCER register value */
   4626            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002C             MOVS     R4,R5
   4627            /* Get the TIMx CR2 register value */
   4628            tmpcr2 =  TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002A             MOVS     R2,R5
   4629          
   4630            /* Get the TIMx CCMR1 register value */
   4631            tmpccmrx = TIMx->CCMR1;
   \   00000018   0x6985             LDR      R5,[R0, #+24]
   \   0000001A   0x002B             MOVS     R3,R5
   4632          
   4633            /* Reset the Output Compare Mode Bits */
   4634            tmpccmrx &= ~TIM_CCMR1_OC1M;
   \   0000001C   0xF033 0x0370      BICS     R3,R3,#0x70
   4635            tmpccmrx &= ~TIM_CCMR1_CC1S;
   \   00000020   0x089B             LSRS     R3,R3,#+2
   \   00000022   0x009B             LSLS     R3,R3,#+2
   4636            /* Select the Output Compare Mode */
   4637            tmpccmrx |= OC_Config->OCMode;
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0x432B             ORRS     R3,R5,R3
   4638          
   4639            /* Reset the Output Polarity level */
   4640            tmpccer &= ~TIM_CCER_CC1P;
   \   00000028   0xF034 0x0402      BICS     R4,R4,#0x2
   4641            /* Set the Output Compare Polarity */
   4642            tmpccer |= OC_Config->OCPolarity;
   \   0000002C   0x688D             LDR      R5,[R1, #+8]
   \   0000002E   0x432C             ORRS     R4,R5,R4
   4643          
   4644            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   \   00000030   0x....             LDR.N    R5,??DataTable27_1  ;; 0x40012c00
   \   00000032   0x42A8             CMP      R0,R5
   \   00000034   0xD105             BNE.N    ??TIM_OC1_SetConfig_0
   4645            {
   4646              /* Check parameters */
   4647              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4648          
   4649              /* Reset the Output N Polarity level */
   4650              tmpccer &= ~TIM_CCER_CC1NP;
   \   00000036   0xF034 0x0408      BICS     R4,R4,#0x8
   4651              /* Set the Output N Polarity */
   4652              tmpccer |= OC_Config->OCNPolarity;
   \   0000003A   0x68CD             LDR      R5,[R1, #+12]
   \   0000003C   0x432C             ORRS     R4,R5,R4
   4653              /* Reset the Output N State */
   4654              tmpccer &= ~TIM_CCER_CC1NE;
   \   0000003E   0xF034 0x0404      BICS     R4,R4,#0x4
   4655            }
   4656          
   4657            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC1_SetConfig_0:
   \   00000042   0x....             LDR.N    R5,??DataTable27_1  ;; 0x40012c00
   \   00000044   0x42A8             CMP      R0,R5
   \   00000046   0xD107             BNE.N    ??TIM_OC1_SetConfig_1
   4658            {
   4659              /* Check parameters */
   4660              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4661              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4662          
   4663              /* Reset the Output Compare and Output Compare N IDLE State */
   4664              tmpcr2 &= ~TIM_CR2_OIS1;
   \   00000048   0xF432 0x7280      BICS     R2,R2,#0x100
   4665              tmpcr2 &= ~TIM_CR2_OIS1N;
   \   0000004C   0xF432 0x7200      BICS     R2,R2,#0x200
   4666              /* Set the Output Idle state */
   4667              tmpcr2 |= OC_Config->OCIdleState;
   \   00000050   0x694D             LDR      R5,[R1, #+20]
   \   00000052   0x432A             ORRS     R2,R5,R2
   4668              /* Set the Output N Idle state */
   4669              tmpcr2 |= OC_Config->OCNIdleState;
   \   00000054   0x698D             LDR      R5,[R1, #+24]
   \   00000056   0x432A             ORRS     R2,R5,R2
   4670            }
   4671            /* Write to TIMx CR2 */
   4672            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_1:
   \   00000058   0x6042             STR      R2,[R0, #+4]
   4673          
   4674            /* Write to TIMx CCMR1 */
   4675            TIMx->CCMR1 = tmpccmrx;
   \   0000005A   0x6183             STR      R3,[R0, #+24]
   4676          
   4677            /* Set the Capture Compare Register value */
   4678            TIMx->CCR1 = OC_Config->Pulse;
   \   0000005C   0x6849             LDR      R1,[R1, #+4]
   \   0000005E   0x6341             STR      R1,[R0, #+52]
   4679          
   4680            /* Write to TIMx CCER */
   4681            TIMx->CCER = tmpccer;
   \   00000060   0x6204             STR      R4,[R0, #+32]
   4682          }
   \   00000062   0xBC30             POP      {R4,R5}
   \   00000064   0x4770             BX       LR               ;; return
   4683          
   4684          /**
   4685            * @brief  Time Ouput Compare 2 configuration
   4686            * @param  TIMx  to select the TIM peripheral
   4687            * @param  OC_Config : The ouput configuration structure
   4688            * @retval None
   4689            */

   \                                 In section .text, align 2, keep-with-next
   4690          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4691          {
   \                     TIM_OC2_SetConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
   4692            uint32_t tmpccmrx = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   4693            uint32_t tmpccer = 0U;
   \   00000004   0x2400             MOVS     R4,#+0
   4694            uint32_t tmpcr2 = 0U;
   \   00000006   0x2200             MOVS     R2,#+0
   4695          
   4696            /* Disable the Channel 2: Reset the CC2E Bit */
   4697            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF035 0x0510      BICS     R5,R5,#0x10
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4698          
   4699            /* Get the TIMx CCER register value */
   4700            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002C             MOVS     R4,R5
   4701            /* Get the TIMx CR2 register value */
   4702            tmpcr2 =  TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002A             MOVS     R2,R5
   4703          
   4704            /* Get the TIMx CCMR1 register value */
   4705            tmpccmrx = TIMx->CCMR1;
   \   00000018   0x6985             LDR      R5,[R0, #+24]
   \   0000001A   0x002B             MOVS     R3,R5
   4706          
   4707            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4708            tmpccmrx &= ~TIM_CCMR1_OC2M;
   \   0000001C   0xF433 0x43E0      BICS     R3,R3,#0x7000
   4709            tmpccmrx &= ~TIM_CCMR1_CC2S;
   \   00000020   0xF433 0x7340      BICS     R3,R3,#0x300
   4710          
   4711            /* Select the Output Compare Mode */
   4712            tmpccmrx |= (OC_Config->OCMode << 8U);
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
   4713          
   4714            /* Reset the Output Polarity level */
   4715            tmpccer &= ~TIM_CCER_CC2P;
   \   0000002A   0xF034 0x0420      BICS     R4,R4,#0x20
   4716            /* Set the Output Compare Polarity */
   4717            tmpccer |= (OC_Config->OCPolarity << 4U);
   \   0000002E   0x688D             LDR      R5,[R1, #+8]
   \   00000030   0xEA54 0x1405      ORRS     R4,R4,R5, LSL #+4
   4718          
   4719            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   \   00000034   0x....             LDR.N    R5,??DataTable27_1  ;; 0x40012c00
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xD106             BNE.N    ??TIM_OC2_SetConfig_0
   4720            {
   4721              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4722          
   4723              /* Reset the Output N Polarity level */
   4724              tmpccer &= ~TIM_CCER_CC2NP;
   \   0000003A   0xF034 0x0480      BICS     R4,R4,#0x80
   4725              /* Set the Output N Polarity */
   4726              tmpccer |= (OC_Config->OCNPolarity << 4U);
   \   0000003E   0x68CD             LDR      R5,[R1, #+12]
   \   00000040   0xEA54 0x1405      ORRS     R4,R4,R5, LSL #+4
   4727              /* Reset the Output N State */
   4728              tmpccer &= ~TIM_CCER_CC2NE;
   \   00000044   0xF034 0x0440      BICS     R4,R4,#0x40
   4729          
   4730            }
   4731          
   4732            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC2_SetConfig_0:
   \   00000048   0x....             LDR.N    R5,??DataTable27_1  ;; 0x40012c00
   \   0000004A   0x42A8             CMP      R0,R5
   \   0000004C   0xD109             BNE.N    ??TIM_OC2_SetConfig_1
   4733            {
   4734              /* Check parameters */
   4735              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4736              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4737          
   4738              /* Reset the Output Compare and Output Compare N IDLE State */
   4739              tmpcr2 &= ~TIM_CR2_OIS2;
   \   0000004E   0xF432 0x6280      BICS     R2,R2,#0x400
   4740              tmpcr2 &= ~TIM_CR2_OIS2N;
   \   00000052   0xF432 0x6200      BICS     R2,R2,#0x800
   4741              /* Set the Output Idle state */
   4742              tmpcr2 |= (OC_Config->OCIdleState << 2);
   \   00000056   0x694D             LDR      R5,[R1, #+20]
   \   00000058   0xEA52 0x0285      ORRS     R2,R2,R5, LSL #+2
   4743              /* Set the Output N Idle state */
   4744              tmpcr2 |= (OC_Config->OCNIdleState << 2);
   \   0000005C   0x698D             LDR      R5,[R1, #+24]
   \   0000005E   0xEA52 0x0285      ORRS     R2,R2,R5, LSL #+2
   4745            }
   4746          
   4747            /* Write to TIMx CR2 */
   4748            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_1:
   \   00000062   0x6042             STR      R2,[R0, #+4]
   4749          
   4750            /* Write to TIMx CCMR1 */
   4751            TIMx->CCMR1 = tmpccmrx;
   \   00000064   0x6183             STR      R3,[R0, #+24]
   4752          
   4753            /* Set the Capture Compare Register value */
   4754            TIMx->CCR2 = OC_Config->Pulse;
   \   00000066   0x6849             LDR      R1,[R1, #+4]
   \   00000068   0x6381             STR      R1,[R0, #+56]
   4755          
   4756            /* Write to TIMx CCER */
   4757            TIMx->CCER = tmpccer;
   \   0000006A   0x6204             STR      R4,[R0, #+32]
   4758          }
   \   0000006C   0xBC30             POP      {R4,R5}
   \   0000006E   0x4770             BX       LR               ;; return
   4759          
   4760          /**
   4761            * @brief  Time Ouput Compare 3 configuration
   4762            * @param  TIMx  to select the TIM peripheral
   4763            * @param  OC_Config : The ouput configuration structure
   4764            * @retval None
   4765            */

   \                                 In section .text, align 2, keep-with-next
   4766          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4767          {
   \                     TIM_OC3_SetConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
   4768            uint32_t tmpccmrx = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   4769            uint32_t tmpccer = 0U;
   \   00000004   0x2400             MOVS     R4,#+0
   4770            uint32_t tmpcr2 = 0U;
   \   00000006   0x2200             MOVS     R2,#+0
   4771          
   4772            /* Disable the Channel 3: Reset the CC2E Bit */
   4773            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF435 0x7580      BICS     R5,R5,#0x100
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4774          
   4775            /* Get the TIMx CCER register value */
   4776            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002C             MOVS     R4,R5
   4777            /* Get the TIMx CR2 register value */
   4778            tmpcr2 =  TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002A             MOVS     R2,R5
   4779          
   4780            /* Get the TIMx CCMR2 register value */
   4781            tmpccmrx = TIMx->CCMR2;
   \   00000018   0x69C5             LDR      R5,[R0, #+28]
   \   0000001A   0x002B             MOVS     R3,R5
   4782          
   4783            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4784            tmpccmrx &= ~TIM_CCMR2_OC3M;
   \   0000001C   0xF033 0x0370      BICS     R3,R3,#0x70
   4785            tmpccmrx &= ~TIM_CCMR2_CC3S;
   \   00000020   0x089B             LSRS     R3,R3,#+2
   \   00000022   0x009B             LSLS     R3,R3,#+2
   4786            /* Select the Output Compare Mode */
   4787            tmpccmrx |= OC_Config->OCMode;
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0x432B             ORRS     R3,R5,R3
   4788          
   4789            /* Reset the Output Polarity level */
   4790            tmpccer &= ~TIM_CCER_CC3P;
   \   00000028   0xF434 0x7400      BICS     R4,R4,#0x200
   4791            /* Set the Output Compare Polarity */
   4792            tmpccer |= (OC_Config->OCPolarity << 8U);
   \   0000002C   0x688D             LDR      R5,[R1, #+8]
   \   0000002E   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
   4793          
   4794            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   \   00000032   0x....             LDR.N    R5,??DataTable27_1  ;; 0x40012c00
   \   00000034   0x42A8             CMP      R0,R5
   \   00000036   0xD106             BNE.N    ??TIM_OC3_SetConfig_0
   4795            {
   4796              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4797          
   4798              /* Reset the Output N Polarity level */
   4799              tmpccer &= ~TIM_CCER_CC3NP;
   \   00000038   0xF434 0x6400      BICS     R4,R4,#0x800
   4800              /* Set the Output N Polarity */
   4801              tmpccer |= (OC_Config->OCNPolarity << 8U);
   \   0000003C   0x68CD             LDR      R5,[R1, #+12]
   \   0000003E   0xEA54 0x2405      ORRS     R4,R4,R5, LSL #+8
   4802              /* Reset the Output N State */
   4803              tmpccer &= ~TIM_CCER_CC3NE;
   \   00000042   0xF434 0x6480      BICS     R4,R4,#0x400
   4804            }
   4805          
   4806            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC3_SetConfig_0:
   \   00000046   0x....             LDR.N    R5,??DataTable27_1  ;; 0x40012c00
   \   00000048   0x42A8             CMP      R0,R5
   \   0000004A   0xD109             BNE.N    ??TIM_OC3_SetConfig_1
   4807            {
   4808              /* Check parameters */
   4809              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4810              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4811          
   4812              /* Reset the Output Compare and Output Compare N IDLE State */
   4813              tmpcr2 &= ~TIM_CR2_OIS3;
   \   0000004C   0xF432 0x5280      BICS     R2,R2,#0x1000
   4814              tmpcr2 &= ~TIM_CR2_OIS3N;
   \   00000050   0xF432 0x5200      BICS     R2,R2,#0x2000
   4815              /* Set the Output Idle state */
   4816              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   \   00000054   0x694D             LDR      R5,[R1, #+20]
   \   00000056   0xEA52 0x1205      ORRS     R2,R2,R5, LSL #+4
   4817              /* Set the Output N Idle state */
   4818              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   \   0000005A   0x698D             LDR      R5,[R1, #+24]
   \   0000005C   0xEA52 0x1205      ORRS     R2,R2,R5, LSL #+4
   4819            }
   4820          
   4821            /* Write to TIMx CR2 */
   4822            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_1:
   \   00000060   0x6042             STR      R2,[R0, #+4]
   4823          
   4824            /* Write to TIMx CCMR2 */
   4825            TIMx->CCMR2 = tmpccmrx;
   \   00000062   0x61C3             STR      R3,[R0, #+28]
   4826          
   4827            /* Set the Capture Compare Register value */
   4828            TIMx->CCR3 = OC_Config->Pulse;
   \   00000064   0x6849             LDR      R1,[R1, #+4]
   \   00000066   0x63C1             STR      R1,[R0, #+60]
   4829          
   4830            /* Write to TIMx CCER */
   4831            TIMx->CCER = tmpccer;
   \   00000068   0x6204             STR      R4,[R0, #+32]
   4832          }
   \   0000006A   0xBC30             POP      {R4,R5}
   \   0000006C   0x4770             BX       LR               ;; return
   4833          
   4834          /**
   4835            * @brief  Time Ouput Compare 4 configuration
   4836            * @param  TIMx  to select the TIM peripheral
   4837            * @param  OC_Config : The ouput configuration structure
   4838            * @retval None
   4839            */

   \                                 In section .text, align 2, keep-with-next
   4840          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4841          {
   \                     TIM_OC4_SetConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
   4842            uint32_t tmpccmrx = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   4843            uint32_t tmpccer = 0U;
   \   00000004   0x2200             MOVS     R2,#+0
   4844            uint32_t tmpcr2 = 0U;
   \   00000006   0x2400             MOVS     R4,#+0
   4845          
   4846            /* Disable the Channel 4: Reset the CC4E Bit */
   4847            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000008   0x6A05             LDR      R5,[R0, #+32]
   \   0000000A   0xF435 0x5580      BICS     R5,R5,#0x1000
   \   0000000E   0x6205             STR      R5,[R0, #+32]
   4848          
   4849            /* Get the TIMx CCER register value */
   4850            tmpccer = TIMx->CCER;
   \   00000010   0x6A05             LDR      R5,[R0, #+32]
   \   00000012   0x002A             MOVS     R2,R5
   4851            /* Get the TIMx CR2 register value */
   4852            tmpcr2 =  TIMx->CR2;
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x002C             MOVS     R4,R5
   4853          
   4854            /* Get the TIMx CCMR2 register value */
   4855            tmpccmrx = TIMx->CCMR2;
   \   00000018   0x69C5             LDR      R5,[R0, #+28]
   \   0000001A   0x002B             MOVS     R3,R5
   4856          
   4857            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4858            tmpccmrx &= ~TIM_CCMR2_OC4M;
   \   0000001C   0xF433 0x43E0      BICS     R3,R3,#0x7000
   4859            tmpccmrx &= ~TIM_CCMR2_CC4S;
   \   00000020   0xF433 0x7340      BICS     R3,R3,#0x300
   4860          
   4861            /* Select the Output Compare Mode */
   4862            tmpccmrx |= (OC_Config->OCMode << 8U);
   \   00000024   0x680D             LDR      R5,[R1, #+0]
   \   00000026   0xEA53 0x2305      ORRS     R3,R3,R5, LSL #+8
   4863          
   4864            /* Reset the Output Polarity level */
   4865            tmpccer &= ~TIM_CCER_CC4P;
   \   0000002A   0xF432 0x5200      BICS     R2,R2,#0x2000
   4866            /* Set the Output Compare Polarity */
   4867            tmpccer |= (OC_Config->OCPolarity << 12U);
   \   0000002E   0x688D             LDR      R5,[R1, #+8]
   \   00000030   0xEA52 0x3205      ORRS     R2,R2,R5, LSL #+12
   4868          
   4869            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \   00000034   0x....             LDR.N    R5,??DataTable27_1  ;; 0x40012c00
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xD104             BNE.N    ??TIM_OC4_SetConfig_0
   4870            {
   4871              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4872          
   4873             /* Reset the Output Compare IDLE State */
   4874              tmpcr2 &= ~TIM_CR2_OIS4;
   \   0000003A   0xF434 0x4480      BICS     R4,R4,#0x4000
   4875              /* Set the Output Idle state */
   4876              tmpcr2 |= (OC_Config->OCIdleState << 6);
   \   0000003E   0x694D             LDR      R5,[R1, #+20]
   \   00000040   0xEA54 0x1485      ORRS     R4,R4,R5, LSL #+6
   4877            }
   4878          
   4879            /* Write to TIMx CR2 */
   4880            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_0:
   \   00000044   0x6044             STR      R4,[R0, #+4]
   4881          
   4882            /* Write to TIMx CCMR2 */
   4883            TIMx->CCMR2 = tmpccmrx;
   \   00000046   0x61C3             STR      R3,[R0, #+28]
   4884          
   4885            /* Set the Capture Compare Register value */
   4886            TIMx->CCR4 = OC_Config->Pulse;
   \   00000048   0x6849             LDR      R1,[R1, #+4]
   \   0000004A   0x6401             STR      R1,[R0, #+64]
   4887          
   4888            /* Write to TIMx CCER */
   4889            TIMx->CCER = tmpccer;
   \   0000004C   0x6202             STR      R2,[R0, #+32]
   4890          }
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
   4891          
   4892          
   4893          /**
   4894            * @brief  Time Slave configuration
   4895            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4896            *                the configuration information for TIM module.
   4897            * @param  sSlaveConfig: The slave configuration structure
   4898            * @retval None
   4899            */

   \                                 In section .text, align 2, keep-with-next
   4900          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4901                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4902          {
   \                     TIM_SlaveTimer_SetConfig:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   4903            uint32_t tmpsmcr = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   4904            uint32_t tmpccmr1 = 0U;
   \   00000004   0x2400             MOVS     R4,#+0
   4905            uint32_t tmpccer = 0U;
   \   00000006   0x2200             MOVS     R2,#+0
   4906          
   4907            /* Get the TIMx SMCR register value */
   4908            tmpsmcr = htim->Instance->SMCR;
   \   00000008   0x6805             LDR      R5,[R0, #+0]
   \   0000000A   0x68AD             LDR      R5,[R5, #+8]
   \   0000000C   0x002B             MOVS     R3,R5
   4909          
   4910            /* Reset the Trigger Selection Bits */
   4911            tmpsmcr &= ~TIM_SMCR_TS;
   \   0000000E   0xF033 0x0370      BICS     R3,R3,#0x70
   4912            /* Set the Input Trigger source */
   4913            tmpsmcr |= sSlaveConfig->InputTrigger;
   \   00000012   0x684D             LDR      R5,[R1, #+4]
   \   00000014   0x432B             ORRS     R3,R5,R3
   4914          
   4915            /* Reset the slave mode Bits */
   4916            tmpsmcr &= ~TIM_SMCR_SMS;
   \   00000016   0x08DB             LSRS     R3,R3,#+3
   \   00000018   0x00DB             LSLS     R3,R3,#+3
   4917            /* Set the slave mode */
   4918            tmpsmcr |= sSlaveConfig->SlaveMode;
   \   0000001A   0x680D             LDR      R5,[R1, #+0]
   \   0000001C   0x432B             ORRS     R3,R5,R3
   4919          
   4920            /* Write to TIMx SMCR */
   4921            htim->Instance->SMCR = tmpsmcr;
   \   0000001E   0x6805             LDR      R5,[R0, #+0]
   \   00000020   0x60AB             STR      R3,[R5, #+8]
   4922          
   4923            /* Configure the trigger prescaler, filter, and polarity */
   4924            switch (sSlaveConfig->InputTrigger)
   \   00000022   0x684B             LDR      R3,[R1, #+4]
   \   00000024   0x2B00             CMP      R3,#+0
   \   00000026   0xD034             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \   00000028   0x2B10             CMP      R3,#+16
   \   0000002A   0xD033             BEQ.N    ??TIM_SlaveTimer_SetConfig_1
   \   0000002C   0x2B20             CMP      R3,#+32
   \   0000002E   0xD032             BEQ.N    ??TIM_SlaveTimer_SetConfig_2
   \   00000030   0x2B30             CMP      R3,#+48
   \   00000032   0xD031             BEQ.N    ??TIM_SlaveTimer_SetConfig_3
   \   00000034   0x2B40             CMP      R3,#+64
   \   00000036   0xD00C             BEQ.N    ??TIM_SlaveTimer_SetConfig_4
   \   00000038   0x2B50             CMP      R3,#+80
   \   0000003A   0xD01E             BEQ.N    ??TIM_SlaveTimer_SetConfig_5
   \   0000003C   0x2B60             CMP      R3,#+96
   \   0000003E   0xD022             BEQ.N    ??TIM_SlaveTimer_SetConfig_6
   \   00000040   0x2B70             CMP      R3,#+112
   \   00000042   0xD12A             BNE.N    ??TIM_SlaveTimer_SetConfig_7
   4925            {
   4926            case TIM_TS_ETRF:
   4927              {
   4928                /* Check the parameters */
   4929                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4930                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4931                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4932                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4933                /* Configure the ETR Trigger source */
   4934                TIM_ETR_SetConfig(htim->Instance,
   4935                                  sSlaveConfig->TriggerPrescaler,
   4936                                  sSlaveConfig->TriggerPolarity,
   4937                                  sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_8:
   \   00000044   0x690B             LDR      R3,[R1, #+16]
   \   00000046   0x688A             LDR      R2,[R1, #+8]
   \   00000048   0x68C9             LDR      R1,[R1, #+12]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_ETR_SetConfig
   4938              }
   4939              break;
   \   00000050   0xE023             B.N      ??TIM_SlaveTimer_SetConfig_9
   4940          
   4941            case TIM_TS_TI1F_ED:
   4942              {
   4943                /* Check the parameters */
   4944                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4945                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4946          
   4947                /* Disable the Channel 1: Reset the CC1E Bit */
   4948                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_4:
   \   00000052   0x6802             LDR      R2,[R0, #+0]
   \   00000054   0x6A12             LDR      R2,[R2, #+32]
   4949                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   00000056   0x6803             LDR      R3,[R0, #+0]
   \   00000058   0x6A1B             LDR      R3,[R3, #+32]
   \   0000005A   0x085B             LSRS     R3,R3,#+1
   \   0000005C   0x005B             LSLS     R3,R3,#+1
   \   0000005E   0x6804             LDR      R4,[R0, #+0]
   \   00000060   0x6223             STR      R3,[R4, #+32]
   4950                tmpccmr1 = htim->Instance->CCMR1;
   \   00000062   0x6803             LDR      R3,[R0, #+0]
   \   00000064   0x699C             LDR      R4,[R3, #+24]
   4951          
   4952                /* Set the filter */
   4953                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \   00000066   0xF034 0x04F0      BICS     R4,R4,#0xF0
   4954                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   \   0000006A   0x6909             LDR      R1,[R1, #+16]
   \   0000006C   0xEA54 0x1401      ORRS     R4,R4,R1, LSL #+4
   4955          
   4956                /* Write to TIMx CCMR1 and CCER registers */
   4957                htim->Instance->CCMR1 = tmpccmr1;
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x618C             STR      R4,[R1, #+24]
   4958                htim->Instance->CCER = tmpccer;
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x6202             STR      R2,[R0, #+32]
   4959          
   4960              }
   4961              break;
   \   00000078   0xE00F             B.N      ??TIM_SlaveTimer_SetConfig_9
   4962          
   4963            case TIM_TS_TI1FP1:
   4964              {
   4965                /* Check the parameters */
   4966                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4967                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4968                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4969          
   4970                /* Configure TI1 Filter and Polarity */
   4971                TIM_TI1_ConfigInputStage(htim->Instance,
   4972                                         sSlaveConfig->TriggerPolarity,
   4973                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_5:
   \   0000007A   0x690A             LDR      R2,[R1, #+16]
   \   0000007C   0x6889             LDR      R1,[R1, #+8]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4974              }
   4975              break;
   \   00000084   0xE009             B.N      ??TIM_SlaveTimer_SetConfig_9
   4976          
   4977            case TIM_TS_TI2FP2:
   4978              {
   4979                /* Check the parameters */
   4980                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4981                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4982                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4983          
   4984                /* Configure TI2 Filter and Polarity */
   4985                TIM_TI2_ConfigInputStage(htim->Instance,
   4986                                          sSlaveConfig->TriggerPolarity,
   4987                                          sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_6:
   \   00000086   0x690A             LDR      R2,[R1, #+16]
   \   00000088   0x6889             LDR      R1,[R1, #+8]
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4988              }
   4989              break;
   \   00000090   0xE003             B.N      ??TIM_SlaveTimer_SetConfig_9
   4990          
   4991            case TIM_TS_ITR0:
   4992              {
   4993                /* Check the parameter */
   4994                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4995              }
   4996              break;
   \                     ??TIM_SlaveTimer_SetConfig_0:
   \   00000092   0xE002             B.N      ??TIM_SlaveTimer_SetConfig_9
   4997          
   4998            case TIM_TS_ITR1:
   4999              {
   5000                /* Check the parameter */
   5001                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5002              }
   5003              break;
   \                     ??TIM_SlaveTimer_SetConfig_1:
   \   00000094   0xE001             B.N      ??TIM_SlaveTimer_SetConfig_9
   5004          
   5005            case TIM_TS_ITR2:
   5006              {
   5007                /* Check the parameter */
   5008                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5009              }
   5010              break;
   \                     ??TIM_SlaveTimer_SetConfig_2:
   \   00000096   0xE000             B.N      ??TIM_SlaveTimer_SetConfig_9
   5011          
   5012            case TIM_TS_ITR3:
   5013              {
   5014                /* Check the parameter */
   5015                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5016              }
   5017              break;
   \                     ??TIM_SlaveTimer_SetConfig_3:
   \   00000098   0xE7FF             B.N      ??TIM_SlaveTimer_SetConfig_9
   5018          
   5019            default:
   5020              break;
   5021            }
   5022          }
   \                     ??TIM_SlaveTimer_SetConfig_7:
   \                     ??TIM_SlaveTimer_SetConfig_9:
   \   0000009A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5023          
   5024          /**
   5025            * @brief  Configure the TI1 as Input.
   5026            * @param  TIMx  to select the TIM peripheral.
   5027            * @param  TIM_ICPolarity : The Input Polarity.
   5028            *          This parameter can be one of the following values:
   5029            *            @arg TIM_ICPOLARITY_RISING
   5030            *            @arg TIM_ICPOLARITY_FALLING
   5031            * @param  TIM_ICSelection : specifies the input to be used.
   5032            *          This parameter can be one of the following values:
   5033            *            @arg TIM_ICSELECTION_DIRECTTI:    TIM Input 1 is selected to be connected to IC1.
   5034            *            @arg TIM_ICSELECTION_INDIRECTTI:  TIM Input 1 is selected to be connected to IC2.
   5035            *            @arg TIM_ICSELECTION_TRC:         TIM Input 1 is selected to be connected to TRC.
   5036            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5037            *          This parameter must be a value between 0x00 and 0x0F.
   5038            * @retval None
   5039            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   5040            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   5041            *        protected against un-initialized filter and polarity values.
   5042            */

   \                                 In section .text, align 2, keep-with-next
   5043          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5044                                 uint32_t TIM_ICFilter)
   5045          {
   \                     TIM_TI1_SetConfig:
   \   00000000   0xB470             PUSH     {R4-R6}
   5046            uint32_t tmpccmr1 = 0U;
   \   00000002   0x2500             MOVS     R5,#+0
   5047            uint32_t tmpccer = 0U;
   \   00000004   0x2400             MOVS     R4,#+0
   5048          
   5049            /* Disable the Channel 1: Reset the CC1E Bit */
   5050            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0x0876             LSRS     R6,R6,#+1
   \   0000000A   0x0076             LSLS     R6,R6,#+1
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   5051            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6986             LDR      R6,[R0, #+24]
   \   00000010   0x0035             MOVS     R5,R6
   5052            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0034             MOVS     R4,R6
   5053          
   5054            /* Select the Input */
   5055            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \   00000016   0x....             LDR.N    R6,??DataTable27_1  ;; 0x40012c00
   \   00000018   0x42B0             CMP      R0,R6
   \   0000001A   0xD008             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000001C   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000020   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000022   0x....             LDR.N    R6,??DataTable27_2  ;; 0x40000400
   \   00000024   0x42B0             CMP      R0,R6
   \   00000026   0xD002             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000028   0x....             LDR.N    R6,??DataTable27_3  ;; 0x40000800
   \   0000002A   0x42B0             CMP      R0,R6
   \   0000002C   0xD101             BNE.N    ??TIM_TI1_SetConfig_1
   \                     ??TIM_TI1_SetConfig_0:
   \   0000002E   0x2601             MOVS     R6,#+1
   \   00000030   0xE000             B.N      ??TIM_TI1_SetConfig_2
   \                     ??TIM_TI1_SetConfig_1:
   \   00000032   0x2600             MOVS     R6,#+0
   \                     ??TIM_TI1_SetConfig_2:
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD003             BEQ.N    ??TIM_TI1_SetConfig_3
   5056            {
   5057              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   \   0000003A   0x08AD             LSRS     R5,R5,#+2
   \   0000003C   0x00AD             LSLS     R5,R5,#+2
   5058              tmpccmr1 |= TIM_ICSelection;
   \   0000003E   0x4315             ORRS     R5,R2,R5
   \   00000040   0xE001             B.N      ??TIM_TI1_SetConfig_4
   5059            }
   5060            else
   5061            {
   5062              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_3:
   \   00000042   0xF055 0x0501      ORRS     R5,R5,#0x1
   5063            }
   5064          
   5065            /* Set the filter */
   5066            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \                     ??TIM_TI1_SetConfig_4:
   \   00000046   0xF035 0x05F0      BICS     R5,R5,#0xF0
   5067            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   \   0000004A   0x011A             LSLS     R2,R3,#+4
   \   0000004C   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000050   0x4315             ORRS     R5,R2,R5
   5068          
   5069            /* Select the Polarity and set the CC1E Bit */
   5070            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \   00000052   0xF034 0x040A      BICS     R4,R4,#0xA
   5071            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   \   00000056   0xF011 0x010A      ANDS     R1,R1,#0xA
   \   0000005A   0x430C             ORRS     R4,R1,R4
   5072          
   5073            /* Write to TIMx CCMR1 and CCER registers */
   5074            TIMx->CCMR1 = tmpccmr1;
   \   0000005C   0x6185             STR      R5,[R0, #+24]
   5075            TIMx->CCER = tmpccer;
   \   0000005E   0x6204             STR      R4,[R0, #+32]
   5076          }
   \   00000060   0xBC70             POP      {R4-R6}
   \   00000062   0x4770             BX       LR               ;; return
   5077          
   5078          /**
   5079            * @brief  Configure the Polarity and Filter for TI1.
   5080            * @param  TIMx  to select the TIM peripheral.
   5081            * @param  TIM_ICPolarity : The Input Polarity.
   5082            *          This parameter can be one of the following values:
   5083            *            @arg TIM_ICPOLARITY_RISING   
   5084            *            @arg TIM_ICPOLARITY_FALLING
   5085            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5086            *          This parameter must be a value between 0x00 and 0x0F.
   5087            * @retval None
   5088            */

   \                                 In section .text, align 2, keep-with-next
   5089          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5090          {
   \                     TIM_TI1_ConfigInputStage:
   \   00000000   0xB430             PUSH     {R4,R5}
   5091            uint32_t tmpccmr1 = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   5092            uint32_t tmpccer = 0U;
   \   00000004   0x2400             MOVS     R4,#+0
   5093          
   5094            /* Disable the Channel 1: Reset the CC1E Bit */
   5095            tmpccer = TIMx->CCER;
   \   00000006   0x6A05             LDR      R5,[R0, #+32]
   \   00000008   0x002C             MOVS     R4,R5
   5096            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   0000000A   0x6A05             LDR      R5,[R0, #+32]
   \   0000000C   0x086D             LSRS     R5,R5,#+1
   \   0000000E   0x006D             LSLS     R5,R5,#+1
   \   00000010   0x6205             STR      R5,[R0, #+32]
   5097            tmpccmr1 = TIMx->CCMR1;
   \   00000012   0x6985             LDR      R5,[R0, #+24]
   \   00000014   0x002B             MOVS     R3,R5
   5098          
   5099            /* Set the filter */
   5100            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \   00000016   0xF033 0x03F0      BICS     R3,R3,#0xF0
   5101            tmpccmr1 |= (TIM_ICFilter << 4U);
   \   0000001A   0xEA53 0x1302      ORRS     R3,R3,R2, LSL #+4
   5102          
   5103            /* Select the Polarity and set the CC1E Bit */
   5104            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \   0000001E   0xF034 0x040A      BICS     R4,R4,#0xA
   5105            tmpccer |= TIM_ICPolarity;
   \   00000022   0x430C             ORRS     R4,R1,R4
   5106          
   5107            /* Write to TIMx CCMR1 and CCER registers */
   5108            TIMx->CCMR1 = tmpccmr1;
   \   00000024   0x6183             STR      R3,[R0, #+24]
   5109            TIMx->CCER = tmpccer;
   \   00000026   0x6204             STR      R4,[R0, #+32]
   5110          }
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return
   5111          
   5112          /**
   5113            * @brief  Configure the TI2 as Input.
   5114            * @param  TIMx  to select the TIM peripheral
   5115            * @param  TIM_ICPolarity : The Input Polarity.
   5116            *          This parameter can be one of the following values:
   5117            *            @arg TIM_ICPOLARITY_RISING   
   5118            *            @arg TIM_ICPOLARITY_FALLING
   5119            * @param  TIM_ICSelection : specifies the input to be used.
   5120            *          This parameter can be one of the following values:
   5121            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 2 is selected to be connected to IC2.
   5122            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   5123            *            @arg TIM_ICSELECTION_TRC:        TIM Input 2 is selected to be connected to TRC.
   5124            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5125            *          This parameter must be a value between 0x00 and 0x0F.
   5126            * @retval None
   5127            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5128            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5129            *        protected against un-initialized filter and polarity values.
   5130            */

   \                                 In section .text, align 2, keep-with-next
   5131          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5132                                 uint32_t TIM_ICFilter)
   5133          {
   \                     TIM_TI2_SetConfig:
   \   00000000   0xB470             PUSH     {R4-R6}
   5134            uint32_t tmpccmr1 = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   5135            uint32_t tmpccer = 0U;
   \   00000004   0x2500             MOVS     R5,#+0
   5136          
   5137            /* Disable the Channel 2: Reset the CC2E Bit */
   5138            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF036 0x0610      BICS     R6,R6,#0x10
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   5139            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6986             LDR      R6,[R0, #+24]
   \   00000010   0x0034             MOVS     R4,R6
   5140            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   5141          
   5142            /* Select the Input */
   5143            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   \   00000016   0xF434 0x7440      BICS     R4,R4,#0x300
   5144            tmpccmr1 |= (TIM_ICSelection << 8U);
   \   0000001A   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   5145          
   5146            /* Set the filter */
   5147            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \   0000001E   0xF434 0x4470      BICS     R4,R4,#0xF000
   5148            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   \   00000022   0x031A             LSLS     R2,R3,#+12
   \   00000024   0xF412 0x4270      ANDS     R2,R2,#0xF000
   \   00000028   0x4314             ORRS     R4,R2,R4
   5149          
   5150            /* Select the Polarity and set the CC2E Bit */
   5151            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \   0000002A   0xF035 0x05A0      BICS     R5,R5,#0xA0
   5152            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   \   0000002E   0x0109             LSLS     R1,R1,#+4
   \   00000030   0xF011 0x01A0      ANDS     R1,R1,#0xA0
   \   00000034   0x430D             ORRS     R5,R1,R5
   5153          
   5154            /* Write to TIMx CCMR1 and CCER registers */
   5155            TIMx->CCMR1 = tmpccmr1 ;
   \   00000036   0x6184             STR      R4,[R0, #+24]
   5156            TIMx->CCER = tmpccer;
   \   00000038   0x6205             STR      R5,[R0, #+32]
   5157          }
   \   0000003A   0xBC70             POP      {R4-R6}
   \   0000003C   0x4770             BX       LR               ;; return
   5158          
   5159          /**
   5160            * @brief  Configure the Polarity and Filter for TI2.
   5161            * @param  TIMx  to select the TIM peripheral.
   5162            * @param  TIM_ICPolarity : The Input Polarity.
   5163            *          This parameter can be one of the following values:
   5164            *            @arg TIM_ICPOLARITY_RISING  
   5165            *            @arg TIM_ICPOLARITY_FALLING
   5166            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5167            *          This parameter must be a value between 0x00 and 0x0F.
   5168            * @retval None
   5169            */

   \                                 In section .text, align 2, keep-with-next
   5170          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5171          {
   \                     TIM_TI2_ConfigInputStage:
   \   00000000   0xB430             PUSH     {R4,R5}
   5172            uint32_t tmpccmr1 = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   5173            uint32_t tmpccer = 0U;
   \   00000004   0x2400             MOVS     R4,#+0
   5174          
   5175            /* Disable the Channel 2: Reset the CC2E Bit */
   5176            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000006   0x6A05             LDR      R5,[R0, #+32]
   \   00000008   0xF035 0x0510      BICS     R5,R5,#0x10
   \   0000000C   0x6205             STR      R5,[R0, #+32]
   5177            tmpccmr1 = TIMx->CCMR1;
   \   0000000E   0x6985             LDR      R5,[R0, #+24]
   \   00000010   0x002B             MOVS     R3,R5
   5178            tmpccer = TIMx->CCER;
   \   00000012   0x6A05             LDR      R5,[R0, #+32]
   \   00000014   0x002C             MOVS     R4,R5
   5179          
   5180            /* Set the filter */
   5181            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \   00000016   0xF433 0x4370      BICS     R3,R3,#0xF000
   5182            tmpccmr1 |= (TIM_ICFilter << 12U);
   \   0000001A   0xEA53 0x3302      ORRS     R3,R3,R2, LSL #+12
   5183          
   5184            /* Select the Polarity and set the CC2E Bit */
   5185            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \   0000001E   0xF034 0x04A0      BICS     R4,R4,#0xA0
   5186            tmpccer |= (TIM_ICPolarity << 4U);
   \   00000022   0xEA54 0x1401      ORRS     R4,R4,R1, LSL #+4
   5187          
   5188            /* Write to TIMx CCMR1 and CCER registers */
   5189            TIMx->CCMR1 = tmpccmr1 ;
   \   00000026   0x6183             STR      R3,[R0, #+24]
   5190            TIMx->CCER = tmpccer;
   \   00000028   0x6204             STR      R4,[R0, #+32]
   5191          }
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return
   5192          
   5193          /**
   5194            * @brief  Configure the TI3 as Input.
   5195            * @param  TIMx  to select the TIM peripheral
   5196            * @param  TIM_ICPolarity : The Input Polarity.
   5197            *          This parameter can be one of the following values:
   5198            *            @arg TIM_ICPOLARITY_RISING  
   5199            *            @arg TIM_ICPOLARITY_FALLING
   5200            * @param  TIM_ICSelection : specifies the input to be used.
   5201            *          This parameter can be one of the following values:
   5202            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 3 is selected to be connected to IC3.
   5203            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   5204            *            @arg TIM_ICSELECTION_TRC:        TIM Input 3 is selected to be connected to TRC.
   5205            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5206            *          This parameter must be a value between 0x00 and 0x0F.
   5207            * @retval None
   5208            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5209            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5210            *        protected against un-initialized filter and polarity values.
   5211            */

   \                                 In section .text, align 2, keep-with-next
   5212          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5213                                 uint32_t TIM_ICFilter)
   5214          {
   \                     TIM_TI3_SetConfig:
   \   00000000   0xB470             PUSH     {R4-R6}
   5215            uint32_t tmpccmr2 = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   5216            uint32_t tmpccer = 0U;
   \   00000004   0x2500             MOVS     R5,#+0
   5217          
   5218            /* Disable the Channel 3: Reset the CC3E Bit */
   5219            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF436 0x7680      BICS     R6,R6,#0x100
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   5220            tmpccmr2 = TIMx->CCMR2;
   \   0000000E   0x69C6             LDR      R6,[R0, #+28]
   \   00000010   0x0034             MOVS     R4,R6
   5221            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   5222          
   5223            /* Select the Input */
   5224            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   \   00000016   0x08A4             LSRS     R4,R4,#+2
   \   00000018   0x00A4             LSLS     R4,R4,#+2
   5225            tmpccmr2 |= TIM_ICSelection;
   \   0000001A   0x4314             ORRS     R4,R2,R4
   5226          
   5227            /* Set the filter */
   5228            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   \   0000001C   0xF034 0x04F0      BICS     R4,R4,#0xF0
   5229            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   \   00000020   0x011A             LSLS     R2,R3,#+4
   \   00000022   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000026   0x4314             ORRS     R4,R2,R4
   5230          
   5231            /* Select the Polarity and set the CC3E Bit */
   5232            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   \   00000028   0xF435 0x6520      BICS     R5,R5,#0xA00
   5233            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   \   0000002C   0x0209             LSLS     R1,R1,#+8
   \   0000002E   0xF411 0x6120      ANDS     R1,R1,#0xA00
   \   00000032   0x430D             ORRS     R5,R1,R5
   5234          
   5235            /* Write to TIMx CCMR2 and CCER registers */
   5236            TIMx->CCMR2 = tmpccmr2;
   \   00000034   0x61C4             STR      R4,[R0, #+28]
   5237            TIMx->CCER = tmpccer;
   \   00000036   0x6205             STR      R5,[R0, #+32]
   5238          }
   \   00000038   0xBC70             POP      {R4-R6}
   \   0000003A   0x4770             BX       LR               ;; return
   5239          
   5240          /**
   5241            * @brief  Configure the TI4 as Input.
   5242            * @param  TIMx to select the TIM peripheral
   5243            * @param  TIM_ICPolarity : The Input Polarity.
   5244            *          This parameter can be one of the following values:
   5245            *            @arg TIM_ICPOLARITY_RISING  
   5246            *            @arg TIM_ICPOLARITY_FALLING
   5247            * @param  TIM_ICSelection : specifies the input to be used.
   5248            *          This parameter can be one of the following values:
   5249            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 4 is selected to be connected to IC4.
   5250            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   5251            *            @arg TIM_ICSELECTION_TRC:        TIM Input 4 is selected to be connected to TRC.
   5252            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5253            *          This parameter must be a value between 0x00 and 0x0F.
   5254            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5255            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5256            *        protected against un-initialized filter and polarity values.
   5257            * @retval None
   5258            */

   \                                 In section .text, align 2, keep-with-next
   5259          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5260                                 uint32_t TIM_ICFilter)
   5261          {
   \                     TIM_TI4_SetConfig:
   \   00000000   0xB470             PUSH     {R4-R6}
   5262            uint32_t tmpccmr2 = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   5263            uint32_t tmpccer = 0U;
   \   00000004   0x2500             MOVS     R5,#+0
   5264          
   5265            /* Disable the Channel 4: Reset the CC4E Bit */
   5266            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000006   0x6A06             LDR      R6,[R0, #+32]
   \   00000008   0xF436 0x5680      BICS     R6,R6,#0x1000
   \   0000000C   0x6206             STR      R6,[R0, #+32]
   5267            tmpccmr2 = TIMx->CCMR2;
   \   0000000E   0x69C6             LDR      R6,[R0, #+28]
   \   00000010   0x0034             MOVS     R4,R6
   5268            tmpccer = TIMx->CCER;
   \   00000012   0x6A06             LDR      R6,[R0, #+32]
   \   00000014   0x0035             MOVS     R5,R6
   5269          
   5270            /* Select the Input */
   5271            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   \   00000016   0xF434 0x7440      BICS     R4,R4,#0x300
   5272            tmpccmr2 |= (TIM_ICSelection << 8U);
   \   0000001A   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   5273          
   5274            /* Set the filter */
   5275            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   \   0000001E   0xF434 0x4470      BICS     R4,R4,#0xF000
   5276            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   \   00000022   0x031A             LSLS     R2,R3,#+12
   \   00000024   0xF412 0x4270      ANDS     R2,R2,#0xF000
   \   00000028   0x4314             ORRS     R4,R2,R4
   5277          
   5278            /* Select the Polarity and set the CC4E Bit */
   5279            tmpccer &= ~TIM_CCER_CC4P;
   \   0000002A   0xF435 0x5500      BICS     R5,R5,#0x2000
   5280            tmpccer |= ((TIM_ICPolarity << 12U) & TIM_CCER_CC4P);
   \   0000002E   0x0309             LSLS     R1,R1,#+12
   \   00000030   0xF411 0x5100      ANDS     R1,R1,#0x2000
   \   00000034   0x430D             ORRS     R5,R1,R5
   5281          
   5282            /* Write to TIMx CCMR2 and CCER registers */
   5283            TIMx->CCMR2 = tmpccmr2;
   \   00000036   0x61C4             STR      R4,[R0, #+28]
   5284            TIMx->CCER = tmpccer ;
   \   00000038   0x6205             STR      R5,[R0, #+32]
   5285          }
   \   0000003A   0xBC70             POP      {R4-R6}
   \   0000003C   0x4770             BX       LR               ;; return
   5286          
   5287          /**
   5288            * @brief  Selects the Input Trigger source
   5289            * @param  TIMx  to select the TIM peripheral
   5290            * @param  InputTriggerSource : The Input Trigger source.
   5291            *          This parameter can be one of the following values:
   5292            *            @arg TIM_TS_ITR0 : Internal Trigger 0
   5293            *            @arg TIM_TS_ITR1 : Internal Trigger 1
   5294            *            @arg TIM_TS_ITR2 : Internal Trigger 2
   5295            *            @arg TIM_TS_ITR3 : Internal Trigger 3
   5296            *            @arg TIM_TS_TI1F_ED : TI1 Edge Detector
   5297            *            @arg TIM_TS_TI1FP1 : Filtered Timer Input 1
   5298            *            @arg TIM_TS_TI2FP2 : Filtered Timer Input 2
   5299            *            @arg TIM_TS_ETRF : External Trigger input
   5300            * @retval None
   5301            */

   \                                 In section .text, align 2, keep-with-next
   5302          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
   5303          {
   5304            uint32_t tmpsmcr = 0U;
   \                     TIM_ITRx_SetConfig:
   \   00000000   0x2200             MOVS     R2,#+0
   5305          
   5306             /* Get the TIMx SMCR register value */
   5307             tmpsmcr = TIMx->SMCR;
   \   00000002   0x6883             LDR      R3,[R0, #+8]
   \   00000004   0x001A             MOVS     R2,R3
   5308             /* Reset the TS Bits */
   5309             tmpsmcr &= ~TIM_SMCR_TS;
   \   00000006   0xF032 0x0270      BICS     R2,R2,#0x70
   5310             /* Set the Input Trigger source and the slave mode*/
   5311             tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0xF051 0x0107      ORRS     R1,R1,#0x7
   \   00000010   0x430A             ORRS     R2,R1,R2
   5312             /* Write to TIMx SMCR */
   5313             TIMx->SMCR = tmpsmcr;
   \   00000012   0x6082             STR      R2,[R0, #+8]
   5314          }
   \   00000014   0x4770             BX       LR               ;; return
   5315          /**
   5316            * @brief  Configures the TIMx External Trigger (ETR).
   5317            * @param  TIMx  to select the TIM peripheral
   5318            * @param  TIM_ExtTRGPrescaler : The external Trigger Prescaler.
   5319            *          This parameter can be one of the following values:
   5320            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   5321            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   5322            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   5323            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   5324            * @param  TIM_ExtTRGPolarity : The external Trigger Polarity.
   5325            *          This parameter can be one of the following values:
   5326            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   5327            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   5328            * @param  ExtTRGFilter : External Trigger Filter.
   5329            *          This parameter must be a value between 0x00 and 0x0F
   5330            * @retval None
   5331            */

   \                                 In section .text, align 2, keep-with-next
   5332          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5333                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5334          {
   \                     TIM_ETR_SetConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
   5335            uint32_t tmpsmcr = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
   5336          
   5337            tmpsmcr = TIMx->SMCR;
   \   00000004   0x6885             LDR      R5,[R0, #+8]
   \   00000006   0x002C             MOVS     R4,R5
   5338          
   5339            /* Reset the ETR Bits */
   5340            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \   00000008   0xF434 0x447F      BICS     R4,R4,#0xFF00
   5341          
   5342            /* Set the Prescaler, the Filter value and the Polarity */
   5343            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0xEA51 0x2103      ORRS     R1,R1,R3, LSL #+8
   \   00000012   0x430C             ORRS     R4,R1,R4
   5344          
   5345            /* Write to TIMx SMCR */
   5346            TIMx->SMCR = tmpsmcr;
   \   00000014   0x6084             STR      R4,[R0, #+8]
   5347          }
   \   00000016   0xBC30             POP      {R4,R5}
   \   00000018   0x4770             BX       LR               ;; return
   5348          
   5349          /**
   5350            * @brief  Enables or disables the TIM Capture Compare Channel x.
   5351            * @param  TIMx  to select the TIM peripheral
   5352            * @param  Channel : specifies the TIM Channel
   5353            *          This parameter can be one of the following values:
   5354            *            @arg TIM_CHANNEL_1: TIM Channel 1
   5355            *            @arg TIM_CHANNEL_2: TIM Channel 2
   5356            *            @arg TIM_CHANNEL_3: TIM Channel 3
   5357            *            @arg TIM_CHANNEL_4: TIM Channel 4
   5358            * @param  ChannelState : specifies the TIM Channel CCxE bit new state.
   5359            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
   5360            * @retval None
   5361            */

   \                                 In section .text, align 2, keep-with-next
   5362          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   5363          {
   \                     TIM_CCxChannelCmd:
   \   00000000   0xB410             PUSH     {R4}
   5364            uint32_t tmp = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   5365          
   5366            /* Check the parameters */
   5367            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   5368            assert_param(IS_TIM_CHANNELS(Channel));
   5369          
   5370            tmp = TIM_CCER_CC1E << Channel;
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x0023             MOVS     R3,R4
   5371          
   5372            /* Reset the CCxE Bit */
   5373            TIMx->CCER &= ~tmp;
   \   0000000A   0x6A04             LDR      R4,[R0, #+32]
   \   0000000C   0xEA34 0x0303      BICS     R3,R4,R3
   \   00000010   0x6203             STR      R3,[R0, #+32]
   5374          
   5375            /* Set or reset the CCxE Bit */
   5376            TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
   \   00000012   0x6A03             LDR      R3,[R0, #+32]
   \   00000014   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000018   0x4319             ORRS     R1,R1,R3
   \   0000001A   0x6201             STR      R1,[R0, #+32]
   5377          }
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0xFFFFF3F3         DC32     0xfffff3f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0xFFFF0F0F         DC32     0xffff0f0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x40000800         DC32     0x40000800
   5378          
   5379          /**
   5380            * @}
   5381            */
   5382          
   5383          #endif /* HAL_TIM_MODULE_ENABLED */
   5384          /**
   5385            * @}
   5386            */
   5387          
   5388          /**
   5389            * @}
   5390            */
   5391          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  HAL_TIM_Base_DeInit
              8 -> HAL_TIM_Base_MspDeInit
        0  HAL_TIM_Base_GetState
        8  HAL_TIM_Base_Init
              8 -> HAL_TIM_Base_MspInit
              8 -> TIM_Base_SetConfig
        0  HAL_TIM_Base_MspDeInit
        0  HAL_TIM_Base_MspInit
        0  HAL_TIM_Base_Start
        8  HAL_TIM_Base_Start_DMA
              8 -> HAL_DMA_Start_IT
        0  HAL_TIM_Base_Start_IT
        0  HAL_TIM_Base_Stop
        0  HAL_TIM_Base_Stop_DMA
        0  HAL_TIM_Base_Stop_IT
        8  HAL_TIM_ConfigClockSource
              8 -> TIM_ETR_SetConfig
              8 -> TIM_ITRx_SetConfig
              8 -> TIM_TI1_ConfigInputStage
              8 -> TIM_TI2_ConfigInputStage
       16  HAL_TIM_ConfigOCrefClear
             16 -> TIM_ETR_SetConfig
        0  HAL_TIM_ConfigTI1Input
       24  HAL_TIM_DMABurst_ReadStart
             24 -> HAL_DMA_Start_IT
       16  HAL_TIM_DMABurst_ReadStop
             16 -> HAL_DMA_Abort
       24  HAL_TIM_DMABurst_WriteStart
             24 -> HAL_DMA_Start_IT
       16  HAL_TIM_DMABurst_WriteStop
             16 -> HAL_DMA_Abort
        8  HAL_TIM_Encoder_DeInit
              8 -> HAL_TIM_Encoder_MspDeInit
        0  HAL_TIM_Encoder_GetState
       16  HAL_TIM_Encoder_Init
             16 -> HAL_TIM_Encoder_MspInit
             16 -> TIM_Base_SetConfig
        0  HAL_TIM_Encoder_MspDeInit
        0  HAL_TIM_Encoder_MspInit
        8  HAL_TIM_Encoder_Start
              8 -> TIM_CCxChannelCmd
       16  HAL_TIM_Encoder_Start_DMA
             16 -> HAL_DMA_Start_IT
             16 -> TIM_CCxChannelCmd
        8  HAL_TIM_Encoder_Start_IT
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_Encoder_Stop
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_Encoder_Stop_DMA
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_Encoder_Stop_IT
              8 -> TIM_CCxChannelCmd
        0  HAL_TIM_ErrorCallback
        0  HAL_TIM_GenerateEvent
        0  HAL_TIM_IC_CaptureCallback
       16  HAL_TIM_IC_ConfigChannel
             16 -> TIM_TI1_SetConfig
             16 -> TIM_TI2_SetConfig
             16 -> TIM_TI3_SetConfig
             16 -> TIM_TI4_SetConfig
        8  HAL_TIM_IC_DeInit
              8 -> HAL_TIM_IC_MspDeInit
        0  HAL_TIM_IC_GetState
        8  HAL_TIM_IC_Init
              8 -> HAL_TIM_IC_MspInit
              8 -> TIM_Base_SetConfig
        0  HAL_TIM_IC_MspDeInit
        0  HAL_TIM_IC_MspInit
        8  HAL_TIM_IC_Start
              8 -> TIM_CCxChannelCmd
       16  HAL_TIM_IC_Start_DMA
             16 -> HAL_DMA_Start_IT
             16 -> TIM_CCxChannelCmd
        8  HAL_TIM_IC_Start_IT
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_IC_Stop
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_IC_Stop_DMA
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_IC_Stop_IT
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_IRQHandler
              8 -> HAL_TIMEx_BreakCallback
              8 -> HAL_TIMEx_CommutationCallback
              8 -> HAL_TIM_IC_CaptureCallback
              8 -> HAL_TIM_OC_DelayElapsedCallback
              8 -> HAL_TIM_PWM_PulseFinishedCallback
              8 -> HAL_TIM_PeriodElapsedCallback
              8 -> HAL_TIM_TriggerCallback
        8  HAL_TIM_OC_ConfigChannel
              8 -> TIM_OC1_SetConfig
              8 -> TIM_OC2_SetConfig
              8 -> TIM_OC3_SetConfig
              8 -> TIM_OC4_SetConfig
        8  HAL_TIM_OC_DeInit
              8 -> HAL_TIM_OC_MspDeInit
        0  HAL_TIM_OC_DelayElapsedCallback
        0  HAL_TIM_OC_GetState
        8  HAL_TIM_OC_Init
              8 -> HAL_TIM_OC_MspInit
              8 -> TIM_Base_SetConfig
        0  HAL_TIM_OC_MspDeInit
        0  HAL_TIM_OC_MspInit
        8  HAL_TIM_OC_Start
              8 -> TIM_CCxChannelCmd
       16  HAL_TIM_OC_Start_DMA
             16 -> HAL_DMA_Start_IT
             16 -> TIM_CCxChannelCmd
        8  HAL_TIM_OC_Start_IT
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_OC_Stop
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_OC_Stop_DMA
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_OC_Stop_IT
              8 -> TIM_CCxChannelCmd
       48  HAL_TIM_OnePulse_ConfigChannel
             48 -> TIM_OC1_SetConfig
             48 -> TIM_OC2_SetConfig
             48 -> TIM_TI1_SetConfig
             48 -> TIM_TI2_SetConfig
        8  HAL_TIM_OnePulse_DeInit
              8 -> HAL_TIM_OnePulse_MspDeInit
        0  HAL_TIM_OnePulse_GetState
       16  HAL_TIM_OnePulse_Init
             16 -> HAL_TIM_OnePulse_MspInit
             16 -> TIM_Base_SetConfig
        0  HAL_TIM_OnePulse_MspDeInit
        0  HAL_TIM_OnePulse_MspInit
        8  HAL_TIM_OnePulse_Start
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_OnePulse_Start_IT
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_OnePulse_Stop
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_OnePulse_Stop_IT
              8 -> TIM_CCxChannelCmd
       16  HAL_TIM_PWM_ConfigChannel
             16 -> TIM_OC1_SetConfig
             16 -> TIM_OC2_SetConfig
             16 -> TIM_OC3_SetConfig
             16 -> TIM_OC4_SetConfig
        8  HAL_TIM_PWM_DeInit
              8 -> HAL_TIM_PWM_MspDeInit
        0  HAL_TIM_PWM_GetState
        8  HAL_TIM_PWM_Init
              8 -> HAL_TIM_PWM_MspInit
              8 -> TIM_Base_SetConfig
        0  HAL_TIM_PWM_MspDeInit
        0  HAL_TIM_PWM_MspInit
        0  HAL_TIM_PWM_PulseFinishedCallback
        8  HAL_TIM_PWM_Start
              8 -> TIM_CCxChannelCmd
       16  HAL_TIM_PWM_Start_DMA
             16 -> HAL_DMA_Start_IT
             16 -> TIM_CCxChannelCmd
        8  HAL_TIM_PWM_Start_IT
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_PWM_Stop
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_PWM_Stop_DMA
              8 -> TIM_CCxChannelCmd
        8  HAL_TIM_PWM_Stop_IT
              8 -> TIM_CCxChannelCmd
        0  HAL_TIM_PeriodElapsedCallback
        0  HAL_TIM_ReadCapturedValue
        8  HAL_TIM_SlaveConfigSynchronization
              8 -> TIM_SlaveTimer_SetConfig
        8  HAL_TIM_SlaveConfigSynchronization_IT
              8 -> TIM_SlaveTimer_SetConfig
        0  HAL_TIM_TriggerCallback
        0  TIM_Base_SetConfig
        4  TIM_CCxChannelCmd
        8  TIM_DMACaptureCplt
              8 -> HAL_TIM_IC_CaptureCallback
        8  TIM_DMADelayPulseCplt
              8 -> HAL_TIM_PWM_PulseFinishedCallback
        8  TIM_DMAError
              8 -> HAL_TIM_ErrorCallback
        8  TIM_DMAPeriodElapsedCplt
              8 -> HAL_TIM_PeriodElapsedCallback
        8  TIM_DMATriggerCplt
              8 -> HAL_TIM_TriggerCallback
        8  TIM_ETR_SetConfig
        0  TIM_ITRx_SetConfig
        8  TIM_OC1_SetConfig
        8  TIM_OC2_SetConfig
        8  TIM_OC3_SetConfig
        8  TIM_OC4_SetConfig
       16  TIM_SlaveTimer_SetConfig
             16 -> TIM_ETR_SetConfig
             16 -> TIM_TI1_ConfigInputStage
             16 -> TIM_TI2_ConfigInputStage
        8  TIM_TI1_ConfigInputStage
       12  TIM_TI1_SetConfig
        8  TIM_TI2_ConfigInputStage
       12  TIM_TI2_SetConfig
       12  TIM_TI3_SetConfig
       12  TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable19
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
      68  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      56  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      28  HAL_TIM_Base_Start
     106  HAL_TIM_Base_Start_DMA
      28  HAL_TIM_Base_Start_IT
      52  HAL_TIM_Base_Stop
      58  HAL_TIM_Base_Stop_DMA
      52  HAL_TIM_Base_Stop_IT
     280  HAL_TIM_ConfigClockSource
     240  HAL_TIM_ConfigOCrefClear
      22  HAL_TIM_ConfigTI1Input
     362  HAL_TIM_DMABurst_ReadStart
     122  HAL_TIM_DMABurst_ReadStop
     362  HAL_TIM_DMABurst_WriteStart
     122  HAL_TIM_DMABurst_WriteStop
      68  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     172  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      74  HAL_TIM_Encoder_Start
     328  HAL_TIM_Encoder_Start_DMA
     122  HAL_TIM_Encoder_Start_IT
      98  HAL_TIM_Encoder_Stop
     150  HAL_TIM_Encoder_Stop_DMA
     150  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      44  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     212  HAL_TIM_IC_ConfigChannel
      68  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      56  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      28  HAL_TIM_IC_Start
     268  HAL_TIM_IC_Start_DMA
     104  HAL_TIM_IC_Start_IT
      52  HAL_TIM_IC_Stop
     134  HAL_TIM_IC_Stop_DMA
     128  HAL_TIM_IC_Stop_IT
     382  HAL_TIM_IRQHandler
      94  HAL_TIM_OC_ConfigChannel
      68  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      56  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      50  HAL_TIM_OC_Start
     294  HAL_TIM_OC_Start_DMA
     126  HAL_TIM_OC_Start_IT
      98  HAL_TIM_OC_Stop
     180  HAL_TIM_OC_Stop_DMA
     174  HAL_TIM_OC_Stop_IT
     272  HAL_TIM_OnePulse_ConfigChannel
      68  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      80  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      48  HAL_TIM_OnePulse_Start
      72  HAL_TIM_OnePulse_Start_IT
     108  HAL_TIM_OnePulse_Stop
     132  HAL_TIM_OnePulse_Stop_IT
     252  HAL_TIM_PWM_ConfigChannel
      68  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      56  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      50  HAL_TIM_PWM_Start
     294  HAL_TIM_PWM_Start_DMA
     126  HAL_TIM_PWM_Start_IT
     104  HAL_TIM_PWM_Stop
     180  HAL_TIM_PWM_Stop_DMA
     174  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      72  HAL_TIM_ReadCapturedValue
      74  HAL_TIM_SlaveConfigSynchronization
      74  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
     104  TIM_Base_SetConfig
      32  TIM_CCxChannelCmd
      68  TIM_DMACaptureCplt
      68  TIM_DMADelayPulseCplt
      16  TIM_DMAError
      16  TIM_DMAPeriodElapsedCplt
      16  TIM_DMATriggerCplt
      26  TIM_ETR_SetConfig
      22  TIM_ITRx_SetConfig
     102  TIM_OC1_SetConfig
     112  TIM_OC2_SetConfig
     110  TIM_OC3_SetConfig
      82  TIM_OC4_SetConfig
     156  TIM_SlaveTimer_SetConfig
      44  TIM_TI1_ConfigInputStage
     100  TIM_TI1_SetConfig
      46  TIM_TI2_ConfigInputStage
      62  TIM_TI2_SetConfig
      60  TIM_TI3_SetConfig
      62  TIM_TI4_SetConfig

 
 9 472 bytes in section .text
 
 9 472 bytes of CODE memory

Errors: none
Warnings: 1
