###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  09:12:48 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\FreeModbus\modb #
#                    us\mb.c                                                  #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\FreeModbus\mod #
#                    bus\mb.c" -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D     #
#                    STM32F103xB -lC "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/List\" -o                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    Obj\" --no_cse --no_unroll --no_inline --no_code_motion  #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\mb.lst                                               #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\mb.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\FreeModbus\modbus\mb.c
      1          /* 
      2           * FreeModbus Libary: A portable Modbus implementation for Modbus ASCII/RTU.
      3           * Copyright (c) 2006 Christian Walter <wolti@sil.at>
      4           * All rights reserved.
      5           *
      6           * Redistribution and use in source and binary forms, with or without
      7           * modification, are permitted provided that the following conditions
      8           * are met:
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer.
     11           * 2. Redistributions in binary form must reproduce the above copyright
     12           *    notice, this list of conditions and the following disclaimer in the
     13           *    documentation and/or other materials provided with the distribution.
     14           * 3. The name of the author may not be used to endorse or promote products
     15           *    derived from this software without specific prior written permission.
     16           *
     17           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     19           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     20           * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     22           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     23           * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     24           * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     25           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
     26           * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           *
     28           * File: $Id: mb.c,v 1.27 2007/02/18 23:45:41 wolti Exp $
     29           */
     30          
     31          /* ----------------------- System includes ----------------------------------*/
     32          #include "stdlib.h"
     33          #include "string.h"
     34          
     35          /* ----------------------- Platform includes --------------------------------*/
     36          #include "port.h"
     37          #include "usart.h"

  /**
    ^
"D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_usart.h",1  Warning[Pa050]: 
          non-native end of line sequence detected (this diagnostic is only
          issued once)
     38          
     39          /* ----------------------- Modbus includes ----------------------------------*/
     40          
     41          #include "mb.h"
     42          #include "mbconfig.h"
     43          #include "mbframe.h"
     44          #include "mbproto.h"
     45          #include "mbfunc.h"
     46          
     47          #include "mbport.h"
     48          #if MB_RTU_ENABLED == 1
     49          #include "mbrtu.h"
     50          #endif
     51          #if MB_ASCII_ENABLED == 1
     52          #include "mbascii.h"
     53          #endif
     54          #if MB_TCP_ENABLED == 1
     55          #include "mbtcp.h"
     56          #endif
     57          
     58          #ifndef MB_PORT_HAS_CLOSE
     59          #define MB_PORT_HAS_CLOSE 0
     60          #endif
     61          
     62          /* ----------------------- Static variables ---------------------------------*/
     63          

   \                                 In section .bss, align 1
     64          static UCHAR    ucMBAddress;
   \                     ucMBAddress:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     65          static eMBMode  eMBCurrentMode;
                                 ^
Warning[Pe550]: variable "eMBCurrentMode" was set but never used
   \                     eMBCurrentMode:
   \   00000000                      DS8 1
     66          
     67          static enum
     68          {
     69              STATE_ENABLED,
     70              STATE_DISABLED,
     71              STATE_NOT_INITIALIZED

   \                                 In section .data, align 1
     72          } eMBState = STATE_NOT_INITIALIZED;
   \                     eMBState:
   \   00000000   0x02               DC8 2
     73          
     74          /* Functions pointer which are initialized in eMBInit( ). Depending on the
     75           * mode (RTU or ASCII) the are set to the correct implementations.
     76           */

   \                                 In section .bss, align 4
     77          static peMBFrameSend peMBFrameSendCur;
   \                     peMBFrameSendCur:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     78          static pvMBFrameStart pvMBFrameStartCur;
   \                     pvMBFrameStartCur:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     79          static pvMBFrameStop pvMBFrameStopCur;
   \                     pvMBFrameStopCur:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     80          static peMBFrameReceive peMBFrameReceiveCur;
   \                     peMBFrameReceiveCur:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     81          static pvMBFrameClose pvMBFrameCloseCur;
   \                     pvMBFrameCloseCur:
   \   00000000                      DS8 4
     82          
     83          /* Callback functions required by the porting layer. They are called when
     84           * an external event has happend which includes a timeout or the reception
     85           * or transmission of a character.
     86           */

   \                                 In section .bss, align 4
     87          BOOL( *pxMBFrameCBByteReceived ) ( void );
   \                     pxMBFrameCBByteReceived:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     88          BOOL( *pxMBFrameCBTransmitterEmpty ) ( void );
   \                     pxMBFrameCBTransmitterEmpty:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     89          BOOL( *pxMBPortCBTimerExpired ) ( void );
   \                     pxMBPortCBTimerExpired:
   \   00000000                      DS8 4
     90          

   \                                 In section .bss, align 4
     91          BOOL( *pxMBFrameCBReceiveFSMCur ) ( void );
   \                     pxMBFrameCBReceiveFSMCur:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     92          BOOL( *pxMBFrameCBTransmitFSMCur ) ( void );
   \                     pxMBFrameCBTransmitFSMCur:
   \   00000000                      DS8 4
     93          
     94          /* An array of Modbus functions handlers which associates Modbus function
     95           * codes with implementing functions.
     96           */

   \                                 In section .data, align 4
     97          static xMBFunctionHandler xFuncHandlers[MB_FUNC_HANDLERS_MAX] = {
   \                     xFuncHandlers:
   \   00000000   0x11 0x00          DC8 17, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x........         DC32 eMBFuncReportSlaveID
   \   00000008   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \   0000000C   0x........         DC32 eMBFuncReadInputRegister
   \   00000010   0x03 0x00          DC8 3, 0, 0, 0
   \              0x00 0x00    
   \   00000014   0x........         DC32 eMBFuncReadHoldingRegister
   \   00000018   0x10 0x00          DC8 16, 0, 0, 0
   \              0x00 0x00    
   \   0000001C   0x........         DC32 eMBFuncWriteMultipleHoldingRegister
   \   00000020   0x06 0x00          DC8 6, 0, 0, 0
   \              0x00 0x00    
   \   00000024   0x........         DC32 eMBFuncWriteHoldingRegister
   \   00000028   0x17 0x00          DC8 23, 0, 0, 0
   \              0x00 0x00    
   \   0000002C   0x........         DC32 eMBFuncReadWriteMultipleHoldingRegister
   \   00000030   0x01 0x00          DC8 1, 0, 0, 0
   \              0x00 0x00    
   \   00000034   0x........         DC32 eMBFuncReadCoils
   \   00000038   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   0000003C   0x........         DC32 eMBFuncReadDiscreteInputs
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000060   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000070   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     98          #if MB_FUNC_OTHER_REP_SLAVEID_ENABLED > 0
     99              {MB_FUNC_OTHER_REPORT_SLAVEID, eMBFuncReportSlaveID},
    100          #endif
    101          #if MB_FUNC_READ_INPUT_ENABLED > 0
    102              {MB_FUNC_READ_INPUT_REGISTER, eMBFuncReadInputRegister},
    103          #endif
    104          #if MB_FUNC_READ_HOLDING_ENABLED > 0
    105              {MB_FUNC_READ_HOLDING_REGISTER, eMBFuncReadHoldingRegister},
    106          #endif
    107          #if MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED > 0
    108              {MB_FUNC_WRITE_MULTIPLE_REGISTERS, eMBFuncWriteMultipleHoldingRegister},
    109          #endif
    110          #if MB_FUNC_WRITE_HOLDING_ENABLED > 0
    111              {MB_FUNC_WRITE_REGISTER, eMBFuncWriteHoldingRegister},
    112          #endif
    113          #if MB_FUNC_READWRITE_HOLDING_ENABLED > 0
    114              {MB_FUNC_READWRITE_MULTIPLE_REGISTERS, eMBFuncReadWriteMultipleHoldingRegister},
    115          #endif
    116          #if MB_FUNC_READ_COILS_ENABLED > 0
    117              {MB_FUNC_READ_COILS, eMBFuncReadCoils},
    118          #endif
    119          #if MB_FUNC_WRITE_COIL_ENABLED > 0
    120              {MB_FUNC_WRITE_SINGLE_COIL, eMBFuncWriteCoil},
    121          #endif
    122          #if MB_FUNC_WRITE_MULTIPLE_COILS_ENABLED > 0
    123              {MB_FUNC_WRITE_MULTIPLE_COILS, eMBFuncWriteMultipleCoils},
    124          #endif
    125          #if MB_FUNC_READ_DISCRETE_INPUTS_ENABLED > 0
    126              {MB_FUNC_READ_DISCRETE_INPUTS, eMBFuncReadDiscreteInputs},
    127          #endif
    128          };
    129          
    130          /* ----------------------- Start implementation -----------------------------*/

   \                                 In section .text, align 2, keep-with-next
    131          eMBErrorCode
    132          eMBInit( eMBMode eMode, UCHAR ucSlaveAddress)
    133          {
   \                     eMBInit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    134              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000004   0x2500             MOVS     R5,#+0
    135          
    136              /* check preconditions */
    137              if( ( ucSlaveAddress == MB_ADDRESS_BROADCAST ) ||
    138                  ( ucSlaveAddress < MB_ADDRESS_MIN ) || ( ucSlaveAddress > MB_ADDRESS_MAX ) )
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD003             BEQ.N    ??eMBInit_0
   \   0000000C   0x1E48             SUBS     R0,R1,#+1
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x28F7             CMP      R0,#+247
   \   00000012   0xD301             BCC.N    ??eMBInit_1
    139              {
    140                  eStatus = MB_EINVAL;
   \                     ??eMBInit_0:
   \   00000014   0x2502             MOVS     R5,#+2
   \   00000016   0xE031             B.N      ??eMBInit_2
    141              }
    142              else
    143              {
    144                  ucMBAddress = ucSlaveAddress;
   \                     ??eMBInit_1:
   \   00000018   0x....             LDR.N    R0,??DataTable5
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    145          
    146                  switch ( eMode )
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD11D             BNE.N    ??eMBInit_3
    147                  {
    148          #if MB_RTU_ENABLED > 0
    149                  case MB_RTU:
    150                      pvMBFrameStartCur = eMBRTUStart;
   \   00000022   0x....             LDR.N    R0,??DataTable5_1
   \   00000024   0x....             LDR.N    R1,??DataTable5_2
   \   00000026   0x6001             STR      R1,[R0, #+0]
    151                      pvMBFrameStopCur = eMBRTUStop;
   \   00000028   0x....             LDR.N    R0,??DataTable5_3
   \   0000002A   0x....             LDR.N    R1,??DataTable5_4
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    152                      peMBFrameSendCur = eMBRTUSend;
   \   0000002E   0x....             LDR.N    R0,??DataTable5_5
   \   00000030   0x....             LDR.N    R1,??DataTable5_6
   \   00000032   0x6001             STR      R1,[R0, #+0]
    153                      peMBFrameReceiveCur = eMBRTUReceive;
   \   00000034   0x....             LDR.N    R0,??DataTable5_7
   \   00000036   0x....             LDR.N    R1,??DataTable5_8
   \   00000038   0x6001             STR      R1,[R0, #+0]
    154                      pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBPortClose : NULL;
   \   0000003A   0x....             LDR.N    R0,??DataTable5_9
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x6001             STR      R1,[R0, #+0]
    155                      pxMBFrameCBByteReceived = xMBRTUReceiveFSM;
   \   00000040   0x....             LDR.N    R0,??DataTable5_10
   \   00000042   0x....             LDR.N    R1,??DataTable5_11
   \   00000044   0x6001             STR      R1,[R0, #+0]
    156                      pxMBFrameCBTransmitterEmpty = xMBRTUTransmitFSM;
   \   00000046   0x....             LDR.N    R0,??DataTable5_12
   \   00000048   0x....             LDR.N    R1,??DataTable5_13
   \   0000004A   0x6001             STR      R1,[R0, #+0]
    157                      pxMBPortCBTimerExpired = xMBRTUTimerT35Expired;
   \   0000004C   0x....             LDR.N    R0,??DataTable5_14
   \   0000004E   0x....             LDR.N    R1,??DataTable5_15
   \   00000050   0x6001             STR      R1,[R0, #+0]
    158          
    159                      eStatus = eMBRTUInit( ucMBAddress );
   \   00000052   0x....             LDR.N    R0,??DataTable5
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x.... 0x....      BL       eMBRTUInit
   \   0000005A   0x0005             MOVS     R5,R0
    160                      break;
   \   0000005C   0xE000             B.N      ??eMBInit_4
    161          #endif
    162          
    163                  default:
    164                      eStatus = MB_EINVAL;
   \                     ??eMBInit_3:
   \   0000005E   0x2502             MOVS     R5,#+2
    165                  }
    166          
    167                  if( eStatus == MB_ENOERR )
   \                     ??eMBInit_4:
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD10A             BNE.N    ??eMBInit_2
    168                  {
    169                      if( !xMBPortEventInit(  ) )
   \   00000066   0x.... 0x....      BL       xMBPortEventInit
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD101             BNE.N    ??eMBInit_5
    170                      {
    171                          /* port dependent event module initalization failed. */
    172                          eStatus = MB_EPORTERR;
   \   0000006E   0x2503             MOVS     R5,#+3
   \   00000070   0xE004             B.N      ??eMBInit_2
    173                      }
    174                      else
    175                      {
    176                          eMBCurrentMode = eMode;
   \                     ??eMBInit_5:
   \   00000072   0x....             LDR.N    R0,??DataTable5_16
   \   00000074   0x7004             STRB     R4,[R0, #+0]
    177                          eMBState = STATE_DISABLED;
   \   00000076   0x....             LDR.N    R0,??DataTable5_17
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x7001             STRB     R1,[R0, #+0]
    178                      }
    179                  }
    180              }
    181              return eStatus;
   \                     ??eMBInit_2:
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    182          }
    183          
    184          #if MB_TCP_ENABLED > 0
    185          eMBErrorCode
    186          eMBTCPInit( USHORT ucTCPPort )
    187          {
    188              eMBErrorCode    eStatus = MB_ENOERR;
    189          
    190              if( ( eStatus = eMBTCPDoInit( ucTCPPort ) ) != MB_ENOERR )
    191              {
    192                  eMBState = STATE_DISABLED;
    193              }
    194              else if( !xMBPortEventInit(  ) )
    195              {
    196                  /* Port dependent event module initalization failed. */
    197                  eStatus = MB_EPORTERR;
    198              }
    199              else
    200              {
    201                  pvMBFrameStartCur = eMBTCPStart;
    202                  pvMBFrameStopCur = eMBTCPStop;
    203                  peMBFrameReceiveCur = eMBTCPReceive;
    204                  peMBFrameSendCur = eMBTCPSend;
    205                  pvMBFrameCloseCur = MB_PORT_HAS_CLOSE ? vMBTCPPortClose : NULL;
    206                  ucMBAddress = MB_TCP_PSEUDO_ADDRESS;
    207                  eMBCurrentMode = MB_TCP;
    208                  eMBState = STATE_DISABLED;
    209              }
    210              return eStatus;
    211          }
    212          #endif
    213          

   \                                 In section .text, align 2, keep-with-next
    214          eMBErrorCode
    215          eMBRegisterCB( UCHAR ucFunctionCode, pxMBFunctionHandler pxHandler )
    216          {
   \                     eMBRegisterCB:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    217              int             i;
    218              eMBErrorCode    eStatus;
    219          
    220              if( ( 0 < ucFunctionCode ) && ( ucFunctionCode <= 127 ) )
   \   00000006   0x1E60             SUBS     R0,R4,#+1
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x287F             CMP      R0,#+127
   \   0000000C   0xD23B             BCS.N    ??eMBRegisterCB_0
    221              {
    222                  ENTER_CRITICAL_SECTION(  );
   \   0000000E   0x.... 0x....      BL       vPortEnterCritical
    223                  if( pxHandler != NULL )
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD01E             BEQ.N    ??eMBRegisterCB_1
    224                  {
    225                      for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE000             B.N      ??eMBRegisterCB_2
   \                     ??eMBRegisterCB_3:
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \                     ??eMBRegisterCB_2:
   \   0000001E   0x2810             CMP      R0,#+16
   \   00000020   0xDA13             BGE.N    ??eMBRegisterCB_4
    226                      {
    227                          if( ( xFuncHandlers[i].pxHandler == NULL ) ||
    228                              ( xFuncHandlers[i].pxHandler == pxHandler ) )
   \   00000022   0x....             LDR.N    R1,??DataTable5_18
   \   00000024   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   00000028   0x6849             LDR      R1,[R1, #+4]
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD006             BEQ.N    ??eMBRegisterCB_5
   \   0000002E   0x....             LDR.N    R1,??DataTable5_18
   \   00000030   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   00000034   0x6849             LDR      R1,[R1, #+4]
   \   00000036   0x002A             MOVS     R2,R5
   \   00000038   0x4291             CMP      R1,R2
   \   0000003A   0xD1EF             BNE.N    ??eMBRegisterCB_3
    229                          {
    230                              xFuncHandlers[i].ucFunctionCode = ucFunctionCode;
   \                     ??eMBRegisterCB_5:
   \   0000003C   0x....             LDR.N    R1,??DataTable5_18
   \   0000003E   0xF801 0x4030      STRB     R4,[R1, R0, LSL #+3]
    231                              xFuncHandlers[i].pxHandler = pxHandler;
   \   00000042   0x....             LDR.N    R1,??DataTable5_18
   \   00000044   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   00000048   0x604D             STR      R5,[R1, #+4]
    232                              break;
    233                          }
    234                      }
    235                      eStatus = ( i != MB_FUNC_HANDLERS_MAX ) ? MB_ENOERR : MB_ENORES;
   \                     ??eMBRegisterCB_4:
   \   0000004A   0x2810             CMP      R0,#+16
   \   0000004C   0xD001             BEQ.N    ??eMBRegisterCB_6
   \   0000004E   0x2400             MOVS     R4,#+0
   \   00000050   0xE000             B.N      ??eMBRegisterCB_7
   \                     ??eMBRegisterCB_6:
   \   00000052   0x2404             MOVS     R4,#+4
   \                     ??eMBRegisterCB_7:
   \   00000054   0xE014             B.N      ??eMBRegisterCB_8
    236                  }
    237                  else
    238                  {
    239                      for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
   \                     ??eMBRegisterCB_1:
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE000             B.N      ??eMBRegisterCB_9
   \                     ??eMBRegisterCB_10:
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \                     ??eMBRegisterCB_9:
   \   0000005C   0x2810             CMP      R0,#+16
   \   0000005E   0xDA0E             BGE.N    ??eMBRegisterCB_11
    240                      {
    241                          if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
   \   00000060   0x....             LDR.N    R1,??DataTable5_18
   \   00000062   0xF811 0x1030      LDRB     R1,[R1, R0, LSL #+3]
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x42A1             CMP      R1,R4
   \   0000006A   0xD1F6             BNE.N    ??eMBRegisterCB_10
    242                          {
    243                              xFuncHandlers[i].ucFunctionCode = 0;
   \   0000006C   0x....             LDR.N    R1,??DataTable5_18
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0xF801 0x2030      STRB     R2,[R1, R0, LSL #+3]
    244                              xFuncHandlers[i].pxHandler = NULL;
   \   00000074   0x....             LDR.N    R1,??DataTable5_18
   \   00000076   0xEB11 0x00C0      ADDS     R0,R1,R0, LSL #+3
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x6041             STR      R1,[R0, #+4]
    245                              break;
    246                          }
    247                      }
    248                      /* Remove can't fail. */
    249                      eStatus = MB_ENOERR;
   \                     ??eMBRegisterCB_11:
   \   0000007E   0x2400             MOVS     R4,#+0
    250                  }
    251                  EXIT_CRITICAL_SECTION(  );
   \                     ??eMBRegisterCB_8:
   \   00000080   0x.... 0x....      BL       vPortExitCritical
   \   00000084   0xE000             B.N      ??eMBRegisterCB_12
    252              }
    253              else
    254              {
    255                  eStatus = MB_EINVAL;
   \                     ??eMBRegisterCB_0:
   \   00000086   0x2402             MOVS     R4,#+2
    256              }
    257              return eStatus;
   \                     ??eMBRegisterCB_12:
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    258          }
    259          
    260          

   \                                 In section .text, align 2, keep-with-next
    261          eMBErrorCode
    262          eMBClose( void )
    263          {
   \                     eMBClose:
   \   00000000   0xB510             PUSH     {R4,LR}
    264              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000002   0x2400             MOVS     R4,#+0
    265          
    266              if( eMBState == STATE_DISABLED )
   \   00000004   0x....             LDR.N    R0,??DataTable5_17
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD107             BNE.N    ??eMBClose_0
    267              {
    268                  if( pvMBFrameCloseCur != NULL )
   \   0000000C   0x....             LDR.N    R0,??DataTable5_9
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??eMBClose_1
    269                  {
    270                      pvMBFrameCloseCur(  );
   \   00000014   0x....             LDR.N    R0,??DataTable5_9
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x4780             BLX      R0
   \   0000001A   0xE000             B.N      ??eMBClose_1
    271                  }
    272              }
    273              else
    274              {
    275                  eStatus = MB_EILLSTATE;
   \                     ??eMBClose_0:
   \   0000001C   0x2406             MOVS     R4,#+6
    276              }
    277              return eStatus;
   \                     ??eMBClose_1:
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    278          }
    279          

   \                                 In section .text, align 2, keep-with-next
    280          eMBErrorCode
    281          eMBEnable( void )
    282          {
   \                     eMBEnable:
   \   00000000   0xB510             PUSH     {R4,LR}
    283              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000002   0x2400             MOVS     R4,#+0
    284          
    285              if( eMBState == STATE_DISABLED )
   \   00000004   0x....             LDR.N    R0,??DataTable5_17
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD106             BNE.N    ??eMBEnable_0
    286              {
    287                  /* Activate the protocol stack. */
    288                  pvMBFrameStartCur(  );
   \   0000000C   0x....             LDR.N    R0,??DataTable5_1
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x4780             BLX      R0
    289                  eMBState = STATE_ENABLED;
   \   00000012   0x....             LDR.N    R0,??DataTable5_17
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   \   00000018   0xE000             B.N      ??eMBEnable_1
    290              }
    291              else
    292              {
    293                  eStatus = MB_EILLSTATE;
   \                     ??eMBEnable_0:
   \   0000001A   0x2406             MOVS     R4,#+6
    294              }
    295              return eStatus;
   \                     ??eMBEnable_1:
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    296          }
    297          

   \                                 In section .text, align 2, keep-with-next
    298          eMBErrorCode
    299          eMBDisable( void )
    300          {
   \                     eMBDisable:
   \   00000000   0xB580             PUSH     {R7,LR}
    301              eMBErrorCode    eStatus;
    302          
    303              if( eMBState == STATE_ENABLED )
   \   00000002   0x....             LDR.N    R0,??DataTable5_17
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD107             BNE.N    ??eMBDisable_0
    304              {
    305                  pvMBFrameStopCur(  );
   \   0000000A   0x....             LDR.N    R0,??DataTable5_3
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4780             BLX      R0
    306                  eMBState = STATE_DISABLED;
   \   00000010   0x....             LDR.N    R0,??DataTable5_17
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x7001             STRB     R1,[R0, #+0]
    307                  eStatus = MB_ENOERR;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE006             B.N      ??eMBDisable_1
    308              }
    309              else if( eMBState == STATE_DISABLED )
   \                     ??eMBDisable_0:
   \   0000001A   0x....             LDR.N    R0,??DataTable5_17
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD101             BNE.N    ??eMBDisable_2
    310              {
    311                  eStatus = MB_ENOERR;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE000             B.N      ??eMBDisable_1
    312              }
    313              else
    314              {
    315                  eStatus = MB_EILLSTATE;
   \                     ??eMBDisable_2:
   \   00000026   0x2006             MOVS     R0,#+6
    316              }
    317              return eStatus;
   \                     ??eMBDisable_1:
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD02             POP      {R1,PC}          ;; return
    318          }
    319          

   \                                 In section .text, align 2, keep-with-next
    320          eMBErrorCode eMBPoll( void )
    321          {
   \                     eMBPoll:
   \   00000000   0xB580             PUSH     {R7,LR}
    322              static UCHAR   *ucMBFrame;
    323              static UCHAR    ucRcvAddress;
    324              static UCHAR    ucFunctionCode;
    325              static USHORT   usLength;
    326              static eMBException eException;
    327          
    328              int             i;
    329              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000002   0x2000             MOVS     R0,#+0
    330              eMBEventType    eEvent;
    331          
    332              /* Check if the protocol stack is ready. */
    333              if( eMBState != STATE_ENABLED )
   \   00000004   0x....             LDR.N    R1,??DataTable5_17
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD001             BEQ.N    ??eMBPoll_0
    334              {
    335                  return MB_EILLSTATE;
   \   0000000C   0x2006             MOVS     R0,#+6
   \   0000000E   0xE079             B.N      ??eMBPoll_1
    336              }
    337          
    338              /* Check if there is a event available. If not return control to caller.
    339               * Otherwise we will handle the event. */
    340              if( xMBPortEventGet( &eEvent ) == TRUE )
   \                     ??eMBPoll_0:
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       xMBPortEventGet
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD173             BNE.N    ??eMBPoll_2
    341              {
    342                  switch ( eEvent )
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD005             BEQ.N    ??eMBPoll_3
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD01B             BEQ.N    ??eMBPoll_4
   \   00000026   0xD303             BCC.N    ??eMBPoll_5
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD06A             BEQ.N    ??eMBPoll_6
   \   0000002C   0xE069             B.N      ??eMBPoll_2
    343                  {
    344                  case EV_READY:
    345                      break;
   \                     ??eMBPoll_3:
   \   0000002E   0xE068             B.N      ??eMBPoll_2
    346          
    347                  case EV_FRAME_RECEIVED:
    348                      eStatus = peMBFrameReceiveCur( &ucRcvAddress, &ucMBFrame, &usLength );
   \                     ??eMBPoll_5:
   \   00000030   0x....             LDR.N    R2,??DataTable5_19
   \   00000032   0x....             LDR.N    R1,??DataTable5_20
   \   00000034   0x....             LDR.N    R0,??DataTable5_21
   \   00000036   0x....             LDR.N    R3,??DataTable5_7
   \   00000038   0x681B             LDR      R3,[R3, #+0]
   \   0000003A   0x4798             BLX      R3
    349                      if( eStatus == MB_ENOERR )
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10C             BNE.N    ??eMBPoll_7
    350                      {
    351                          /* Check if the frame is for us. If not ignore the frame. */
    352                          if( ( ucRcvAddress == ucMBAddress ) || ( ucRcvAddress == MB_ADDRESS_BROADCAST ) )
   \   00000042   0x....             LDR.N    R0,??DataTable5_21
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x....             LDR.N    R1,??DataTable5
   \   00000048   0x7809             LDRB     R1,[R1, #+0]
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD003             BEQ.N    ??eMBPoll_8
   \   0000004E   0x....             LDR.N    R0,??DataTable5_21
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD102             BNE.N    ??eMBPoll_7
    353                          {
    354                              ( void )xMBPortEventPost( EV_EXECUTE );
   \                     ??eMBPoll_8:
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x.... 0x....      BL       xMBPortEventPost
    355                          }
    356                      }
    357                      break;
   \                     ??eMBPoll_7:
   \   0000005C   0xE051             B.N      ??eMBPoll_2
    358          
    359                  case EV_EXECUTE:
    360                      ucFunctionCode = ucMBFrame[MB_PDU_FUNC_OFF];
   \                     ??eMBPoll_4:
   \   0000005E   0x....             LDR.N    R0,??DataTable5_22
   \   00000060   0x....             LDR.N    R1,??DataTable5_20
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0x7001             STRB     R1,[R0, #+0]
    361                      eException = MB_EX_ILLEGAL_FUNCTION;
   \   00000068   0x....             LDR.N    R0,??DataTable5_23
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
    362                      for( i = 0; i < MB_FUNC_HANDLERS_MAX; i++ )
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0xE000             B.N      ??eMBPoll_9
   \                     ??eMBPoll_10:
   \   00000072   0x1C52             ADDS     R2,R2,#+1
   \                     ??eMBPoll_9:
   \   00000074   0x2A10             CMP      R2,#+16
   \   00000076   0xDA15             BGE.N    ??eMBPoll_11
    363                      {
    364                          /* No more function handlers registered. Abort. */
    365                          if( xFuncHandlers[i].ucFunctionCode == 0 )
   \   00000078   0x....             LDR.N    R0,??DataTable5_18
   \   0000007A   0xF810 0x0032      LDRB     R0,[R0, R2, LSL #+3]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD010             BEQ.N    ??eMBPoll_11
    366                          {
    367                              break;
    368                          }
    369                          else if( xFuncHandlers[i].ucFunctionCode == ucFunctionCode )
   \                     ??eMBPoll_12:
   \   00000082   0x....             LDR.N    R0,??DataTable5_18
   \   00000084   0xF810 0x0032      LDRB     R0,[R0, R2, LSL #+3]
   \   00000088   0x....             LDR.N    R1,??DataTable5_22
   \   0000008A   0x7809             LDRB     R1,[R1, #+0]
   \   0000008C   0x4288             CMP      R0,R1
   \   0000008E   0xD1F0             BNE.N    ??eMBPoll_10
    370                          {
    371                              eException = xFuncHandlers[i].pxHandler( ucMBFrame, &usLength );
   \   00000090   0x....             LDR.N    R1,??DataTable5_19
   \   00000092   0x....             LDR.N    R0,??DataTable5_20
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x....             LDR.N    R3,??DataTable5_18
   \   00000098   0xEB13 0x02C2      ADDS     R2,R3,R2, LSL #+3
   \   0000009C   0x6852             LDR      R2,[R2, #+4]
   \   0000009E   0x4790             BLX      R2
   \   000000A0   0x....             LDR.N    R1,??DataTable5_23
   \   000000A2   0x7008             STRB     R0,[R1, #+0]
    372                              break;
    373                          }
    374                      }
    375          
    376                      /* If the request was not sent to the broadcast address we
    377                       * return a reply. */
    378                      if( ucRcvAddress != MB_ADDRESS_BROADCAST )
   \                     ??eMBPoll_11:
   \   000000A4   0x....             LDR.N    R0,??DataTable5_21
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD029             BEQ.N    ??eMBPoll_13
    379                      {
    380                          if( eException != MB_EX_NONE )
   \   000000AC   0x....             LDR.N    R0,??DataTable5_23
   \   000000AE   0x7800             LDRB     R0,[R0, #+0]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD01C             BEQ.N    ??eMBPoll_14
    381                          {
    382                              /* An exception occured. Build an error frame. */
    383                              usLength = 0;
   \   000000B4   0x....             LDR.N    R0,??DataTable5_19
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x8001             STRH     R1,[R0, #+0]
    384                              ucMBFrame[usLength++] = ( UCHAR )( ucFunctionCode | MB_FUNC_ERROR );
   \   000000BA   0x....             LDR.N    R0,??DataTable5_19
   \   000000BC   0x8800             LDRH     R0,[R0, #+0]
   \   000000BE   0x....             LDR.N    R1,??DataTable5_20
   \   000000C0   0x6809             LDR      R1,[R1, #+0]
   \   000000C2   0x....             LDR.N    R2,??DataTable5_22
   \   000000C4   0x7812             LDRB     R2,[R2, #+0]
   \   000000C6   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   000000CA   0x5442             STRB     R2,[R0, R1]
   \   000000CC   0x....             LDR.N    R0,??DataTable5_19
   \   000000CE   0x8800             LDRH     R0,[R0, #+0]
   \   000000D0   0x1C40             ADDS     R0,R0,#+1
   \   000000D2   0x....             LDR.N    R1,??DataTable5_19
   \   000000D4   0x8008             STRH     R0,[R1, #+0]
    385                              ucMBFrame[usLength++] = eException;
   \   000000D6   0x....             LDR.N    R0,??DataTable5_19
   \   000000D8   0x8800             LDRH     R0,[R0, #+0]
   \   000000DA   0x....             LDR.N    R1,??DataTable5_20
   \   000000DC   0x6809             LDR      R1,[R1, #+0]
   \   000000DE   0x....             LDR.N    R2,??DataTable5_23
   \   000000E0   0x7812             LDRB     R2,[R2, #+0]
   \   000000E2   0x5442             STRB     R2,[R0, R1]
   \   000000E4   0x....             LDR.N    R0,??DataTable5_19
   \   000000E6   0x8800             LDRH     R0,[R0, #+0]
   \   000000E8   0x1C40             ADDS     R0,R0,#+1
   \   000000EA   0x....             LDR.N    R1,??DataTable5_19
   \   000000EC   0x8008             STRH     R0,[R1, #+0]
    386                          }
    387                          eStatus = peMBFrameSendCur( ucMBAddress, ucMBFrame, usLength );
   \                     ??eMBPoll_14:
   \   000000EE   0x....             LDR.N    R0,??DataTable5_19
   \   000000F0   0x8802             LDRH     R2,[R0, #+0]
   \   000000F2   0x....             LDR.N    R0,??DataTable5_20
   \   000000F4   0x6801             LDR      R1,[R0, #+0]
   \   000000F6   0x....             LDR.N    R0,??DataTable5
   \   000000F8   0x7800             LDRB     R0,[R0, #+0]
   \   000000FA   0x....             LDR.N    R3,??DataTable5_5
   \   000000FC   0x681B             LDR      R3,[R3, #+0]
   \   000000FE   0x4798             BLX      R3
    388                      }
    389                      break;
   \                     ??eMBPoll_13:
   \   00000100   0xE7FF             B.N      ??eMBPoll_2
    390          
    391                  case EV_FRAME_SENT:
    392                      break;
    393                  }
    394              }
    395              return MB_ENOERR;
   \                     ??eMBPoll_6:
   \                     ??eMBPoll_2:
   \   00000102   0x2000             MOVS     R0,#+0
   \                     ??eMBPoll_1:
   \   00000104   0xBD02             POP      {R1,PC}          ;; return
    396          }

   \                                 In section .bss, align 4
   \                     ??ucMBFrame:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \                     ??ucRcvAddress:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??ucFunctionCode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
   \                     ??usLength:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
   \                     ??eException:
   \   00000000                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     ucMBAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     pvMBFrameStartCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     eMBRTUStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     pvMBFrameStopCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     eMBRTUStop

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     peMBFrameSendCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     eMBRTUSend

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     peMBFrameReceiveCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     eMBRTUReceive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     pvMBFrameCloseCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     pxMBFrameCBByteReceived

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     xMBRTUReceiveFSM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     pxMBFrameCBTransmitterEmpty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     xMBRTUTransmitFSM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x........         DC32     pxMBPortCBTimerExpired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     xMBRTUTimerT35Expired

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x........         DC32     eMBCurrentMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x........         DC32     eMBState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x........         DC32     xFuncHandlers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x........         DC32     ??usLength

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x........         DC32     ??ucMBFrame

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x........         DC32     ??ucRcvAddress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0x........         DC32     ??ucFunctionCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \   00000000   0x........         DC32     ??eException

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  eMBClose
              8 -- Indirect call
        8  eMBDisable
              8 -- Indirect call
        8  eMBEnable
              8 -- Indirect call
       16  eMBInit
             16 -> eMBRTUInit
             16 -> xMBPortEventInit
        8  eMBPoll
              8 -- Indirect call
              8 -> xMBPortEventGet
              8 -> xMBPortEventPost
       16  eMBRegisterCB
             16 -> vPortEnterCritical
             16 -> vPortExitCritical


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       1  eException
      36  eMBClose
       1  eMBCurrentMode
      44  eMBDisable
      34  eMBEnable
     130  eMBInit
     262  eMBPoll
     142  eMBRegisterCB
       1  eMBState
       4  peMBFrameReceiveCur
       4  peMBFrameSendCur
       4  pvMBFrameCloseCur
       4  pvMBFrameStartCur
       4  pvMBFrameStopCur
       4  pxMBFrameCBByteReceived
       4  pxMBFrameCBReceiveFSMCur
       4  pxMBFrameCBTransmitFSMCur
       4  pxMBFrameCBTransmitterEmpty
       4  pxMBPortCBTimerExpired
       1  ucFunctionCode
       1  ucMBAddress
       4  ucMBFrame
       1  ucRcvAddress
       2  usLength
     128  xFuncHandlers

 
  51 bytes in section .bss
 129 bytes in section .data
 744 bytes in section .text
 
 744 bytes of CODE memory
 180 bytes of DATA memory

Errors: none
Warnings: 2
