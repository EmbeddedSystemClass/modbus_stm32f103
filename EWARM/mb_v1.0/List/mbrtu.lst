###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  09:12:49 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\FreeModbus\modb #
#                    us\rtu\mbrtu.c                                           #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\FreeModbus\mod #
#                    bus\rtu\mbrtu.c" -D USE_FULL_LL_DRIVER -D                #
#                    USE_HAL_DRIVER -D STM32F103xB -lC "D:\projects\задания   #
#                    от работодателя\ЭМИС\EWARM\mb_v1.0/List\" -o             #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    Obj\" --no_cse --no_unroll --no_inline --no_code_motion  #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\mbrtu.lst                                            #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\mbrtu.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\FreeModbus\modbus\rtu\mbrtu.c
      1          /* 
      2           * FreeModbus Libary: A portable Modbus implementation for Modbus ASCII/RTU.
      3           * Copyright (c) 2006 Christian Walter <wolti@sil.at>
      4           * All rights reserved.
      5           *
      6           * Redistribution and use in source and binary forms, with or without
      7           * modification, are permitted provided that the following conditions
      8           * are met:
      9           * 1. Redistributions of source code must retain the above copyright
     10           *    notice, this list of conditions and the following disclaimer.
     11           * 2. Redistributions in binary form must reproduce the above copyright
     12           *    notice, this list of conditions and the following disclaimer in the
     13           *    documentation and/or other materials provided with the distribution.
     14           * 3. The name of the author may not be used to endorse or promote products
     15           *    derived from this software without specific prior written permission.
     16           *
     17           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
     19           * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     20           * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     22           * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     23           * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     24           * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     25           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
     26           * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           *
     28           * File: $Id: mbrtu.c,v 1.18 2007/09/12 10:15:56 wolti Exp $
     29           */
     30          
     31          /* ----------------------- System includes ----------------------------------*/
     32          #include "stdlib.h"
     33          #include "string.h"
     34          
     35          /* ----------------------- Platform includes --------------------------------*/
     36          
     37          #include "hw_config.h"

  /**
    ^
"D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_adc.h",1  Warning[Pa050]: 
          non-native end of line sequence detected (this diagnostic is only
          issued once)
     38          #include "port.h"
     39          #include "tim.h"
     40          #include "usart.h"
     41          
     42          /* ----------------------- Modbus includes ----------------------------------*/
     43          #include "mb.h"
     44          #include "mbrtu.h"
     45          #include "mbframe.h"
     46          
     47          #include "mbcrc.h"
     48          #include "mbport.h"
     49          
     50          /* ----------------------- Defines ------------------------------------------*/
     51          #define MB_SER_PDU_SIZE_MIN     4       /*!< Minimum size of a Modbus RTU frame. */
     52          #define MB_SER_PDU_SIZE_MAX     256     /*!< Maximum size of a Modbus RTU frame. */
     53          #define MB_SER_PDU_SIZE_CRC     2       /*!< Size of CRC field in PDU. */
     54          #define MB_SER_PDU_ADDR_OFF     0       /*!< Offset of slave address in Ser-PDU. */
     55          #define MB_SER_PDU_PDU_OFF      1       /*!< Offset of Modbus-PDU in Ser-PDU. */
     56          
     57          /* ----------------------- Type definitions ---------------------------------*/
     58          typedef enum
     59          {
     60              STATE_RX_INIT,              /*!< Receiver is in initial state. */
     61              STATE_RX_IDLE,              /*!< Receiver is in idle state. */
     62              STATE_RX_RCV,               /*!< Frame is beeing received. */
     63              STATE_RX_ERROR              /*!< If the frame is invalid. */
     64          } eMBRcvState;
     65          
     66          typedef enum
     67          {
     68              STATE_TX_IDLE,              /*!< Transmitter is in idle state. */
     69              STATE_TX_XMIT               /*!< Transmitter is in transfer state. */
     70          } eMBSndState;
     71          
     72          /* ----------------------- Static variables ---------------------------------*/

   \                                 In section .bss, align 1
     73          static volatile eMBSndState eSndState;
   \                     eSndState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     74          static volatile eMBRcvState eRcvState;
   \                     eRcvState:
   \   00000000                      DS8 1
     75          

   \                                 In section .bss, align 4
     76          volatile UCHAR  ucRTUBuf[MB_SER_PDU_SIZE_MAX];
   \                     ucRTUBuf:
   \   00000000                      DS8 256
     77          

   \                                 In section .bss, align 4
     78          static volatile UCHAR *pucSndBufferCur;
   \                     pucSndBufferCur:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
     79          static volatile USHORT usSndBufferCount;
   \                     usSndBufferCount:
   \   00000000                      DS8 2
     80          

   \                                 In section .bss, align 2
     81          static volatile USHORT usRcvBufferPos;
   \                     usRcvBufferPos:
   \   00000000                      DS8 2
     82          
     83          /* ----------------------- Start implementation -----------------------------*/

   \                                 In section .text, align 2, keep-with-next
     84          eMBErrorCode
     85          eMBRTUInit( UCHAR ucSlaveAddress)
     86          {
   \                     eMBRTUInit:
   \   00000000   0xB510             PUSH     {R4,LR}
     87              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000002   0x2400             MOVS     R4,#+0
     88              ULONG           usTimerT35;
     89          
     90              ( void )ucSlaveAddress;
     91              ENTER_CRITICAL_SECTION();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
     92          
     93                  /* If baudrate > 19200 then we should use the fixed timer values
     94                   * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
     95                   */
     96                  if( mbBaudRate > 19200 )
     97                  {
     98                      usTimerT35 = 1000;       /* 1750us. */
   \   00000008   0xF44F 0x707A      MOV      R0,#+1000
     99                  }
    100                  else
    101                  {
    102                      /* The timer reload value for a character is given by:
    103                       *
    104                       *  usTimerT35 = (1/((Baudrate/11))*3,5)*(SystemCoreClock/TimerPrescaler)
    105                       *             = (SystemCoreClock/TimerPrescaler)/(Baudrate/38.5)
    106                       * The reload for t3.5 is 1.5 times this value and similary
    107                       * for t3.5.
    108                       */
    109                      usTimerT35 = ( 1000000 ) / ( mbBaudRate / 38.5 );
                                          ^
Warning[Pa092]: implicit conversion to integer does not preserve the value
    110                  }
    111                  if( mbTimerReInit( ( USHORT ) usTimerT35 ) != TRUE )
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0x.... 0x....      BL       mbTimerReInit
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD000             BEQ.N    ??eMBRTUInit_0
    112                  {
    113                      eStatus = MB_EPORTERR;
   \   00000016   0x2403             MOVS     R4,#+3
    114                  }
    115              EXIT_CRITICAL_SECTION(  );
   \                     ??eMBRTUInit_0:
   \   00000018   0x.... 0x....      BL       vPortExitCritical
    116          
    117              return eStatus;
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    118          }
    119          

   \                                 In section .text, align 2, keep-with-next
    120          void
    121          eMBRTUStart( void )
    122          {
   \                     eMBRTUStart:
   \   00000000   0xB580             PUSH     {R7,LR}
    123          //    ENTER_CRITICAL_SECTION(  );
    124              /* Initially the receiver is in the state STATE_RX_INIT. we start
    125               * the timer and if no character is received within t3.5 we change
    126               * to STATE_RX_IDLE. This makes sure that we delay startup of the
    127               * modbus protocol stack until the bus is free.
    128               */
    129              eRcvState = STATE_RX_INIT;
   \   00000002   0x....             LDR.N    R0,??DataTable5
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    130              vMBPortSerialEnable( TRUE, FALSE );
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       vMBPortSerialEnable
    131              vMBPortTimersEnable(  );
   \   00000010   0x.... 0x....      BL       vMBPortTimersEnable
    132          
    133          //    EXIT_CRITICAL_SECTION(  );
    134          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    135          

   \                                 In section .text, align 2, keep-with-next
    136          void
    137          eMBRTUStop( void )
    138          {
   \                     eMBRTUStop:
   \   00000000   0xB580             PUSH     {R7,LR}
    139              ENTER_CRITICAL_SECTION(  );
   \   00000002   0x.... 0x....      BL       vPortEnterCritical
    140              vMBPortSerialEnable( FALSE, FALSE );
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       vMBPortSerialEnable
    141              vMBPortTimersDisable(  );
   \   0000000E   0x.... 0x....      BL       vMBPortTimersDisable
    142              EXIT_CRITICAL_SECTION(  );
   \   00000012   0x.... 0x....      BL       vPortExitCritical
    143          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    144          

   \                                 In section .text, align 2, keep-with-next
    145          eMBErrorCode
    146          eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
    147          {
   \                     eMBRTUReceive:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    148              BOOL            xFrameReceived = FALSE;
                                     ^
Warning[Pe550]: variable "xFrameReceived" was set but never used
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    149              eMBErrorCode    eStatus = MB_ENOERR;
   \   0000000E   0x2600             MOVS     R6,#+0
    150          
    151              ENTER_CRITICAL_SECTION(  );
   \   00000010   0x.... 0x....      BL       vPortEnterCritical
    152              assert_param( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );
    153          
    154              /* Length and CRC check */
    155              if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
    156                  && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
   \   00000014   0x....             LDR.N    R0,??DataTable5_1
   \   00000016   0x8800             LDRH     R0,[R0, #+0]
   \   00000018   0x2804             CMP      R0,#+4
   \   0000001A   0xD312             BCC.N    ??eMBRTUReceive_0
   \   0000001C   0x....             LDR.N    R0,??DataTable5_1
   \   0000001E   0x8801             LDRH     R1,[R0, #+0]
   \   00000020   0x....             LDR.N    R0,??DataTable5_2
   \   00000022   0x.... 0x....      BL       usMBCRC16
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD10B             BNE.N    ??eMBRTUReceive_0
    157              {
    158                  /* Save the address field. All frames are passed to the upper layed
    159                   * and the decision if a frame is used is done there.
    160                   */
    161                  *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
   \   0000002A   0x....             LDR.N    R0,??DataTable5_2
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x7038             STRB     R0,[R7, #+0]
    162          
    163                  /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
    164                   * size of address field and CRC checksum.
    165                   */
    166                  *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
   \   00000030   0x....             LDR.N    R0,??DataTable5_1
   \   00000032   0x8800             LDRH     R0,[R0, #+0]
   \   00000034   0x1EC0             SUBS     R0,R0,#+3
   \   00000036   0x8028             STRH     R0,[R5, #+0]
    167          
    168                  /* Return the start of the Modbus PDU to the caller. */
    169                  *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
   \   00000038   0x....             LDR.N    R0,??DataTable5_3
   \   0000003A   0x6020             STR      R0,[R4, #+0]
    170                  xFrameReceived = TRUE;
   \   0000003C   0xF05F 0x0801      MOVS     R8,#+1
   \   00000040   0xE000             B.N      ??eMBRTUReceive_1
    171              }
    172              else
    173              {
    174                  eStatus = MB_EIO;
   \                     ??eMBRTUReceive_0:
   \   00000042   0x2605             MOVS     R6,#+5
    175              }
    176          
    177              EXIT_CRITICAL_SECTION(  );
   \                     ??eMBRTUReceive_1:
   \   00000044   0x.... 0x....      BL       vPortExitCritical
    178              return eStatus;
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    179          }
    180          

   \                                 In section .text, align 2, keep-with-next
    181          eMBErrorCode
    182          eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
    183          {
   \                     eMBRTUSend:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
    184              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000008   0x2400             MOVS     R4,#+0
    185              USHORT          usCRC16;
    186          
    187              ENTER_CRITICAL_SECTION(  );
   \   0000000A   0x.... 0x....      BL       vPortEnterCritical
    188          
    189              /* Check if the receiver is still in idle state. If not we where to
    190               * slow with processing the received frame and the master sent another
    191               * frame on the network. We have to abort sending the frame.
    192               */
    193              if( eRcvState == STATE_RX_IDLE )
   \   0000000E   0x....             LDR.N    R0,??DataTable5
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD131             BNE.N    ??eMBRTUSend_0
    194              {
    195                  /* First byte before the Modbus-PDU is the slave address. */
    196                  pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
   \   00000016   0x1E78             SUBS     R0,R7,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable5_4
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    197                  usSndBufferCount = 1;
   \   0000001C   0x....             LDR.N    R0,??DataTable5_5
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x8001             STRH     R1,[R0, #+0]
    198          
    199                  /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
    200                  pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
   \   00000022   0x....             LDR.N    R0,??DataTable5_4
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x7005             STRB     R5,[R0, #+0]
    201                  usSndBufferCount += usLength;
   \   00000028   0x....             LDR.N    R0,??DataTable5_5
   \   0000002A   0x8800             LDRH     R0,[R0, #+0]
   \   0000002C   0x1830             ADDS     R0,R6,R0
   \   0000002E   0x....             LDR.N    R1,??DataTable5_5
   \   00000030   0x8008             STRH     R0,[R1, #+0]
    202          
    203                  /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
    204                  usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
   \   00000032   0x....             LDR.N    R0,??DataTable5_5
   \   00000034   0x8801             LDRH     R1,[R0, #+0]
   \   00000036   0x....             LDR.N    R0,??DataTable5_4
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       usMBCRC16
    205                  ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
   \   0000003E   0x....             LDR.N    R1,??DataTable5_5
   \   00000040   0x8809             LDRH     R1,[R1, #+0]
   \   00000042   0x1C4A             ADDS     R2,R1,#+1
   \   00000044   0x....             LDR.N    R3,??DataTable5_5
   \   00000046   0x801A             STRH     R2,[R3, #+0]
   \   00000048   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004A   0x....             LDR.N    R2,??DataTable5_2
   \   0000004C   0x5488             STRB     R0,[R1, R2]
    206                  ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
   \   0000004E   0x....             LDR.N    R1,??DataTable5_5
   \   00000050   0x8809             LDRH     R1,[R1, #+0]
   \   00000052   0x1C4A             ADDS     R2,R1,#+1
   \   00000054   0x....             LDR.N    R3,??DataTable5_5
   \   00000056   0x801A             STRH     R2,[R3, #+0]
   \   00000058   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005A   0x....             LDR.N    R2,??DataTable5_2
   \   0000005C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005E   0x0A00             LSRS     R0,R0,#+8
   \   00000060   0x5488             STRB     R0,[R1, R2]
    207          
    208                  EXIT_CRITICAL_SECTION(  );
   \   00000062   0x.... 0x....      BL       vPortExitCritical
    209                  /* Activate the transmitter. */
    210                  eSndState = STATE_TX_XMIT;
   \   00000066   0x....             LDR.N    R0,??DataTable5_6
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
    211                  vMBPortSerialEnable( FALSE, TRUE );
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      BL       vMBPortSerialEnable
    212                  xMBRTUTransmitFSM();
   \   00000074   0x.... 0x....      BL       xMBRTUTransmitFSM
   \   00000078   0xE000             B.N      ??eMBRTUSend_1
    213              }
    214              else
    215              {
    216                  eStatus = MB_EIO;
   \                     ??eMBRTUSend_0:
   \   0000007A   0x2405             MOVS     R4,#+5
    217              }
    218              return eStatus;
   \                     ??eMBRTUSend_1:
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    219          }
    220          

   \                                 In section .text, align 2, keep-with-next
    221          BOOL
    222          xMBRTUReceiveFSM( void )
    223          {
   \                     xMBRTUReceiveFSM:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    224              BOOL            xTaskNeedSwitch = FALSE;
   \   00000004   0x2400             MOVS     R4,#+0
    225              UCHAR           ucByte;
    226          
    227              assert_param( eSndState == STATE_TX_IDLE );
    228          
    229              /* Always read the character. */
    230              ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      BL       xMBPortSerialGetByte
    231          
    232              switch ( eRcvState )
   \   0000000C   0x....             LDR.N    R1,??DataTable5
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD005             BEQ.N    ??xMBRTUReceiveFSM_0
   \   00000014   0x2902             CMP      R1,#+2
   \   00000016   0xD01C             BEQ.N    ??xMBRTUReceiveFSM_1
   \   00000018   0xD308             BCC.N    ??xMBRTUReceiveFSM_2
   \   0000001A   0x2903             CMP      R1,#+3
   \   0000001C   0xD003             BEQ.N    ??xMBRTUReceiveFSM_3
   \   0000001E   0xE02E             B.N      ??xMBRTUReceiveFSM_4
    233              {
    234                  /* If we have received a character in the init state we have to
    235                   * wait until the frame is finished.
    236                   */
    237              case STATE_RX_INIT:
    238                  vMBPortTimersEnable( );
   \                     ??xMBRTUReceiveFSM_0:
   \   00000020   0x.... 0x....      BL       vMBPortTimersEnable
    239                  break;
   \   00000024   0xE02B             B.N      ??xMBRTUReceiveFSM_4
    240          
    241                  /* In the error state we wait until all characters in the
    242                   * damaged frame are transmitted.
    243                   */
    244              case STATE_RX_ERROR:
    245                  vMBPortTimersEnable( );
   \                     ??xMBRTUReceiveFSM_3:
   \   00000026   0x.... 0x....      BL       vMBPortTimersEnable
    246                  break;
   \   0000002A   0xE028             B.N      ??xMBRTUReceiveFSM_4
    247          
    248                  /* In the idle state we wait for a new character. If a character
    249                   * is received the t1.5 and t3.5 timers are started and the
    250                   * receiver is in the state STATE_RX_RECEIVCE.
    251                   */
    252              case STATE_RX_IDLE:
    253                  usRcvBufferPos = 0;
   \                     ??xMBRTUReceiveFSM_2:
   \   0000002C   0x....             LDR.N    R0,??DataTable5_1
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x8001             STRH     R1,[R0, #+0]
    254                  ucRTUBuf[usRcvBufferPos++] = ucByte;
   \   00000032   0x....             LDR.N    R0,??DataTable5_1
   \   00000034   0x8800             LDRH     R0,[R0, #+0]
   \   00000036   0x1C41             ADDS     R1,R0,#+1
   \   00000038   0x....             LDR.N    R2,??DataTable5_1
   \   0000003A   0x8011             STRH     R1,[R2, #+0]
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x....             LDR.N    R1,??DataTable5_2
   \   00000040   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000044   0x5442             STRB     R2,[R0, R1]
    255                  eRcvState = STATE_RX_RCV;
   \   00000046   0x....             LDR.N    R0,??DataTable5
   \   00000048   0x2102             MOVS     R1,#+2
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
    256          
    257                  /* Enable t3.5 timers. */
    258                  vMBPortTimersEnable( );
   \   0000004C   0x.... 0x....      BL       vMBPortTimersEnable
    259                  break;
   \   00000050   0xE015             B.N      ??xMBRTUReceiveFSM_4
    260          
    261                  /* We are currently receiving a frame. Reset the timer after
    262                   * every character received. If more than the maximum possible
    263                   * number of bytes in a modbus frame is received the frame is
    264                   * ignored.
    265                   */
    266              case STATE_RX_RCV:
    267                  if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
   \                     ??xMBRTUReceiveFSM_1:
   \   00000052   0x....             LDR.N    R0,??DataTable5_1
   \   00000054   0x8800             LDRH     R0,[R0, #+0]
   \   00000056   0xF44F 0x7180      MOV      R1,#+256
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD20A             BCS.N    ??xMBRTUReceiveFSM_5
    268                  {
    269                      ucRTUBuf[usRcvBufferPos++] = ucByte;
   \   0000005E   0x....             LDR.N    R0,??DataTable5_1
   \   00000060   0x8800             LDRH     R0,[R0, #+0]
   \   00000062   0x1C41             ADDS     R1,R0,#+1
   \   00000064   0x....             LDR.N    R2,??DataTable5_1
   \   00000066   0x8011             STRH     R1,[R2, #+0]
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0x....             LDR.N    R1,??DataTable5_2
   \   0000006C   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000070   0x5442             STRB     R2,[R0, R1]
   \   00000072   0xE002             B.N      ??xMBRTUReceiveFSM_6
    270                  }
    271                  else
    272                  {
    273                      eRcvState = STATE_RX_ERROR;
   \                     ??xMBRTUReceiveFSM_5:
   \   00000074   0x....             LDR.N    R0,??DataTable5
   \   00000076   0x2103             MOVS     R1,#+3
   \   00000078   0x7001             STRB     R1,[R0, #+0]
    274                  }
    275                  vMBPortTimersEnable();
   \                     ??xMBRTUReceiveFSM_6:
   \   0000007A   0x.... 0x....      BL       vMBPortTimersEnable
    276                  break;
    277              }
    278              return xTaskNeedSwitch;
   \                     ??xMBRTUReceiveFSM_4:
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    279          }
    280          

   \                                 In section .text, align 2, keep-with-next
    281          BOOL
    282          xMBRTUTransmitFSM( void )
    283          {
   \                     xMBRTUTransmitFSM:
   \   00000000   0xB510             PUSH     {R4,LR}
    284              BOOL            xNeedPoll = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    285          
    286              assert_param( eRcvState == STATE_RX_IDLE );
    287          
    288              switch ( eSndState )
   \   00000004   0x....             LDR.N    R0,??DataTable5_6
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??xMBRTUTransmitFSM_0
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD005             BEQ.N    ??xMBRTUTransmitFSM_1
   \   00000010   0xE019             B.N      ??xMBRTUTransmitFSM_2
    289              {
    290                  /* We should not get a transmitter event if the transmitter is in
    291                   * idle state.  */
    292              case STATE_TX_IDLE:
    293                  /* enable receiver/disable transmitter. */
    294                  vMBPortSerialEnable( TRUE, FALSE );
   \                     ??xMBRTUTransmitFSM_0:
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       vMBPortSerialEnable
    295                  break;
   \   0000001A   0xE014             B.N      ??xMBRTUTransmitFSM_2
    296          
    297              case STATE_TX_XMIT:
    298                  /* check if we are finished. */
    299                  if( usSndBufferCount != 0 )
   \                     ??xMBRTUTransmitFSM_1:
   \   0000001C   0x....             LDR.N    R0,??DataTable5_5
   \   0000001E   0x8800             LDRH     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD005             BEQ.N    ??xMBRTUTransmitFSM_3
    300                  {
    301                     // xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
    302                     // pucSndBufferCur++;  /* next byte in sendbuffer. */
    303                     // usSndBufferCount--;
    304                    UARTSendMess(( char *)pucSndBufferCur, usSndBufferCount);           
   \   00000024   0x....             LDR.N    R0,??DataTable5_5
   \   00000026   0x8801             LDRH     R1,[R0, #+0]
   \   00000028   0x....             LDR.N    R0,??DataTable5_4
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x.... 0x....      BL       UARTSendMess
    305                  }
    306                  xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
   \                     ??xMBRTUTransmitFSM_3:
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x.... 0x....      BL       xMBPortEventPost
   \   00000036   0x0004             MOVS     R4,R0
    307                  /* Disable transmitter. This prevents another transmit buffer
    308                       * empty interrupt. */
    309                  vMBPortSerialEnable( TRUE, FALSE );
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       vMBPortSerialEnable
    310                  eSndState = STATE_TX_IDLE;
   \   00000040   0x....             LDR.N    R0,??DataTable5_6
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x7001             STRB     R1,[R0, #+0]
    311               break;
    312              }
    313          
    314              return xNeedPoll;
   \                     ??xMBRTUTransmitFSM_2:
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    315          }
    316          

   \                                 In section .text, align 2, keep-with-next
    317          BOOL
    318          xMBRTUTimerT35Expired( void )
    319          {
   \                     xMBRTUTimerT35Expired:
   \   00000000   0xB510             PUSH     {R4,LR}
    320              BOOL            xNeedPoll = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    321          
    322              switch ( eRcvState )
   \   00000004   0x....             LDR.N    R0,??DataTable5
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??xMBRTUTimerT35Expired_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD007             BEQ.N    ??xMBRTUTimerT35Expired_1
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD00A             BEQ.N    ??xMBRTUTimerT35Expired_2
   \   00000014   0xE00A             B.N      ??xMBRTUTimerT35Expired_3
    323              {
    324                  /* Timer t35 expired. Startup phase is finished. */
    325              case STATE_RX_INIT:
    326                  xNeedPoll = xMBPortEventPost( EV_READY );
   \                     ??xMBRTUTimerT35Expired_0:
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       xMBPortEventPost
   \   0000001C   0x0004             MOVS     R4,R0
    327                  break;
   \   0000001E   0xE005             B.N      ??xMBRTUTimerT35Expired_4
    328          
    329                  /* A frame was received and t35 expired. Notify the listener that
    330                   * a new frame was received. */
    331              case STATE_RX_RCV:
    332                  xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
   \                     ??xMBRTUTimerT35Expired_1:
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       xMBPortEventPost
   \   00000026   0x0004             MOVS     R4,R0
    333                  break;
   \   00000028   0xE000             B.N      ??xMBRTUTimerT35Expired_4
    334          
    335                  /* An error occured while receiving the frame. */
    336              case STATE_RX_ERROR:
    337                  break;
   \                     ??xMBRTUTimerT35Expired_2:
   \   0000002A   0xE7FF             B.N      ??xMBRTUTimerT35Expired_4
    338          
    339                  /* Function called in an illegal state. */
    340              default:
    341                  assert_param( ( eRcvState == STATE_RX_INIT ) ||
    342                          ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
    343              }
    344          
    345              vMBPortTimersDisable(  );
   \                     ??xMBRTUTimerT35Expired_3:
   \                     ??xMBRTUTimerT35Expired_4:
   \   0000002C   0x.... 0x....      BL       vMBPortTimersDisable
    346              eRcvState = STATE_RX_IDLE;
   \   00000030   0x....             LDR.N    R0,??DataTable5
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x7001             STRB     R1,[R0, #+0]
    347          
    348              return xNeedPoll;
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    349          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     eRcvState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     usRcvBufferPos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     ucRTUBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     ucRTUBuf+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     pucSndBufferCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     usSndBufferCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     eSndState

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  eMBRTUInit
              8 -> mbTimerReInit
              8 -> vPortEnterCritical
              8 -> vPortExitCritical
       24  eMBRTUReceive
             24 -> usMBCRC16
             24 -> vPortEnterCritical
             24 -> vPortExitCritical
       24  eMBRTUSend
             24 -> usMBCRC16
             24 -> vMBPortSerialEnable
             24 -> vPortEnterCritical
             24 -> vPortExitCritical
             24 -> xMBRTUTransmitFSM
        8  eMBRTUStart
              8 -> vMBPortSerialEnable
              8 -> vMBPortTimersEnable
        8  eMBRTUStop
              8 -> vMBPortSerialEnable
              8 -> vMBPortTimersDisable
              8 -> vPortEnterCritical
              8 -> vPortExitCritical
       16  xMBRTUReceiveFSM
             16 -> vMBPortTimersEnable
             16 -> xMBPortSerialGetByte
        8  xMBRTUTimerT35Expired
              8 -> vMBPortTimersDisable
              8 -> xMBPortEventPost
        8  xMBRTUTransmitFSM
              8 -> UARTSendMess
              8 -> vMBPortSerialEnable
              8 -> xMBPortEventPost


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
      34  eMBRTUInit
      80  eMBRTUReceive
     130  eMBRTUSend
      22  eMBRTUStart
      24  eMBRTUStop
       1  eRcvState
       1  eSndState
       4  pucSndBufferCur
     256  ucRTUBuf
       2  usRcvBufferPos
       2  usSndBufferCount
     132  xMBRTUReceiveFSM
      60  xMBRTUTimerT35Expired
      76  xMBRTUTransmitFSM

 
 266 bytes in section .bss
 586 bytes in section .text
 
 586 bytes of CODE memory
 266 bytes of DATA memory

Errors: none
Warnings: 3
