###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  09:49:57 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Src\stm32f1xx_i #
#                    t.c                                                      #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Src\stm32f1xx_ #
#                    it.c" -D USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D         #
#                    STM32F103xB -lC "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/List\" -o                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    Obj\" --no_cse --no_unroll --no_inline --no_code_motion  #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\stm32f1xx_it.lst                                     #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\stm32f1xx_it.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Src\stm32f1xx_it.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_it.c
      4            * @brief   Interrupt Service Routines.
      5            ******************************************************************************
      6            *
      7            * COPYRIGHT(c) 2018 STMicroelectronics
      8            *
      9            * Redistribution and use in source and binary forms, with or without modification,
     10            * are permitted provided that the following conditions are met:
     11            *   1. Redistributions of source code must retain the above copyright notice,
     12            *      this list of conditions and the following disclaimer.
     13            *   2. Redistributions in binary form must reproduce the above copyright notice,
     14            *      this list of conditions and the following disclaimer in the documentation
     15            *      and/or other materials provided with the distribution.
     16            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     17            *      may be used to endorse or promote products derived from this software
     18            *      without specific prior written permission.
     19            *
     20            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     21            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     22            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     23            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     24            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     25            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     26            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     27            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     28            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     29            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     30            *
     31            ******************************************************************************
     32            */
     33          /* Includes ------------------------------------------------------------------*/
     34          #include "stm32f1xx_hal.h"

  /**
    ^
"D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal.h",1  Warning[Pa050]: 
          non-native end of line sequence detected (this diagnostic is only
          issued once)

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint16_t LL_ADC_REG_ReadConversionData12(ADC_TypeDef *)
   \                     LL_ADC_REG_ReadConversionData12:
   \   00000000   0x6CC0             LDR      R0,[R0, #+76]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_ClearFlag_UPDATE(TIM_TypeDef *)
   \                     LL_TIM_ClearFlag_UPDATE:
   \   00000000   0xF07F 0x0101      MVNS     R1,#+1
   \   00000004   0x6101             STR      R1,[R0, #+16]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t LL_USART_IsActiveFlag_RXNE(USART_TypeDef *)
   \                     LL_USART_IsActiveFlag_RXNE:
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t LL_USART_IsActiveFlag_TC(USART_TypeDef *)
   \                     LL_USART_IsActiveFlag_TC:
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_USART_ClearFlag_TC(USART_TypeDef *)
   \                     LL_USART_ClearFlag_TC:
   \   00000000   0xF07F 0x0140      MVNS     R1,#+64
   \   00000004   0x6001             STR      R1,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_USART_ClearFlag_RXNE(USART_TypeDef *)
   \                     LL_USART_ClearFlag_RXNE:
   \   00000000   0xF07F 0x0120      MVNS     R1,#+32
   \   00000004   0x6001             STR      R1,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
     35          #include "stm32f1xx.h"
     36          #include "stm32f1xx_it.h"
     37          #include "cmsis_os.h"
     38          
     39          /* USER CODE BEGIN 0 */
     40          
     41          #include "hw_config.h"
     42          #include "mb.h"
     43          #include "UserModbusSlaver.h"
     44          
     45          
     46          extern osSemaphoreId MbTimSemHandle;
     47          extern osSemaphoreId MbTXSemHandle;
     48          extern USHORT   usRegHoldingBuf[REG_HOLDING_NREGS];
     49          extern union FloatChar FlCh;
     50          /* USER CODE END 0 */
     51          
     52          /* External variables --------------------------------------------------------*/
     53          
     54          extern TIM_HandleTypeDef htim2;
     55          
     56          /******************************************************************************/
     57          /*            Cortex-M3 Processor Interruption and Exception Handlers         */ 
     58          /******************************************************************************/
     59          
     60          /**
     61          * @brief This function handles Non maskable interrupt.
     62          */

   \                                 In section .text, align 2, keep-with-next
     63          void NMI_Handler(void)
     64          {
     65            /* USER CODE BEGIN NonMaskableInt_IRQn 0 */
     66          
     67            /* USER CODE END NonMaskableInt_IRQn 0 */
     68            /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
     69          
     70            /* USER CODE END NonMaskableInt_IRQn 1 */
     71          }
   \                     NMI_Handler:
   \   00000000   0x4770             BX       LR               ;; return
     72          
     73          /**
     74          * @brief This function handles Hard fault interrupt.
     75          */

   \                                 In section .text, align 2, keep-with-next
     76          void HardFault_Handler(void)
     77          {
     78            /* USER CODE BEGIN HardFault_IRQn 0 */
     79          
     80            /* USER CODE END HardFault_IRQn 0 */
     81            while (1)
   \                     HardFault_Handler:
   \                     ??HardFault_Handler_0:
   \   00000000   0xE7FE             B.N      ??HardFault_Handler_0
     82            {
     83              /* USER CODE BEGIN W1_HardFault_IRQn 0 */
     84              /* USER CODE END W1_HardFault_IRQn 0 */
     85            }
     86            /* USER CODE BEGIN HardFault_IRQn 1 */
     87          
     88            /* USER CODE END HardFault_IRQn 1 */
     89          }
     90          
     91          /**
     92          * @brief This function handles Memory management fault.
     93          */

   \                                 In section .text, align 2, keep-with-next
     94          void MemManage_Handler(void)
     95          {
     96            /* USER CODE BEGIN MemoryManagement_IRQn 0 */
     97          
     98            /* USER CODE END MemoryManagement_IRQn 0 */
     99            while (1)
   \                     MemManage_Handler:
   \                     ??MemManage_Handler_0:
   \   00000000   0xE7FE             B.N      ??MemManage_Handler_0
    100            {
    101              /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
    102              /* USER CODE END W1_MemoryManagement_IRQn 0 */
    103            }
    104            /* USER CODE BEGIN MemoryManagement_IRQn 1 */
    105          
    106            /* USER CODE END MemoryManagement_IRQn 1 */
    107          }
    108          
    109          /**
    110          * @brief This function handles Prefetch fault, memory access fault.
    111          */

   \                                 In section .text, align 2, keep-with-next
    112          void BusFault_Handler(void)
    113          {
    114            /* USER CODE BEGIN BusFault_IRQn 0 */
    115          
    116            /* USER CODE END BusFault_IRQn 0 */
    117            while (1)
   \                     BusFault_Handler:
   \                     ??BusFault_Handler_0:
   \   00000000   0xE7FE             B.N      ??BusFault_Handler_0
    118            {
    119              /* USER CODE BEGIN W1_BusFault_IRQn 0 */
    120              /* USER CODE END W1_BusFault_IRQn 0 */
    121            }
    122            /* USER CODE BEGIN BusFault_IRQn 1 */
    123          
    124            /* USER CODE END BusFault_IRQn 1 */
    125          }
    126          
    127          /**
    128          * @brief This function handles Undefined instruction or illegal state.
    129          */

   \                                 In section .text, align 2, keep-with-next
    130          void UsageFault_Handler(void)
    131          {
    132            /* USER CODE BEGIN UsageFault_IRQn 0 */
    133          
    134            /* USER CODE END UsageFault_IRQn 0 */
    135            while (1)
   \                     UsageFault_Handler:
   \                     ??UsageFault_Handler_0:
   \   00000000   0xE7FE             B.N      ??UsageFault_Handler_0
    136            {
    137              /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
    138              /* USER CODE END W1_UsageFault_IRQn 0 */
    139            }
    140            /* USER CODE BEGIN UsageFault_IRQn 1 */
    141          
    142            /* USER CODE END UsageFault_IRQn 1 */
    143          }
    144          
    145          /**
    146          * @brief This function handles Debug monitor.
    147          */

   \                                 In section .text, align 2, keep-with-next
    148          void DebugMon_Handler(void)
    149          {
    150            /* USER CODE BEGIN DebugMonitor_IRQn 0 */
    151          
    152            /* USER CODE END DebugMonitor_IRQn 0 */
    153            /* USER CODE BEGIN DebugMonitor_IRQn 1 */
    154          
    155            /* USER CODE END DebugMonitor_IRQn 1 */
    156          }
   \                     DebugMon_Handler:
   \   00000000   0x4770             BX       LR               ;; return
    157          
    158          /**
    159          * @brief This function handles System tick timer.
    160          */

   \                                 In section .text, align 2, keep-with-next
    161          void SysTick_Handler(void)
    162          {
   \                     SysTick_Handler:
   \   00000000   0xB580             PUSH     {R7,LR}
    163            /* USER CODE BEGIN SysTick_IRQn 0 */
    164          
    165            /* USER CODE END SysTick_IRQn 0 */
    166            osSystickHandler();
   \   00000002   0x.... 0x....      BL       osSystickHandler
    167            /* USER CODE BEGIN SysTick_IRQn 1 */
    168          
    169            /* USER CODE END SysTick_IRQn 1 */
    170          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    171          
    172          /******************************************************************************/
    173          /* STM32F1xx Peripheral Interrupt Handlers                                    */
    174          /* Add here the Interrupt Handlers for the used peripherals.                  */
    175          /* For the available peripheral interrupt handler names,                      */
    176          /* please refer to the startup file (startup_stm32f1xx.s).                    */
    177          /******************************************************************************/
    178          
    179          /**
    180          * @brief This function handles ADC1 and ADC2 global interrupts.
    181          */

   \                                 In section .text, align 2, keep-with-next
    182          void ADC1_2_IRQHandler(void)
    183          {
   \                     ADC1_2_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    184            /* USER CODE BEGIN ADC1_2_IRQn 0 */
    185          
    186          FlCh.fl = LL_ADC_REG_ReadConversionData12(usedADC) * 0.0008;
   \   00000002   0x....             LDR.N    R0,??DataTable3  ;; 0x40012400
   \   00000004   0x.... 0x....      BL       LL_ADC_REG_ReadConversionData12
   \   00000008   0x.... 0x....      BL       __aeabi_ui2d
   \   0000000C   0x....             LDR.N    R2,??DataTable3_1  ;; 0xeb1c432d
   \   0000000E   0x....             LDR.N    R3,??DataTable3_2  ;; 0x3f4a36e2
   \   00000010   0x.... 0x....      BL       __aeabi_dmul
   \   00000014   0x.... 0x....      BL       __aeabi_d2f
   \   00000018   0x....             LDR.N    R1,??DataTable3_3
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    187          
    188          #ifdef DEBUG    
    189             HAL_GPIO_TogglePin(TEST_GPIO_Port, TEST_Pin);
   \   0000001C   0xF248 0x0180      MOVW     R1,#+32896
   \   00000020   0x....             LDR.N    R0,??DataTable3_4  ;; 0x40010c00
   \   00000022   0x.... 0x....      BL       HAL_GPIO_TogglePin
    190          #endif
    191            /* USER CODE END ADC1_2_IRQn 0 */
    192            
    193            /* USER CODE BEGIN ADC1_2_IRQn 1 */
    194          
    195            /* USER CODE END ADC1_2_IRQn 1 */
    196          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    197          
    198          /**
    199          * @brief This function handles TIM1 update interrupt.
    200          */

   \                                 In section .text, align 2, keep-with-next
    201          void TIM1_UP_IRQHandler(void)
    202          {
   \                     TIM1_UP_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    203            /* USER CODE BEGIN TIM1_UP_IRQn 0 */
    204           portBASE_TYPE xTaskWokenBy = pdFALSE;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    205           
    206            LL_TIM_ClearFlag_UPDATE(TIM1);
   \   00000006   0x....             LDR.N    R0,??DataTable3_5  ;; 0x40012c00
   \   00000008   0x.... 0x....      BL       LL_TIM_ClearFlag_UPDATE
    207            xSemaphoreGiveFromISR( MbTimSemHandle, &xTaskWokenBy );
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x....             LDR.N    R0,??DataTable3_6
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       xQueueGiveFromISR
    208            portEND_SWITCHING_ISR( xTaskWokenBy );///> activating sheduller to give semaphore right now
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD007             BEQ.N    ??TIM1_UP_IRQHandler_0
   \   0000001C   0x....             LDR.N    R0,??DataTable3_7  ;; 0xe000ed04
   \   0000001E   0xF05F 0x5180      MOVS     R1,#+268435456
   \   00000022   0x6001             STR      R1,[R0, #+0]
   \   00000024   0xF3BF 0x8F4F      DSB      
   \   00000028   0xF3BF 0x8F6F      ISB      
    209            /* USER CODE END TIM1_UP_IRQn 0 */
    210            /* USER CODE BEGIN TIM1_UP_IRQn 1 */
    211          
    212            /* USER CODE END TIM1_UP_IRQn 1 */
    213          }
   \                     ??TIM1_UP_IRQHandler_0:
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
    214          
    215          /**
    216          * @brief This function handles TIM2 global interrupt.
    217          */

   \                                 In section .text, align 2, keep-with-next
    218          void TIM2_IRQHandler(void)
    219          {
   \                     TIM2_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    220            /* USER CODE BEGIN TIM2_IRQn 0 */
    221          
    222            /* USER CODE END TIM2_IRQn 0 */
    223            HAL_TIM_IRQHandler(&htim2);
   \   00000002   0x....             LDR.N    R0,??DataTable3_8
   \   00000004   0x.... 0x....      BL       HAL_TIM_IRQHandler
    224            /* USER CODE BEGIN TIM2_IRQn 1 */
    225          
    226            /* USER CODE END TIM2_IRQn 1 */
    227          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    228          
    229          /**
    230          * @brief This function handles USART1 global interrupt.
    231          */

   \                                 In section .text, align 2, keep-with-next
    232          void USART1_IRQHandler(void)
    233          {
   \                     USART1_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    234            /* USER CODE BEGIN USART1_IRQn 0 */
    235          portBASE_TYPE xTaskWokenBy = pdFALSE;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    236          
    237            if(LL_USART_IsActiveFlag_RXNE(USART1) != RESET)///< checking flag
   \   00000006   0x....             LDR.N    R0,??DataTable3_9  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       LL_USART_IsActiveFlag_RXNE
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD005             BEQ.N    ??USART1_IRQHandler_0
    238            {   
    239              LL_USART_ClearFlag_RXNE(mbUART);///< reset IT 
   \   00000010   0x....             LDR.N    R0,??DataTable3_9  ;; 0x40013800
   \   00000012   0x.... 0x....      BL       LL_USART_ClearFlag_RXNE
    240              pxMBFrameCBByteReceived();
   \   00000016   0x....             LDR.N    R0,??DataTable3_10
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x4780             BLX      R0
    241            }
    242           
    243           if(LL_USART_IsActiveFlag_TC(mbUART) != RESET)
   \                     ??USART1_IRQHandler_0:
   \   0000001C   0x....             LDR.N    R0,??DataTable3_9  ;; 0x40013800
   \   0000001E   0x.... 0x....      BL       LL_USART_IsActiveFlag_TC
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD012             BEQ.N    ??USART1_IRQHandler_1
    244            {   
    245             LL_USART_ClearFlag_TC(mbUART);///< reset IT  
   \   00000026   0x....             LDR.N    R0,??DataTable3_9  ;; 0x40013800
   \   00000028   0x.... 0x....      BL       LL_USART_ClearFlag_TC
    246             xSemaphoreGiveFromISR( MbTXSemHandle, &xTaskWokenBy );///< signalling
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x....             LDR.N    R0,??DataTable3_11
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       xQueueGiveFromISR
    247             portEND_SWITCHING_ISR( xTaskWokenBy);
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD007             BEQ.N    ??USART1_IRQHandler_1
   \   0000003C   0x....             LDR.N    R0,??DataTable3_7  ;; 0xe000ed04
   \   0000003E   0xF05F 0x5180      MOVS     R1,#+268435456
   \   00000042   0x6001             STR      R1,[R0, #+0]
   \   00000044   0xF3BF 0x8F4F      DSB      
   \   00000048   0xF3BF 0x8F6F      ISB      
    248            }
    249            
    250            /* USER CODE END USART1_IRQn 0 */
    251            /* USER CODE BEGIN USART1_IRQn 1 */
    252          
    253            /* USER CODE END USART1_IRQn 1 */
    254          }
   \                     ??USART1_IRQHandler_1:
   \   0000004C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xEB1C432D         DC32     0xeb1c432d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x3F4A36E2         DC32     0x3f4a36e2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     FlCh

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     MbTimSemHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     pxMBFrameCBByteReceived

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     MbTXSemHandle
    255          
    256          /* USER CODE BEGIN 1 */
    257          
    258          /* USER CODE END 1 */
    259          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  ADC1_2_IRQHandler
             8 -> HAL_GPIO_TogglePin
             8 -> LL_ADC_REG_ReadConversionData12
             8 -> __aeabi_d2f
             8 -> __aeabi_dmul
             8 -> __aeabi_ui2d
        0  BusFault_Handler
        0  DebugMon_Handler
        0  HardFault_Handler
        0  LL_ADC_REG_ReadConversionData12
        0  LL_TIM_ClearFlag_UPDATE
        0  LL_USART_ClearFlag_RXNE
        0  LL_USART_ClearFlag_TC
        0  LL_USART_IsActiveFlag_RXNE
        0  LL_USART_IsActiveFlag_TC
        0  MemManage_Handler
        0  NMI_Handler
        8  SysTick_Handler
             8 -> osSystickHandler
        8  TIM1_UP_IRQHandler
             8 -> LL_TIM_ClearFlag_UPDATE
             8 -> xQueueGiveFromISR
        8  TIM2_IRQHandler
             8 -> HAL_TIM_IRQHandler
        8  USART1_IRQHandler
             8 -- Indirect call
             8 -> LL_USART_ClearFlag_RXNE
             8 -> LL_USART_ClearFlag_TC
             8 -> LL_USART_IsActiveFlag_RXNE
             8 -> LL_USART_IsActiveFlag_TC
             8 -> xQueueGiveFromISR
        0  UsageFault_Handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      40  ADC1_2_IRQHandler
       2  BusFault_Handler
       2  DebugMon_Handler
       2  HardFault_Handler
       6  LL_ADC_REG_ReadConversionData12
       8  LL_TIM_ClearFlag_UPDATE
       8  LL_USART_ClearFlag_RXNE
       8  LL_USART_ClearFlag_TC
      12  LL_USART_IsActiveFlag_RXNE
      12  LL_USART_IsActiveFlag_TC
       2  MemManage_Handler
       2  NMI_Handler
       8  SysTick_Handler
      46  TIM1_UP_IRQHandler
      10  TIM2_IRQHandler
      78  USART1_IRQHandler
       2  UsageFault_Handler

 
 296 bytes in section .text
 
 296 bytes of CODE memory

Errors: none
Warnings: 1
