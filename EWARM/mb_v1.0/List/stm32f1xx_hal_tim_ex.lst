###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  06:16:10 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1 #
#                    xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c                 #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F #
#                    1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c" -D            #
#                    USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F103xB -lC  #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    List\" -o "D:\projects\задания от                        #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/Obj\" --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\stm32f1xx_hal_tim_ex.lst                             #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\stm32f1xx_hal_tim_ex.o                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_tim_ex.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer Extended peripheral:
      8            *           + Time Hall Sensor Interface Initialization
      9            *           + Time Hall Sensor Interface Start
     10            *           + Time Complementary signal bread and dead time configuration
     11            *           + Time Master and Slave synchronization configuration
     12            *           + Timer remapping capabilities configuration
     13            @verbatim
     14            ==============================================================================
     15                                ##### TIMER Extended features #####
     16            ==============================================================================
     17            [..]
     18              The Timer Extended features include:
     19              (#) Complementary outputs with programmable dead-time for :
     20                  (++) Output Compare
     21                  (++) PWM generation (Edge and Center-aligned Mode)
     22                  (++) One-pulse mode output
     23              (#) Synchronization circuit to control the timer with external signals and to
     24                  interconnect several timers together.
     25              (#) Break input to put the timer output signals in reset state or in a known state.
     26              (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for
     27                  positioning purposes
     28          
     29                      ##### How to use this driver #####
     30            ==============================================================================
     31              [..]
     32               (#) Initialize the TIM low level resources by implementing the following functions
     33                   depending from feature used :
     34                     (++) Complementary Output Compare : HAL_TIM_OC_MspInit()
     35                     (++) Complementary PWM generation : HAL_TIM_PWM_MspInit()
     36                     (++) Complementary One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     37                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()
     38          
     39               (#) Initialize the TIM low level resources :
     40                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     41                  (##) TIM pins configuration
     42                      (+++) Enable the clock for the TIM GPIOs using the following function:
     43                        __HAL_RCC_GPIOx_CLK_ENABLE();
     44                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     45          
     46               (#) The external Clock can be configured, if needed (the default clock is the
     47                   internal clock from the APBx), using the following function:
     48                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     49                   any start function.
     50          
     51               (#) Configure the TIM in the desired functioning mode using one of the
     52                   initialization function of this driver:
     53                    (++) HAL_TIMEx_HallSensor_Init and HAL_TIMEx_ConfigCommutationEvent: to use the
     54                        Timer Hall Sensor Interface and the commutation event with the corresponding
     55                        Interrupt and DMA request if needed (Note that One Timer is used to interface
     56                       with the Hall sensor Interface and another Timer should be used to use
     57                       the commutation event).
     58          
     59               (#) Activate the TIM peripheral using one of the start functions:
     60                     (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OCN_Start_IT()
     61                     (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()
     62                     (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
     63                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().
     64          
     65          
     66            @endverbatim
     67            ******************************************************************************
     68            * @attention
     69            *
     70            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     71            *
     72            * Redistribution and use in source and binary forms, with or without modification,
     73            * are permitted provided that the following conditions are met:
     74            *   1. Redistributions of source code must retain the above copyright notice,
     75            *      this list of conditions and the following disclaimer.
     76            *   2. Redistributions in binary form must reproduce the above copyright notice,
     77            *      this list of conditions and the following disclaimer in the documentation
     78            *      and/or other materials provided with the distribution.
     79            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     80            *      may be used to endorse or promote products derived from this software
     81            *      without specific prior written permission.
     82            *
     83            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     84            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     85            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     86            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     87            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     88            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     89            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     90            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     91            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     92            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     93            *
     94            ******************************************************************************
     95          */
     96          
     97          /* Includes ------------------------------------------------------------------*/
     98          #include "stm32f1xx_hal.h"

  /**
    ^
"D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal.h",1  Warning[Pa050]: 
          non-native end of line sequence detected (this diagnostic is only
          issued once)
     99          
    100          /** @addtogroup STM32F1xx_HAL_Driver
    101            * @{
    102            */
    103          
    104          /** @defgroup TIMEx TIMEx
    105            * @brief TIM Extended HAL module driver
    106            * @{
    107            */
    108          
    109          #ifdef HAL_TIM_MODULE_ENABLED
    110          
    111          /* Private typedef -----------------------------------------------------------*/
    112          /* Private define ------------------------------------------------------------*/
    113          /* Private macro -------------------------------------------------------------*/
    114          /* Private variables ---------------------------------------------------------*/
    115          /* Private function prototypes -----------------------------------------------*/
    116          
    117          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
    118              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
    119              defined (STM32F105xC) || defined (STM32F107xC)
    120          /** @defgroup TIMEx_Private_Functions TIMEx Private Functions
    121            * @{
    122            */
    123          static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState);
    124          /**
    125            * @}
    126            */
    127          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
    128                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
    129                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
    130          
    131          /* Exported functions ---------------------------------------------------------*/
    132          
    133          /** @defgroup TIMEx_Exported_Functions TIMEx Exported Functions
    134            * @{
    135            */
    136          
    137          
    138          /** @defgroup TIMEx_Exported_Functions_Group1 Timer Hall Sensor functions
    139           *  @brief    Timer Hall Sensor functions
    140           *
    141          @verbatim
    142            ==============================================================================
    143                                ##### Timer Hall Sensor functions #####
    144            ==============================================================================
    145            [..]
    146              This section provides functions allowing to:
    147              (+) Initialize and configure TIM HAL Sensor.
    148              (+) De-initialize TIM HAL Sensor.
    149              (+) Start the Hall Sensor Interface.
    150              (+) Stop the Hall Sensor Interface.
    151              (+) Start the Hall Sensor Interface and enable interrupts.
    152              (+) Stop the Hall Sensor Interface and disable interrupts.
    153              (+) Start the Hall Sensor Interface and enable DMA transfers.
    154              (+) Stop the Hall Sensor Interface and disable DMA transfers.
    155          
    156          @endverbatim
    157            * @{
    158            */
    159          /**
    160            * @brief  Initializes the TIM Hall Sensor Interface and create the associated handle.
    161            * @param  htim : TIM Encoder Interface handle
    162            * @param  sConfig : TIM Hall Sensor configuration structure
    163            * @retval HAL status
    164            */

   \                                 In section .text, align 2, keep-with-next
    165          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
    166          {
   \                     HAL_TIMEx_HallSensor_Init:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    167            TIM_OC_InitTypeDef OC_Config;
    168          
    169            /* Check the TIM handle allocation */
    170            if(htim == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_TIMEx_HallSensor_Init_0
    171            {
    172              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE062             B.N      ??HAL_TIMEx_HallSensor_Init_1
    173            }
    174          
    175            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    176            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    177            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    178            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    179            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
    180            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
    181            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
    182          
    183            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIMEx_HallSensor_Init_0:
   \   00000010   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Init_2
    184            {
    185              /* Allocate lock resource and initialize it */
    186              htim->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x003C      STRB     R0,[R4, #+60]
    187              
    188              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    189              HAL_TIMEx_HallSensor_MspInit(htim);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspInit
    190            }
    191          
    192            /* Set the TIM state */
    193            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Init_2:
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x003D      STRB     R0,[R4, #+61]
    194          
    195            /* Configure the Time base in the Encoder Mode */
    196            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000002A   0x1D21             ADDS     R1,R4,#+4
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_Base_SetConfig
    197          
    198            /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
    199            TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
   \   00000032   0x68AB             LDR      R3,[R5, #+8]
   \   00000034   0x2203             MOVS     R2,#+3
   \   00000036   0x6829             LDR      R1,[R5, #+0]
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       TIM_TI1_SetConfig
    200          
    201            /* Reset the IC1PSC Bits */
    202            htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6980             LDR      R0,[R0, #+24]
   \   00000042   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6188             STR      R0,[R1, #+24]
    203            /* Set the IC1PSC value */
    204            htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6980             LDR      R0,[R0, #+24]
   \   0000004E   0x6869             LDR      R1,[R5, #+4]
   \   00000050   0x4308             ORRS     R0,R1,R0
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6188             STR      R0,[R1, #+24]
    205          
    206            /* Enable the Hall sensor interface (XOR function of the three inputs) */
    207            htim->Instance->CR2 |= TIM_CR2_TI1S;
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6840             LDR      R0,[R0, #+4]
   \   0000005A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x6048             STR      R0,[R1, #+4]
    208          
    209            /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
    210            htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6880             LDR      R0,[R0, #+8]
   \   00000066   0xF030 0x0070      BICS     R0,R0,#0x70
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x6088             STR      R0,[R1, #+8]
    211            htim->Instance->SMCR |= TIM_TS_TI1F_ED;
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6880             LDR      R0,[R0, #+8]
   \   00000072   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000076   0x6821             LDR      R1,[R4, #+0]
   \   00000078   0x6088             STR      R0,[R1, #+8]
    212          
    213            /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
    214            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6880             LDR      R0,[R0, #+8]
   \   0000007E   0x08C0             LSRS     R0,R0,#+3
   \   00000080   0x00C0             LSLS     R0,R0,#+3
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x6088             STR      R0,[R1, #+8]
    215            htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6880             LDR      R0,[R0, #+8]
   \   0000008A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000008E   0x6821             LDR      R1,[R4, #+0]
   \   00000090   0x6088             STR      R0,[R1, #+8]
    216          
    217            /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
    218            OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x9004             STR      R0,[SP, #+16]
    219            OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x9005             STR      R0,[SP, #+20]
    220            OC_Config.OCMode = TIM_OCMODE_PWM2;
   \   0000009A   0x2070             MOVS     R0,#+112
   \   0000009C   0x9000             STR      R0,[SP, #+0]
    221            OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x9006             STR      R0,[SP, #+24]
    222            OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x9003             STR      R0,[SP, #+12]
    223            OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x9002             STR      R0,[SP, #+8]
    224            OC_Config.Pulse = sConfig->Commutation_Delay;
   \   000000AA   0x68E8             LDR      R0,[R5, #+12]
   \   000000AC   0x9001             STR      R0,[SP, #+4]
    225          
    226            TIM_OC2_SetConfig(htim->Instance, &OC_Config);
   \   000000AE   0xA900             ADD      R1,SP,#+0
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x.... 0x....      BL       TIM_OC2_SetConfig
    227          
    228            /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    229              register to 101 */
    230            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x6840             LDR      R0,[R0, #+4]
   \   000000BA   0xF030 0x0070      BICS     R0,R0,#0x70
   \   000000BE   0x6821             LDR      R1,[R4, #+0]
   \   000000C0   0x6048             STR      R0,[R1, #+4]
    231            htim->Instance->CR2 |= TIM_TRGO_OC2REF;
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6840             LDR      R0,[R0, #+4]
   \   000000C6   0xF050 0x0050      ORRS     R0,R0,#0x50
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x6048             STR      R0,[R1, #+4]
    232          
    233            /* Initialize the TIM state*/
    234            htim->State= HAL_TIM_STATE_READY;
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xF884 0x003D      STRB     R0,[R4, #+61]
    235          
    236            return HAL_OK;
   \   000000D4   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Init_1:
   \   000000D6   0xB007             ADD      SP,SP,#+28
   \   000000D8   0xBD30             POP      {R4,R5,PC}       ;; return
    237          }
    238          
    239          /**
    240            * @brief  DeInitializes the TIM Hall Sensor interface
    241            * @param  htim : TIM Hall Sensor handle
    242            * @retval HAL status
    243            */

   \                                 In section .text, align 2, keep-with-next
    244          HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
    245          {
   \                     HAL_TIMEx_HallSensor_DeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    246            /* Check the parameters */
    247            assert_param(IS_TIM_INSTANCE(htim->Instance));
    248          
    249            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x003D      STRB     R0,[R4, #+61]
    250          
    251            /* Disable the TIM Peripheral Clock */
    252            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD10B             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6A00             LDR      R0,[R0, #+32]
   \   0000001A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    253          
    254            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    255            HAL_TIMEx_HallSensor_MspDeInit(htim);
   \                     ??HAL_TIMEx_HallSensor_DeInit_0:
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspDeInit
    256          
    257            /* Change TIM state */
    258            htim->State = HAL_TIM_STATE_RESET;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x003D      STRB     R0,[R4, #+61]
    259          
    260            /* Release Lock */
    261            __HAL_UNLOCK(htim);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x003C      STRB     R0,[R4, #+60]
    262          
    263            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    264          }
    265          
    266          /**
    267            * @brief  Initializes the TIM Hall Sensor MSP.
    268            * @param  htim : TIM handle
    269            * @retval None
    270            */

   \                                 In section .text, align 2, keep-with-next
    271          __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
    272          {
    273            /* Prevent unused argument(s) compilation warning */
    274            UNUSED(htim);
    275            /* NOTE : This function Should not be modified, when the callback is needed,
    276                      the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
    277             */
    278          }
   \                     HAL_TIMEx_HallSensor_MspInit:
   \   00000000   0x4770             BX       LR               ;; return
    279          
    280          /**
    281            * @brief  DeInitializes TIM Hall Sensor MSP.
    282            * @param  htim : TIM handle
    283            * @retval None
    284            */

   \                                 In section .text, align 2, keep-with-next
    285          __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
    286          {
    287            /* Prevent unused argument(s) compilation warning */
    288            UNUSED(htim);
    289            /* NOTE : This function Should not be modified, when the callback is needed,
    290                      the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
    291             */
    292          }
   \                     HAL_TIMEx_HallSensor_MspDeInit:
   \   00000000   0x4770             BX       LR               ;; return
    293          
    294          /**
    295            * @brief  Starts the TIM Hall Sensor Interface.
    296            * @param  htim : TIM Hall Sensor handle
    297            * @retval HAL status
    298            */

   \                                 In section .text, align 2, keep-with-next
    299          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
    300          {
   \                     HAL_TIMEx_HallSensor_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    301            /* Check the parameters */
    302            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    303          
    304            /* Enable the Input Capture channel 1
    305              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    306            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    307          
    308            /* Enable the Peripheral */
    309            __HAL_TIM_ENABLE(htim);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000016   0x6821             LDR      R1,[R4, #+0]
   \   00000018   0x6008             STR      R0,[R1, #+0]
    310          
    311            /* Return function status */
    312            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    313          }
    314          
    315          /**
    316            * @brief  Stops the TIM Hall sensor Interface.
    317            * @param  htim : TIM Hall Sensor handle
    318            * @retval HAL status
    319            */

   \                                 In section .text, align 2, keep-with-next
    320          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
    321          {
   \                     HAL_TIMEx_HallSensor_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    322            /* Check the parameters */
    323            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    324          
    325            /* Disable the Input Capture channel 1
    326              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    327            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    328          
    329            /* Disable the Peripheral */
    330            __HAL_TIM_DISABLE(htim);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A00             LDR      R0,[R0, #+32]
   \   00000012   0xF241 0x1111      MOVW     R1,#+4369
   \   00000016   0x4208             TST      R0,R1
   \   00000018   0xD10B             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6A00             LDR      R0,[R0, #+32]
   \   0000001E   0xF240 0x4144      MOVW     R1,#+1092
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0840             LSRS     R0,R0,#+1
   \   0000002C   0x0040             LSLS     R0,R0,#+1
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6008             STR      R0,[R1, #+0]
    331          
    332            /* Return function status */
    333            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_0:
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    334          }
    335          
    336          /**
    337            * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
    338            * @param  htim : TIM Hall Sensor handle
    339            * @retval HAL status
    340            */

   \                                 In section .text, align 2, keep-with-next
    341          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
    342          {
   \                     HAL_TIMEx_HallSensor_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    343            /* Check the parameters */
    344            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    345          
    346            /* Enable the capture compare Interrupts 1 event */
    347            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
    348          
    349            /* Enable the Input Capture channel 1
    350              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    351            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       TIM_CCxChannelCmd
    352          
    353            /* Enable the Peripheral */
    354            __HAL_TIM_ENABLE(htim);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x6008             STR      R0,[R1, #+0]
    355          
    356            /* Return function status */
    357            return HAL_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    358          }
    359          
    360          /**
    361            * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
    362            * @param  htim : TIM handle
    363            * @retval HAL status
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
    366          {
   \                     HAL_TIMEx_HallSensor_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    367            /* Check the parameters */
    368            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    369          
    370            /* Disable the Input Capture channel 1
    371              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    372            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    373          
    374            /* Disable the capture compare Interrupts event */
    375            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000016   0x6821             LDR      R1,[R4, #+0]
   \   00000018   0x60C8             STR      R0,[R1, #+12]
    376          
    377            /* Disable the Peripheral */
    378            __HAL_TIM_DISABLE(htim);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6A00             LDR      R0,[R0, #+32]
   \   0000001E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD10B             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6A00             LDR      R0,[R0, #+32]
   \   0000002A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000002E   0x4208             TST      R0,R1
   \   00000030   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x0840             LSRS     R0,R0,#+1
   \   00000038   0x0040             LSLS     R0,R0,#+1
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    379          
    380            /* Return function status */
    381            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_IT_0:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    382          }
    383          
    384          /**
    385            * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
    386            * @param  htim : TIM Hall Sensor handle
    387            * @param  pData : The destination Buffer address.
    388            * @param  Length : The length of data to be transferred from TIM peripheral to memory.
    389            * @retval HAL status
    390            */

   \                                 In section .text, align 2, keep-with-next
    391          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    392          {
   \                     HAL_TIMEx_HallSensor_Start_DMA:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    393            /* Check the parameters */
    394            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    395          
    396             if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_0
    397            {
    398               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE031             B.N      ??HAL_TIMEx_HallSensor_Start_DMA_1
    399            }
    400            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_0:
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD109             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_2
    401            {
    402              if(((uint32_t)pData == 0U) && (Length > 0U))
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD104             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_3
   \   00000020   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_3
    403              {
    404                return HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE026             B.N      ??HAL_TIMEx_HallSensor_Start_DMA_1
    405              }
    406              else
    407              {
    408                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_3:
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x003D      STRB     R0,[R4, #+61]
    409              }
    410            }
    411            /* Enable the Input Capture channel 1
    412              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    413            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_2:
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_CCxChannelCmd
    414          
    415            /* Set the DMA Input Capture 1 Callback */
    416            htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \   0000003A   0x6A60             LDR      R0,[R4, #+36]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable3
   \   00000040   0x6281             STR      R1,[R0, #+40]
    417            /* Set the DMA error callback */
    418            htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000042   0x6A60             LDR      R0,[R4, #+36]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable3_1
   \   00000048   0x6301             STR      R1,[R0, #+48]
    419          
    420            /* Enable the DMA channel for Capture 1*/
    421            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
   \   0000004A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004C   0x0033             MOVS     R3,R6
   \   0000004E   0x002A             MOVS     R2,R5
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF110 0x0134      ADDS     R1,R0,#+52
   \   00000056   0x6A60             LDR      R0,[R4, #+36]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
    422          
    423            /* Enable the capture compare 1 Interrupt */
    424            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0xF44F 0x7100      MOV      R1,#+512
   \   00000064   0x4308             ORRS     R0,R1,R0
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x60C8             STR      R0,[R1, #+12]
    425          
    426            /* Enable the Peripheral */
    427            __HAL_TIM_ENABLE(htim);
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x6008             STR      R0,[R1, #+0]
    428          
    429            /* Return function status */
    430            return HAL_OK;
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_1:
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    431          }
    432          
    433          /**
    434            * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
    435            * @param  htim : TIM handle
    436            * @retval HAL status
    437            */

   \                                 In section .text, align 2, keep-with-next
    438          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
    439          {
   \                     HAL_TIMEx_HallSensor_Stop_DMA:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    440            /* Check the parameters */
    441            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    442          
    443            /* Disable the Input Capture channel 1
    444              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    445            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    446          
    447          
    448            /* Disable the capture compare Interrupts 1 event */
    449            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000016   0x6821             LDR      R1,[R4, #+0]
   \   00000018   0x60C8             STR      R0,[R1, #+12]
    450          
    451            /* Disable the Peripheral */
    452            __HAL_TIM_DISABLE(htim);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6A00             LDR      R0,[R0, #+32]
   \   0000001E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD10B             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6A00             LDR      R0,[R0, #+32]
   \   0000002A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000002E   0x4208             TST      R0,R1
   \   00000030   0xD105             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x0840             LSRS     R0,R0,#+1
   \   00000038   0x0040             LSLS     R0,R0,#+1
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    453          
    454            /* Return function status */
    455            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_DMA_0:
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    456          }
    457          
    458          /**
    459            * @}
    460            */
    461          
    462          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
    463              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
    464              defined (STM32F105xC) || defined (STM32F107xC)
    465          
    466          /** @defgroup TIMEx_Exported_Functions_Group2 Timer Complementary Output Compare functions
    467           *  @brief    Timer Complementary Output Compare functions
    468           *
    469          @verbatim
    470            ==============================================================================
    471                        ##### Timer Complementary Output Compare functions #####
    472            ==============================================================================
    473            [..]
    474              This section provides functions allowing to:
    475              (+) Start the Complementary Output Compare/PWM.
    476              (+) Stop the Complementary Output Compare/PWM.
    477              (+) Start the Complementary Output Compare/PWM and enable interrupts.
    478              (+) Stop the Complementary Output Compare/PWM and disable interrupts.
    479              (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
    480              (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.
    481          
    482          @endverbatim
    483            * @{
    484            */
    485          
    486          /**
    487            * @brief  Starts the TIM Output Compare signal generation on the complementary
    488            *         output.
    489            * @param  htim : TIM Output Compare handle
    490            * @param  Channel : TIM Channel to be enabled
    491            *          This parameter can be one of the following values:
    492            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    493            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    494            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    495            * @retval HAL status
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    498          {
   \                     HAL_TIMEx_OCN_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    499            /* Check the parameters */
    500            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    501          
    502            /* Enable the Capture compare channel N */
    503            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    504          
    505            /* Enable the Main Ouput */
    506            __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C40             LDR      R0,[R0, #+68]
   \   00000010   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6448             STR      R0,[R1, #+68]
    507          
    508            /* Enable the Peripheral */
    509            __HAL_TIM_ENABLE(htim);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
    510          
    511            /* Return function status */
    512            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    513          }
    514          
    515          /**
    516            * @brief  Stops the TIM Output Compare signal generation on the complementary
    517            *         output.
    518            * @param  htim : TIM handle
    519            * @param  Channel : TIM Channel to be disabled
    520            *          This parameter can be one of the following values:
    521            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    522            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    523            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    524            * @retval HAL status
    525            */

   \                                 In section .text, align 2, keep-with-next
    526          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    527          {
   \                     HAL_TIMEx_OCN_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    528            /* Check the parameters */
    529            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    530          
    531            /* Disable the Capture compare channel N */
    532            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    533          
    534            /* Disable the Main Ouput */
    535            __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6A00             LDR      R0,[R0, #+32]
   \   00000010   0xF241 0x1111      MOVW     R1,#+4369
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6A00             LDR      R0,[R0, #+32]
   \   0000001C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6C40             LDR      R0,[R0, #+68]
   \   00000028   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6448             STR      R0,[R1, #+68]
    536          
    537            /* Disable the Peripheral */
    538            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_0:
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6A00             LDR      R0,[R0, #+32]
   \   00000034   0xF241 0x1111      MOVW     R1,#+4369
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6A00             LDR      R0,[R0, #+32]
   \   00000040   0xF240 0x4144      MOVW     R1,#+1092
   \   00000044   0x4208             TST      R0,R1
   \   00000046   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0840             LSRS     R0,R0,#+1
   \   0000004E   0x0040             LSLS     R0,R0,#+1
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6008             STR      R0,[R1, #+0]
    539          
    540            /* Return function status */
    541            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_1:
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    542          }
    543          
    544          /**
    545            * @brief  Starts the TIM Output Compare signal generation in interrupt mode
    546            *         on the complementary output.
    547            * @param  htim : TIM OC handle
    548            * @param  Channel : TIM Channel to be enabled
    549            *          This parameter can be one of the following values:
    550            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    551            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    552            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    553            * @retval HAL status
    554            */

   \                                 In section .text, align 2, keep-with-next
    555          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    556          {
   \                     HAL_TIMEx_OCN_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    557            /* Check the parameters */
    558            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    559          
    560            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD009             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_2
   \   00000012   0xE014             B.N      ??HAL_TIMEx_OCN_Start_IT_3
    561            {
    562              case TIM_CHANNEL_1:
    563              {
    564                /* Enable the TIM Output Compare interrupt */
    565                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Start_IT_0:
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001C   0x6822             LDR      R2,[R4, #+0]
   \   0000001E   0x60D0             STR      R0,[R2, #+12]
    566              }
    567              break;
   \   00000020   0xE00D             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    568          
    569              case TIM_CHANNEL_2:
    570              {
    571                /* Enable the TIM Output Compare interrupt */
    572                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Start_IT_1:
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002A   0x6822             LDR      R2,[R4, #+0]
   \   0000002C   0x60D0             STR      R0,[R2, #+12]
    573              }
    574              break;
   \   0000002E   0xE006             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    575          
    576              case TIM_CHANNEL_3:
    577              {
    578                /* Enable the TIM Output Compare interrupt */
    579                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Start_IT_2:
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000038   0x6822             LDR      R2,[R4, #+0]
   \   0000003A   0x60D0             STR      R0,[R2, #+12]
    580              }
    581              break;
   \   0000003C   0xE7FF             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    582          
    583              default:
    584              break;
    585            }
    586          
    587            /* Enable the TIM Break interrupt */
    588            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_OCN_Start_IT_3:
   \                     ??HAL_TIMEx_OCN_Start_IT_4:
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x68C0             LDR      R0,[R0, #+12]
   \   00000042   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000046   0x6822             LDR      R2,[R4, #+0]
   \   00000048   0x60D0             STR      R0,[R2, #+12]
    589          
    590            /* Enable the Capture compare channel N */
    591            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       TIM_CCxNChannelCmd
    592          
    593            /* Enable the Main Ouput */
    594            __HAL_TIM_MOE_ENABLE(htim);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6C40             LDR      R0,[R0, #+68]
   \   00000056   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6448             STR      R0,[R1, #+68]
    595          
    596            /* Enable the Peripheral */
    597            __HAL_TIM_ENABLE(htim);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6008             STR      R0,[R1, #+0]
    598          
    599            /* Return function status */
    600            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    601          }
    602          
    603          /**
    604            * @brief  Stops the TIM Output Compare signal generation in interrupt mode
    605            *         on the complementary output.
    606            * @param  htim : TIM Output Compare handle
    607            * @param  Channel : TIM Channel to be disabled
    608            *          This parameter can be one of the following values:
    609            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    610            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    611            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    612            * @retval HAL status
    613            */

   \                                 In section .text, align 2, keep-with-next
    614          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    615          {
   \                     HAL_TIMEx_OCN_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    616            uint32_t tmpccer = 0U;
   \   00000004   0x2000             MOVS     R0,#+0
    617          
    618            /* Check the parameters */
    619            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    620          
    621            switch (Channel)
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_0
   \   0000000C   0x2A04             CMP      R2,#+4
   \   0000000E   0xD009             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_1
   \   00000010   0x2A08             CMP      R2,#+8
   \   00000012   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_2
   \   00000014   0xE014             B.N      ??HAL_TIMEx_OCN_Stop_IT_3
    622            {
    623              case TIM_CHANNEL_1:
    624              {
    625                /* Disable the TIM Output Compare interrupt */
    626                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_IT_0:
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C0             LDR      R0,[R0, #+12]
   \   0000001A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001E   0x6822             LDR      R2,[R4, #+0]
   \   00000020   0x60D0             STR      R0,[R2, #+12]
    627              }
    628              break;
   \   00000022   0xE00D             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    629          
    630              case TIM_CHANNEL_2:
    631              {
    632                /* Disable the TIM Output Compare interrupt */
    633                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_IT_1:
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x68C0             LDR      R0,[R0, #+12]
   \   00000028   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000002C   0x6822             LDR      R2,[R4, #+0]
   \   0000002E   0x60D0             STR      R0,[R2, #+12]
    634              }
    635              break;
   \   00000030   0xE006             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    636          
    637              case TIM_CHANNEL_3:
    638              {
    639                /* Disable the TIM Output Compare interrupt */
    640                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_IT_2:
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x68C0             LDR      R0,[R0, #+12]
   \   00000036   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003A   0x6822             LDR      R2,[R4, #+0]
   \   0000003C   0x60D0             STR      R0,[R2, #+12]
    641              }
    642              break;
   \   0000003E   0xE7FF             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    643          
    644              default:
    645              break;
    646            }
    647          
    648            /* Disable the Capture compare channel N */
    649            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_IT_3:
   \                     ??HAL_TIMEx_OCN_Stop_IT_4:
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxNChannelCmd
    650          
    651            /* Disable the TIM Break interrupt (only if no more channel is active) */
    652            tmpccer = htim->Instance->CCER;
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6A00             LDR      R0,[R0, #+32]
    653            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
   \   0000004C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_5
    654            {
    655              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
    656            }
    657          
    658            /* Disable the Main Ouput */
    659            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_5:
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6A00             LDR      R0,[R0, #+32]
   \   00000064   0xF241 0x1111      MOVW     R1,#+4369
   \   00000068   0x4208             TST      R0,R1
   \   0000006A   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6A00             LDR      R0,[R0, #+32]
   \   00000070   0xF240 0x4144      MOVW     R1,#+1092
   \   00000074   0x4208             TST      R0,R1
   \   00000076   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6C40             LDR      R0,[R0, #+68]
   \   0000007C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000080   0x6821             LDR      R1,[R4, #+0]
   \   00000082   0x6448             STR      R0,[R1, #+68]
    660          
    661            /* Disable the Peripheral */
    662            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_6:
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A00             LDR      R0,[R0, #+32]
   \   00000088   0xF241 0x1111      MOVW     R1,#+4369
   \   0000008C   0x4208             TST      R0,R1
   \   0000008E   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6A00             LDR      R0,[R0, #+32]
   \   00000094   0xF240 0x4144      MOVW     R1,#+1092
   \   00000098   0x4208             TST      R0,R1
   \   0000009A   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x0840             LSRS     R0,R0,#+1
   \   000000A2   0x0040             LSLS     R0,R0,#+1
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    663          
    664            /* Return function status */
    665            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_IT_7:
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xBD10             POP      {R4,PC}          ;; return
    666          }
    667          
    668          /**
    669            * @brief  Starts the TIM Output Compare signal generation in DMA mode
    670            *         on the complementary output.
    671            * @param  htim : TIM Output Compare handle
    672            * @param  Channel : TIM Channel to be enabled
    673            *          This parameter can be one of the following values:
    674            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    675            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    676            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    677            * @param  pData : The source Buffer address.
    678            * @param  Length : The length of data to be transferred from memory to TIM peripheral
    679            * @retval HAL status
    680            */

   \                                 In section .text, align 2, keep-with-next
    681          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    682          {
   \                     HAL_TIMEx_OCN_Start_DMA:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0011             MOVS     R1,R2
    683            /* Check the parameters */
    684            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    685          
    686            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_0
    687            {
    688               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE06A             B.N      ??HAL_TIMEx_OCN_Start_DMA_1
    689            }
    690            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_OCN_Start_DMA_0:
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD109             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_2
    691            {
    692              if(((uint32_t)pData == 0U) && (Length > 0U))
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD104             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_3
   \   00000020   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_3
    693              {
    694                return HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE05F             B.N      ??HAL_TIMEx_OCN_Start_DMA_1
    695              }
    696              else
    697              {
    698                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_OCN_Start_DMA_3:
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x003D      STRB     R0,[R4, #+61]
    699              }
    700            }
    701            switch (Channel)
   \                     ??HAL_TIMEx_OCN_Start_DMA_2:
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_4
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xD019             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_5
   \   0000003A   0x2808             CMP      R0,#+8
   \   0000003C   0xD02D             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_6
   \   0000003E   0xE042             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    702            {
    703              case TIM_CHANNEL_1:
    704              {
    705                /* Set the DMA Period elapsed callback */
    706                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_4:
   \   00000040   0x6A60             LDR      R0,[R4, #+36]
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable3_2
   \   00000046   0x6282             STR      R2,[R0, #+40]
    707          
    708                /* Set the DMA error callback */
    709                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x6A60             LDR      R0,[R4, #+36]
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable3_1
   \   0000004E   0x6302             STR      R2,[R0, #+48]
    710          
    711                /* Enable the DMA channel */
    712                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000050   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0xF110 0x0234      ADDS     R2,R0,#+52
   \   00000058   0x6A60             LDR      R0,[R4, #+36]
   \   0000005A   0x.... 0x....      BL       HAL_DMA_Start_IT
    713          
    714                /* Enable the TIM Output Compare DMA request */
    715                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0xF44F 0x7100      MOV      R1,#+512
   \   00000066   0x4308             ORRS     R0,R1,R0
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x60C8             STR      R0,[R1, #+12]
    716              }
    717              break;
   \   0000006C   0xE02B             B.N      ??HAL_TIMEx_OCN_Start_DMA_8
    718          
    719              case TIM_CHANNEL_2:
    720              {
    721                /* Set the DMA Period elapsed callback */
    722                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_5:
   \   0000006E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000070   0x.... 0x....      LDR.W    R2,??DataTable3_2
   \   00000074   0x6282             STR      R2,[R0, #+40]
    723          
    724                /* Set the DMA error callback */
    725                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000076   0x6AA0             LDR      R0,[R4, #+40]
   \   00000078   0x.... 0x....      LDR.W    R2,??DataTable3_1
   \   0000007C   0x6302             STR      R2,[R0, #+48]
    726          
    727                /* Enable the DMA channel */
    728                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   0000007E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0xF110 0x0238      ADDS     R2,R0,#+56
   \   00000086   0x6AA0             LDR      R0,[R4, #+40]
   \   00000088   0x.... 0x....      BL       HAL_DMA_Start_IT
    729          
    730                /* Enable the TIM Output Compare DMA request */
    731                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x68C0             LDR      R0,[R0, #+12]
   \   00000090   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000094   0x6821             LDR      R1,[R4, #+0]
   \   00000096   0x60C8             STR      R0,[R1, #+12]
    732              }
    733              break;
   \   00000098   0xE015             B.N      ??HAL_TIMEx_OCN_Start_DMA_8
    734          
    735              case TIM_CHANNEL_3:
    736              {
    737                /* Set the DMA Period elapsed callback */
    738                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_6:
   \   0000009A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable3_2
   \   000000A0   0x6282             STR      R2,[R0, #+40]
    739          
    740                /* Set the DMA error callback */
    741                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000A2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable3_1
   \   000000A8   0x6302             STR      R2,[R0, #+48]
    742          
    743                /* Enable the DMA channel */
    744                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000AA   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0xF110 0x023C      ADDS     R2,R0,#+60
   \   000000B2   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B4   0x.... 0x....      BL       HAL_DMA_Start_IT
    745          
    746                /* Enable the TIM Output Compare DMA request */
    747                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x68C0             LDR      R0,[R0, #+12]
   \   000000BC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x60C8             STR      R0,[R1, #+12]
    748              }
    749              break;
   \   000000C4   0xE7FF             B.N      ??HAL_TIMEx_OCN_Start_DMA_8
    750          
    751              default:
    752              break;
    753            }
    754          
    755            /* Enable the Capture compare channel N */
    756            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_OCN_Start_DMA_7:
   \                     ??HAL_TIMEx_OCN_Start_DMA_8:
   \   000000C6   0x2204             MOVS     R2,#+4
   \   000000C8   0x0029             MOVS     R1,R5
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x.... 0x....      BL       TIM_CCxNChannelCmd
    757          
    758            /* Enable the Main Ouput */
    759            __HAL_TIM_MOE_ENABLE(htim);
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6C40             LDR      R0,[R0, #+68]
   \   000000D4   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000D8   0x6821             LDR      R1,[R4, #+0]
   \   000000DA   0x6448             STR      R0,[R1, #+68]
    760          
    761            /* Enable the Peripheral */
    762            __HAL_TIM_ENABLE(htim);
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000E4   0x6821             LDR      R1,[R4, #+0]
   \   000000E6   0x6008             STR      R0,[R1, #+0]
    763          
    764            /* Return function status */
    765            return HAL_OK;
   \   000000E8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_OCN_Start_DMA_1:
   \   000000EA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    766          }
    767          
    768          /**
    769            * @brief  Stops the TIM Output Compare signal generation in DMA mode
    770            *         on the complementary output.
    771            * @param  htim : TIM Output Compare handle
    772            * @param  Channel : TIM Channel to be disabled
    773            *          This parameter can be one of the following values:
    774            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    775            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    776            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    777            * @retval HAL status
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    780          {
   \                     HAL_TIMEx_OCN_Stop_DMA:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    781            /* Check the parameters */
    782            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    783          
    784            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD004             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD009             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_2
   \   00000012   0xE014             B.N      ??HAL_TIMEx_OCN_Stop_DMA_3
    785            {
    786              case TIM_CHANNEL_1:
    787              {
    788                /* Disable the TIM Output Compare DMA request */
    789                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_0:
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000001C   0x6822             LDR      R2,[R4, #+0]
   \   0000001E   0x60D0             STR      R0,[R2, #+12]
    790              }
    791              break;
   \   00000020   0xE00D             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    792          
    793              case TIM_CHANNEL_2:
    794              {
    795                /* Disable the TIM Output Compare DMA request */
    796                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_1:
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000002A   0x6822             LDR      R2,[R4, #+0]
   \   0000002C   0x60D0             STR      R0,[R2, #+12]
    797              }
    798              break;
   \   0000002E   0xE006             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    799          
    800              case TIM_CHANNEL_3:
    801              {
    802                /* Disable the TIM Output Compare DMA request */
    803                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_2:
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000038   0x6822             LDR      R2,[R4, #+0]
   \   0000003A   0x60D0             STR      R0,[R2, #+12]
    804              }
    805              break;
   \   0000003C   0xE7FF             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    806          
    807              default:
    808              break;
    809            }
    810          
    811            /* Disable the Capture compare channel N */
    812            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_3:
   \                     ??HAL_TIMEx_OCN_Stop_DMA_4:
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       TIM_CCxNChannelCmd
    813          
    814            /* Disable the Main Ouput */
    815            __HAL_TIM_MOE_DISABLE(htim);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6A00             LDR      R0,[R0, #+32]
   \   0000004A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000004E   0x4208             TST      R0,R1
   \   00000050   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6A00             LDR      R0,[R0, #+32]
   \   00000056   0xF240 0x4144      MOVW     R1,#+1092
   \   0000005A   0x4208             TST      R0,R1
   \   0000005C   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6C40             LDR      R0,[R0, #+68]
   \   00000062   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6448             STR      R0,[R1, #+68]
    816          
    817            /* Disable the Peripheral */
    818            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_5:
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000072   0x4208             TST      R0,R1
   \   00000074   0xD10B             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6A00             LDR      R0,[R0, #+32]
   \   0000007A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000007E   0x4208             TST      R0,R1
   \   00000080   0xD105             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x0840             LSRS     R0,R0,#+1
   \   00000088   0x0040             LSLS     R0,R0,#+1
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    819          
    820            /* Change the htim state */
    821            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_OCN_Stop_DMA_6:
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xF884 0x003D      STRB     R0,[R4, #+61]
    822          
    823            /* Return function status */
    824            return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
    825          }
    826          
    827          /**
    828            * @}
    829            */
    830          
    831          /** @defgroup TIMEx_Exported_Functions_Group3 Timer Complementary PWM functions
    832           *  @brief    Timer Complementary PWM functions
    833           *
    834          @verbatim
    835            ==============================================================================
    836                           ##### Timer Complementary PWM functions #####
    837            ==============================================================================
    838            [..]
    839              This section provides functions allowing to:
    840              (+) Start the Complementary PWM.
    841              (+) Stop the Complementary PWM.
    842              (+) Start the Complementary PWM and enable interrupts.
    843              (+) Stop the Complementary PWM and disable interrupts.
    844              (+) Start the Complementary PWM and enable DMA transfers.
    845              (+) Stop the Complementary PWM and disable DMA transfers.
    846              (+) Start the Complementary Input Capture measurement.
    847              (+) Stop the Complementary Input Capture.
    848              (+) Start the Complementary Input Capture and enable interrupts.
    849              (+) Stop the Complementary Input Capture and disable interrupts.
    850              (+) Start the Complementary Input Capture and enable DMA transfers.
    851              (+) Stop the Complementary Input Capture and disable DMA transfers.
    852              (+) Start the Complementary One Pulse generation.
    853              (+) Stop the Complementary One Pulse.
    854              (+) Start the Complementary One Pulse and enable interrupts.
    855              (+) Stop the Complementary One Pulse and disable interrupts.
    856          
    857          @endverbatim
    858            * @{
    859            */
    860          
    861          /**
    862            * @brief  Starts the PWM signal generation on the complementary output.
    863            * @param  htim : TIM handle
    864            * @param  Channel : TIM Channel to be enabled
    865            *          This parameter can be one of the following values:
    866            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    867            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    868            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    869            * @retval HAL status
    870            */

   \                                 In section .text, align 2, keep-with-next
    871          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    872          {
   \                     HAL_TIMEx_PWMN_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    873            /* Check the parameters */
    874            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    875          
    876            /* Enable the complementary PWM output  */
    877            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    878          
    879            /* Enable the Main Ouput */
    880            __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C40             LDR      R0,[R0, #+68]
   \   00000010   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6448             STR      R0,[R1, #+68]
    881          
    882            /* Enable the Peripheral */
    883            __HAL_TIM_ENABLE(htim);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x6008             STR      R0,[R1, #+0]
    884          
    885            /* Return function status */
    886            return HAL_OK;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    887          }
    888          
    889          /**
    890            * @brief  Stops the PWM signal generation on the complementary output.
    891            * @param  htim : TIM handle
    892            * @param  Channel : TIM Channel to be disabled
    893            *          This parameter can be one of the following values:
    894            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    895            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    896            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    897            * @retval HAL status
    898            */

   \                                 In section .text, align 2, keep-with-next
    899          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    900          {
   \                     HAL_TIMEx_PWMN_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    901            /* Check the parameters */
    902            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    903          
    904            /* Disable the complementary PWM output  */
    905            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    906          
    907            /* Disable the Main Ouput */
    908            __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6A00             LDR      R0,[R0, #+32]
   \   00000010   0xF241 0x1111      MOVW     R1,#+4369
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6A00             LDR      R0,[R0, #+32]
   \   0000001C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6C40             LDR      R0,[R0, #+68]
   \   00000028   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6448             STR      R0,[R1, #+68]
    909          
    910            /* Disable the Peripheral */
    911            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_0:
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6A00             LDR      R0,[R0, #+32]
   \   00000034   0xF241 0x1111      MOVW     R1,#+4369
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6A00             LDR      R0,[R0, #+32]
   \   00000040   0xF240 0x4144      MOVW     R1,#+1092
   \   00000044   0x4208             TST      R0,R1
   \   00000046   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0840             LSRS     R0,R0,#+1
   \   0000004E   0x0040             LSLS     R0,R0,#+1
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6008             STR      R0,[R1, #+0]
    912          
    913            /* Return function status */
    914            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_1:
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    915          }
    916          
    917          /**
    918            * @brief  Starts the PWM signal generation in interrupt mode on the
    919            *         complementary output.
    920            * @param  htim : TIM handle
    921            * @param  Channel : TIM Channel to be disabled
    922            *          This parameter can be one of the following values:
    923            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    924            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    925            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    926            * @retval HAL status
    927            */

   \                                 In section .text, align 2, keep-with-next
    928          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    929          {
   \                     HAL_TIMEx_PWMN_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    930            /* Check the parameters */
    931            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    932          
    933            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD009             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_2
   \   00000012   0xE014             B.N      ??HAL_TIMEx_PWMN_Start_IT_3
    934            {
    935              case TIM_CHANNEL_1:
    936              {
    937                /* Enable the TIM Capture/Compare 1 interrupt */
    938                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Start_IT_0:
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001C   0x6822             LDR      R2,[R4, #+0]
   \   0000001E   0x60D0             STR      R0,[R2, #+12]
    939              }
    940              break;
   \   00000020   0xE00D             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    941          
    942              case TIM_CHANNEL_2:
    943              {
    944                /* Enable the TIM Capture/Compare 2 interrupt */
    945                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Start_IT_1:
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002A   0x6822             LDR      R2,[R4, #+0]
   \   0000002C   0x60D0             STR      R0,[R2, #+12]
    946              }
    947              break;
   \   0000002E   0xE006             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    948          
    949              case TIM_CHANNEL_3:
    950              {
    951                /* Enable the TIM Capture/Compare 3 interrupt */
    952                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Start_IT_2:
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000038   0x6822             LDR      R2,[R4, #+0]
   \   0000003A   0x60D0             STR      R0,[R2, #+12]
    953              }
    954              break;
   \   0000003C   0xE7FF             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    955          
    956              default:
    957              break;
    958            }
    959          
    960            /* Enable the TIM Break interrupt */
    961            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_PWMN_Start_IT_3:
   \                     ??HAL_TIMEx_PWMN_Start_IT_4:
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x68C0             LDR      R0,[R0, #+12]
   \   00000042   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000046   0x6822             LDR      R2,[R4, #+0]
   \   00000048   0x60D0             STR      R0,[R2, #+12]
    962          
    963            /* Enable the complementary PWM output  */
    964            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       TIM_CCxNChannelCmd
    965          
    966            /* Enable the Main Ouput */
    967            __HAL_TIM_MOE_ENABLE(htim);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6C40             LDR      R0,[R0, #+68]
   \   00000056   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6448             STR      R0,[R1, #+68]
    968          
    969            /* Enable the Peripheral */
    970            __HAL_TIM_ENABLE(htim);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6008             STR      R0,[R1, #+0]
    971          
    972            /* Return function status */
    973            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    974          }
    975          
    976          /**
    977            * @brief  Stops the PWM signal generation in interrupt mode on the
    978            *         complementary output.
    979            * @param  htim : TIM handle
    980            * @param  Channel : TIM Channel to be disabled
    981            *          This parameter can be one of the following values:
    982            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    983            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    984            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    985            * @retval HAL status
    986            */

   \                                 In section .text, align 2, keep-with-next
    987          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    988          {
   \                     HAL_TIMEx_PWMN_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    989            uint32_t tmpccer = 0U;
   \   00000004   0x2000             MOVS     R0,#+0
    990          
    991            /* Check the parameters */
    992            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    993          
    994            switch (Channel)
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_0
   \   0000000C   0x2A04             CMP      R2,#+4
   \   0000000E   0xD009             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_1
   \   00000010   0x2A08             CMP      R2,#+8
   \   00000012   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_2
   \   00000014   0xE014             B.N      ??HAL_TIMEx_PWMN_Stop_IT_3
    995            {
    996              case TIM_CHANNEL_1:
    997              {
    998                /* Disable the TIM Capture/Compare 1 interrupt */
    999                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_0:
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C0             LDR      R0,[R0, #+12]
   \   0000001A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000001E   0x6822             LDR      R2,[R4, #+0]
   \   00000020   0x60D0             STR      R0,[R2, #+12]
   1000              }
   1001              break;
   \   00000022   0xE00D             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1002          
   1003              case TIM_CHANNEL_2:
   1004              {
   1005                /* Disable the TIM Capture/Compare 2 interrupt */
   1006                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_1:
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x68C0             LDR      R0,[R0, #+12]
   \   00000028   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000002C   0x6822             LDR      R2,[R4, #+0]
   \   0000002E   0x60D0             STR      R0,[R2, #+12]
   1007              }
   1008              break;
   \   00000030   0xE006             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1009          
   1010              case TIM_CHANNEL_3:
   1011              {
   1012                /* Disable the TIM Capture/Compare 3 interrupt */
   1013                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_2:
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x68C0             LDR      R0,[R0, #+12]
   \   00000036   0xF030 0x0008      BICS     R0,R0,#0x8
   \   0000003A   0x6822             LDR      R2,[R4, #+0]
   \   0000003C   0x60D0             STR      R0,[R2, #+12]
   1014              }
   1015              break;
   \   0000003E   0xE7FF             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1016          
   1017              default:
   1018              break;
   1019            }
   1020          
   1021            /* Disable the complementary PWM output  */
   1022            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_3:
   \                     ??HAL_TIMEx_PWMN_Stop_IT_4:
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1023          
   1024            /* Disable the TIM Break interrupt (only if no more channel is active) */
   1025            tmpccer = htim->Instance->CCER;
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6A00             LDR      R0,[R0, #+32]
   1026            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
   \   0000004C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_5
   1027            {
   1028              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000005C   0x6821             LDR      R1,[R4, #+0]
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
   1029            }
   1030          
   1031            /* Disable the Main Ouput */
   1032            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_5:
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6A00             LDR      R0,[R0, #+32]
   \   00000064   0xF241 0x1111      MOVW     R1,#+4369
   \   00000068   0x4208             TST      R0,R1
   \   0000006A   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6A00             LDR      R0,[R0, #+32]
   \   00000070   0xF240 0x4144      MOVW     R1,#+1092
   \   00000074   0x4208             TST      R0,R1
   \   00000076   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6C40             LDR      R0,[R0, #+68]
   \   0000007C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000080   0x6821             LDR      R1,[R4, #+0]
   \   00000082   0x6448             STR      R0,[R1, #+68]
   1033          
   1034            /* Disable the Peripheral */
   1035            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_6:
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A00             LDR      R0,[R0, #+32]
   \   00000088   0xF241 0x1111      MOVW     R1,#+4369
   \   0000008C   0x4208             TST      R0,R1
   \   0000008E   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6A00             LDR      R0,[R0, #+32]
   \   00000094   0xF240 0x4144      MOVW     R1,#+1092
   \   00000098   0x4208             TST      R0,R1
   \   0000009A   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x0840             LSRS     R0,R0,#+1
   \   000000A2   0x0040             LSLS     R0,R0,#+1
   \   000000A4   0x6821             LDR      R1,[R4, #+0]
   \   000000A6   0x6008             STR      R0,[R1, #+0]
   1036          
   1037            /* Return function status */
   1038            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_IT_7:
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xBD10             POP      {R4,PC}          ;; return
   1039          }
   1040          
   1041          /**
   1042            * @brief  Starts the TIM PWM signal generation in DMA mode on the
   1043            *         complementary output
   1044            * @param  htim : TIM handle
   1045            * @param  Channel : TIM Channel to be enabled
   1046            *          This parameter can be one of the following values:
   1047            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1048            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1049            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1050            * @param  pData : The source Buffer address.
   1051            * @param  Length : The length of data to be transferred from memory to TIM peripheral
   1052            * @retval HAL status
   1053            */

   \                                 In section .text, align 2, keep-with-next
   1054          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1055          {
   \                     HAL_TIMEx_PWMN_Start_DMA:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0011             MOVS     R1,R2
   1056            /* Check the parameters */
   1057            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1058          
   1059            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_0
   1060            {
   1061               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE066             B.N      ??HAL_TIMEx_PWMN_Start_DMA_1
   1062            }
   1063            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_PWMN_Start_DMA_0:
   \   00000014   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD109             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_2
   1064            {
   1065              if(((uint32_t)pData == 0U) && (Length > 0U))
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD104             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_3
   \   00000020   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_3
   1066              {
   1067                return HAL_ERROR;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE05B             B.N      ??HAL_TIMEx_PWMN_Start_DMA_1
   1068              }
   1069              else
   1070              {
   1071                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_3:
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF884 0x003D      STRB     R0,[R4, #+61]
   1072              }
   1073            }
   1074            switch (Channel)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_2:
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_4
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xD019             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_5
   \   0000003A   0x2808             CMP      R0,#+8
   \   0000003C   0xD02B             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_6
   \   0000003E   0xE03E             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1075            {
   1076              case TIM_CHANNEL_1:
   1077              {
   1078                /* Set the DMA Period elapsed callback */
   1079                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_4:
   \   00000040   0x6A60             LDR      R0,[R4, #+36]
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable3_2
   \   00000046   0x6282             STR      R2,[R0, #+40]
   1080          
   1081                /* Set the DMA error callback */
   1082                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x6A60             LDR      R0,[R4, #+36]
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable3_1
   \   0000004E   0x6302             STR      R2,[R0, #+48]
   1083          
   1084                /* Enable the DMA channel */
   1085                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000050   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0xF110 0x0234      ADDS     R2,R0,#+52
   \   00000058   0x6A60             LDR      R0,[R4, #+36]
   \   0000005A   0x.... 0x....      BL       HAL_DMA_Start_IT
   1086          
   1087                /* Enable the TIM Capture/Compare 1 DMA request */
   1088                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0xF44F 0x7100      MOV      R1,#+512
   \   00000066   0x4308             ORRS     R0,R1,R0
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x60C8             STR      R0,[R1, #+12]
   1089              }
   1090              break;
   \   0000006C   0xE027             B.N      ??HAL_TIMEx_PWMN_Start_DMA_8
   1091          
   1092              case TIM_CHANNEL_2:
   1093              {
   1094                /* Set the DMA Period elapsed callback */
   1095                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_5:
   \   0000006E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000070   0x....             LDR.N    R2,??DataTable3_2
   \   00000072   0x6282             STR      R2,[R0, #+40]
   1096          
   1097                /* Set the DMA error callback */
   1098                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000074   0x6AA0             LDR      R0,[R4, #+40]
   \   00000076   0x....             LDR.N    R2,??DataTable3_1
   \   00000078   0x6302             STR      R2,[R0, #+48]
   1099          
   1100                /* Enable the DMA channel */
   1101                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   0000007A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0xF110 0x0238      ADDS     R2,R0,#+56
   \   00000082   0x6AA0             LDR      R0,[R4, #+40]
   \   00000084   0x.... 0x....      BL       HAL_DMA_Start_IT
   1102          
   1103                /* Enable the TIM Capture/Compare 2 DMA request */
   1104                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x68C0             LDR      R0,[R0, #+12]
   \   0000008C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x60C8             STR      R0,[R1, #+12]
   1105              }
   1106              break;
   \   00000094   0xE013             B.N      ??HAL_TIMEx_PWMN_Start_DMA_8
   1107          
   1108              case TIM_CHANNEL_3:
   1109              {
   1110                /* Set the DMA Period elapsed callback */
   1111                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_6:
   \   00000096   0x6AE0             LDR      R0,[R4, #+44]
   \   00000098   0x....             LDR.N    R2,??DataTable3_2
   \   0000009A   0x6282             STR      R2,[R0, #+40]
   1112          
   1113                /* Set the DMA error callback */
   1114                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   0000009C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000009E   0x....             LDR.N    R2,??DataTable3_1
   \   000000A0   0x6302             STR      R2,[R0, #+48]
   1115          
   1116                /* Enable the DMA channel */
   1117                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000A2   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0xF110 0x023C      ADDS     R2,R0,#+60
   \   000000AA   0x6AE0             LDR      R0,[R4, #+44]
   \   000000AC   0x.... 0x....      BL       HAL_DMA_Start_IT
   1118          
   1119                /* Enable the TIM Capture/Compare 3 DMA request */
   1120                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x68C0             LDR      R0,[R0, #+12]
   \   000000B4   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x60C8             STR      R0,[R1, #+12]
   1121              }
   1122              break;
   \   000000BC   0xE7FF             B.N      ??HAL_TIMEx_PWMN_Start_DMA_8
   1123          
   1124              default:
   1125              break;
   1126            }
   1127          
   1128            /* Enable the complementary PWM output  */
   1129            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_7:
   \                     ??HAL_TIMEx_PWMN_Start_DMA_8:
   \   000000BE   0x2204             MOVS     R2,#+4
   \   000000C0   0x0029             MOVS     R1,R5
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1130          
   1131            /* Enable the Main Ouput */
   1132            __HAL_TIM_MOE_ENABLE(htim);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6C40             LDR      R0,[R0, #+68]
   \   000000CC   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x6448             STR      R0,[R1, #+68]
   1133          
   1134            /* Enable the Peripheral */
   1135            __HAL_TIM_ENABLE(htim);
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000DC   0x6821             LDR      R1,[R4, #+0]
   \   000000DE   0x6008             STR      R0,[R1, #+0]
   1136          
   1137            /* Return function status */
   1138            return HAL_OK;
   \   000000E0   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_PWMN_Start_DMA_1:
   \   000000E2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1139          }
   1140          
   1141          /**
   1142            * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
   1143            *         output
   1144            * @param  htim : TIM handle
   1145            * @param  Channel : TIM Channel to be disabled
   1146            *          This parameter can be one of the following values:
   1147            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1148            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1149            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1150            * @retval HAL status
   1151            */

   \                                 In section .text, align 2, keep-with-next
   1152          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1153          {
   \                     HAL_TIMEx_PWMN_Stop_DMA:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1154            /* Check the parameters */
   1155            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1156          
   1157            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD004             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD009             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_1
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_2
   \   00000012   0xE014             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_3
   1158            {
   1159              case TIM_CHANNEL_1:
   1160              {
   1161                /* Disable the TIM Capture/Compare 1 DMA request */
   1162                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_0:
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF430 0x7000      BICS     R0,R0,#0x200
   \   0000001C   0x6822             LDR      R2,[R4, #+0]
   \   0000001E   0x60D0             STR      R0,[R2, #+12]
   1163              }
   1164              break;
   \   00000020   0xE00D             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1165          
   1166              case TIM_CHANNEL_2:
   1167              {
   1168                /* Disable the TIM Capture/Compare 2 DMA request */
   1169                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_1:
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C0             LDR      R0,[R0, #+12]
   \   00000026   0xF430 0x6080      BICS     R0,R0,#0x400
   \   0000002A   0x6822             LDR      R2,[R4, #+0]
   \   0000002C   0x60D0             STR      R0,[R2, #+12]
   1170              }
   1171              break;
   \   0000002E   0xE006             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1172          
   1173              case TIM_CHANNEL_3:
   1174              {
   1175                /* Disable the TIM Capture/Compare 3 DMA request */
   1176                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_2:
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68C0             LDR      R0,[R0, #+12]
   \   00000034   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000038   0x6822             LDR      R2,[R4, #+0]
   \   0000003A   0x60D0             STR      R0,[R2, #+12]
   1177              }
   1178              break;
   \   0000003C   0xE7FF             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1179          
   1180              default:
   1181              break;
   1182            }
   1183          
   1184            /* Disable the complementary PWM output */
   1185            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_3:
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_4:
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1186          
   1187            /* Disable the Main Ouput */
   1188            __HAL_TIM_MOE_DISABLE(htim);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6A00             LDR      R0,[R0, #+32]
   \   0000004A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000004E   0x4208             TST      R0,R1
   \   00000050   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6A00             LDR      R0,[R0, #+32]
   \   00000056   0xF240 0x4144      MOVW     R1,#+1092
   \   0000005A   0x4208             TST      R0,R1
   \   0000005C   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6C40             LDR      R0,[R0, #+68]
   \   00000062   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6448             STR      R0,[R1, #+68]
   1189          
   1190            /* Disable the Peripheral */
   1191            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_5:
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A00             LDR      R0,[R0, #+32]
   \   0000006E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000072   0x4208             TST      R0,R1
   \   00000074   0xD10B             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6A00             LDR      R0,[R0, #+32]
   \   0000007A   0xF240 0x4144      MOVW     R1,#+1092
   \   0000007E   0x4208             TST      R0,R1
   \   00000080   0xD105             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x0840             LSRS     R0,R0,#+1
   \   00000088   0x0040             LSLS     R0,R0,#+1
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   1192          
   1193            /* Change the htim state */
   1194            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_6:
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xF884 0x003D      STRB     R0,[R4, #+61]
   1195          
   1196            /* Return function status */
   1197            return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
   1198          }
   1199          
   1200          /**
   1201            * @}
   1202            */
   1203          
   1204          /** @defgroup TIMEx_Exported_Functions_Group4 Timer Complementary One Pulse functions
   1205           *  @brief    Timer Complementary One Pulse functions
   1206           *
   1207          @verbatim
   1208            ==============================================================================
   1209                          ##### Timer Complementary One Pulse functions #####
   1210            ==============================================================================
   1211            [..]
   1212              This section provides functions allowing to:
   1213              (+) Start the Complementary One Pulse generation.
   1214              (+) Stop the Complementary One Pulse.
   1215              (+) Start the Complementary One Pulse and enable interrupts.
   1216              (+) Stop the Complementary One Pulse and disable interrupts.
   1217          
   1218          @endverbatim
   1219            * @{
   1220            */
   1221          
   1222          /**
   1223            * @brief  Starts the TIM One Pulse signal generation on the complemetary
   1224            *         output.
   1225            * @param  htim : TIM One Pulse handle
   1226            * @param  OutputChannel : TIM Channel to be enabled
   1227            *          This parameter can be one of the following values:
   1228            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1229            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1230            * @retval HAL status
   1231            */

   \                                 In section .text, align 2, keep-with-next
   1232          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1233          {
   \                     HAL_TIMEx_OnePulseN_Start:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1234            /* Check the parameters */
   1235            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1236          
   1237            /* Enable the complementary One Pulse output */
   1238            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1239          
   1240            /* Enable the Main Ouput */
   1241            __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C40             LDR      R0,[R0, #+68]
   \   00000010   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000014   0x6821             LDR      R1,[R4, #+0]
   \   00000016   0x6448             STR      R0,[R1, #+68]
   1242          
   1243            /* Return function status */
   1244            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   1245          }
   1246          
   1247          /**
   1248            * @brief  Stops the TIM One Pulse signal generation on the complementary
   1249            *         output.
   1250            * @param  htim : TIM One Pulse handle
   1251            * @param  OutputChannel : TIM Channel to be disabled
   1252            *          This parameter can be one of the following values:
   1253            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1254            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1255            * @retval HAL status
   1256            */

   \                                 In section .text, align 2, keep-with-next
   1257          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1258          {
   \                     HAL_TIMEx_OnePulseN_Stop:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1259          
   1260            /* Check the parameters */
   1261            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1262          
   1263            /* Disable the complementary One Pulse output */
   1264            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1265          
   1266            /* Disable the Main Ouput */
   1267            __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6A00             LDR      R0,[R0, #+32]
   \   00000010   0xF241 0x1111      MOVW     R1,#+4369
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD10B             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6A00             LDR      R0,[R0, #+32]
   \   0000001C   0xF240 0x4144      MOVW     R1,#+1092
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6C40             LDR      R0,[R0, #+68]
   \   00000028   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6448             STR      R0,[R1, #+68]
   1268          
   1269            /* Disable the Peripheral */
   1270            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OnePulseN_Stop_0:
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6A00             LDR      R0,[R0, #+32]
   \   00000034   0xF241 0x1111      MOVW     R1,#+4369
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD10B             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6A00             LDR      R0,[R0, #+32]
   \   00000040   0xF240 0x4144      MOVW     R1,#+1092
   \   00000044   0x4208             TST      R0,R1
   \   00000046   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0840             LSRS     R0,R0,#+1
   \   0000004E   0x0040             LSLS     R0,R0,#+1
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6008             STR      R0,[R1, #+0]
   1271          
   1272            /* Return function status */
   1273            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_1:
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
   1274          }
   1275          
   1276          /**
   1277            * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
   1278            *         complementary channel.
   1279            * @param  htim : TIM One Pulse handle
   1280            * @param  OutputChannel : TIM Channel to be enabled
   1281            *          This parameter can be one of the following values:
   1282            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1283            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1284            * @retval HAL status
   1285            */

   \                                 In section .text, align 2, keep-with-next
   1286          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1287          {
   \                     HAL_TIMEx_OnePulseN_Start_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1288            /* Check the parameters */
   1289            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1290          
   1291            /* Enable the TIM Capture/Compare 1 interrupt */
   1292            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000C   0x6822             LDR      R2,[R4, #+0]
   \   0000000E   0x60D0             STR      R0,[R2, #+12]
   1293          
   1294            /* Enable the TIM Capture/Compare 2 interrupt */
   1295            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000018   0x6822             LDR      R2,[R4, #+0]
   \   0000001A   0x60D0             STR      R0,[R2, #+12]
   1296          
   1297            /* Enable the complementary One Pulse output */
   1298            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1299          
   1300            /* Enable the Main Ouput */
   1301            __HAL_TIM_MOE_ENABLE(htim);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6C40             LDR      R0,[R0, #+68]
   \   00000028   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6448             STR      R0,[R1, #+68]
   1302          
   1303            /* Return function status */
   1304            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   1305          }
   1306          
   1307          /**
   1308            * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
   1309            *         complementary channel.
   1310            * @param  htim : TIM One Pulse handle
   1311            * @param  OutputChannel : TIM Channel to be disabled
   1312            *          This parameter can be one of the following values:
   1313            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1314            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1315            * @retval HAL status
   1316            */

   \                                 In section .text, align 2, keep-with-next
   1317          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1318          {
   \                     HAL_TIMEx_OnePulseN_Stop_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1319            /* Check the parameters */
   1320            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1321          
   1322            /* Disable the TIM Capture/Compare 1 interrupt */
   1323            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000000C   0x6822             LDR      R2,[R4, #+0]
   \   0000000E   0x60D0             STR      R0,[R2, #+12]
   1324          
   1325            /* Disable the TIM Capture/Compare 2 interrupt */
   1326            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C0             LDR      R0,[R0, #+12]
   \   00000014   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000018   0x6822             LDR      R2,[R4, #+0]
   \   0000001A   0x60D0             STR      R0,[R2, #+12]
   1327          
   1328            /* Disable the complementary One Pulse output */
   1329            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1330          
   1331            /* Disable the Main Ouput */
   1332            __HAL_TIM_MOE_DISABLE(htim);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6A00             LDR      R0,[R0, #+32]
   \   00000028   0xF241 0x1111      MOVW     R1,#+4369
   \   0000002C   0x4208             TST      R0,R1
   \   0000002E   0xD10B             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6A00             LDR      R0,[R0, #+32]
   \   00000034   0xF240 0x4144      MOVW     R1,#+1092
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6C40             LDR      R0,[R0, #+68]
   \   00000040   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6448             STR      R0,[R1, #+68]
   1333          
   1334            /* Disable the Peripheral */
   1335            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_0:
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6A00             LDR      R0,[R0, #+32]
   \   0000004C   0xF241 0x1111      MOVW     R1,#+4369
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xD10B             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6A00             LDR      R0,[R0, #+32]
   \   00000058   0xF240 0x4144      MOVW     R1,#+1092
   \   0000005C   0x4208             TST      R0,R1
   \   0000005E   0xD105             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x0840             LSRS     R0,R0,#+1
   \   00000066   0x0040             LSLS     R0,R0,#+1
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   1336          
   1337            /* Return function status */
   1338            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_1:
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
   1339          }
   1340          
   1341          /**
   1342            * @}
   1343            */
   1344          
   1345          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
   1346                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
   1347                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
   1348          
   1349          /** @defgroup TIMEx_Exported_Functions_Group5 Peripheral Control functions
   1350           *  @brief    Peripheral Control functions
   1351           *
   1352          @verbatim
   1353            ==============================================================================
   1354                              ##### Peripheral Control functions #####
   1355            ==============================================================================
   1356            [..]
   1357              This section provides functions allowing to:
   1358              (+) Configure the commutation event in case of use of the Hall sensor interface.
   1359                (+) Configure Complementary channels, break features and dead time.
   1360                (+) Configure Master synchronization.
   1361          
   1362          @endverbatim
   1363            * @{
   1364            */
   1365          
   1366          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
   1367              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
   1368              defined (STM32F105xC) || defined (STM32F107xC)
   1369          
   1370          /**
   1371            * @brief  Configure the TIM commutation event sequence.
   1372            * @note: this function is mandatory to use the commutation event in order to
   1373            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1374            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1375            *        configured in Hall sensor interface, this interface Timer will generate the
   1376            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1377            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1378            * @param  htim : TIM handle
   1379            * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1380            *          This parameter can be one of the following values:
   1381            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1382            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1383            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1384            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1385            *            @arg TIM_TS_NONE: No trigger is needed
   1386            * @param  CommutationSource : the Commutation Event source
   1387            *          This parameter can be one of the following values:
   1388            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1389            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1390            * @retval HAL status
   1391            */

   \                                 In section .text, align 2, keep-with-next
   1392          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1393          {
   \                     HAL_TIMEx_ConfigCommutationEvent:
   \   00000000   0xB410             PUSH     {R4}
   1394            /* Check the parameters */
   1395            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1396            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1397          
   1398            __HAL_LOCK(htim);
   \   00000002   0xF890 0x303C      LDRB     R3,[R0, #+60]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE02A             B.N      ??HAL_TIMEx_ConfigCommutationEvent_1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_0:
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x303C      STRB     R3,[R0, #+60]
   1399          
   1400            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1401                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
   \   00000018   0x2910             CMP      R1,#+16
   \   0000001A   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
   \   0000001C   0x2920             CMP      R1,#+32
   \   0000001E   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_2
   \   00000020   0x2930             CMP      R1,#+48
   \   00000022   0xD10A             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_3
   1402            {
   1403              /* Select the Input trigger */
   1404              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_2:
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x689B             LDR      R3,[R3, #+8]
   \   00000028   0xF033 0x0370      BICS     R3,R3,#0x70
   \   0000002C   0x6804             LDR      R4,[R0, #+0]
   \   0000002E   0x60A3             STR      R3,[R4, #+8]
   1405              htim->Instance->SMCR |= InputTrigger;
   \   00000030   0x6803             LDR      R3,[R0, #+0]
   \   00000032   0x689B             LDR      R3,[R3, #+8]
   \   00000034   0x4319             ORRS     R1,R1,R3
   \   00000036   0x6803             LDR      R3,[R0, #+0]
   \   00000038   0x6099             STR      R1,[R3, #+8]
   1406            }
   1407          
   1408            /* Select the Capture Compare preload feature */
   1409            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_3:
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x6849             LDR      R1,[R1, #+4]
   \   0000003E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000042   0x6803             LDR      R3,[R0, #+0]
   \   00000044   0x6059             STR      R1,[R3, #+4]
   1410            /* Select the Commutation event source */
   1411            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x6849             LDR      R1,[R1, #+4]
   \   0000004A   0xF031 0x0104      BICS     R1,R1,#0x4
   \   0000004E   0x6803             LDR      R3,[R0, #+0]
   \   00000050   0x6059             STR      R1,[R3, #+4]
   1412            htim->Instance->CR2 |= CommutationSource;
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x6849             LDR      R1,[R1, #+4]
   \   00000056   0x4311             ORRS     R1,R2,R1
   \   00000058   0x6802             LDR      R2,[R0, #+0]
   \   0000005A   0x6051             STR      R1,[R2, #+4]
   1413          
   1414            __HAL_UNLOCK(htim);
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0xF880 0x103C      STRB     R1,[R0, #+60]
   1415          
   1416            return HAL_OK;
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutationEvent_1:
   \   00000064   0xBC10             POP      {R4}
   \   00000066   0x4770             BX       LR               ;; return
   1417          }
   1418          
   1419          /**
   1420            * @brief  Configure the TIM commutation event sequence with interrupt.
   1421            * @note: this function is mandatory to use the commutation event in order to
   1422            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1423            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1424            *        configured in Hall sensor interface, this interface Timer will generate the
   1425            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1426            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1427            * @param  htim : TIM handle
   1428            * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1429            *          This parameter can be one of the following values:
   1430            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1431            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1432            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1433            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1434            *            @arg TIM_TS_NONE: No trigger is needed
   1435            * @param  CommutationSource : the Commutation Event source
   1436            *          This parameter can be one of the following values:
   1437            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1438            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1439            * @retval HAL status
   1440            */

   \                                 In section .text, align 2, keep-with-next
   1441          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1442          {
   \                     HAL_TIMEx_ConfigCommutationEvent_IT:
   \   00000000   0xB410             PUSH     {R4}
   1443            /* Check the parameters */
   1444            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1445            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1446          
   1447            __HAL_LOCK(htim);
   \   00000002   0xF890 0x303C      LDRB     R3,[R0, #+60]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE030             B.N      ??HAL_TIMEx_ConfigCommutationEvent_IT_1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_0:
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x303C      STRB     R3,[R0, #+60]
   1448          
   1449            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1450                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
   \   00000018   0x2910             CMP      R1,#+16
   \   0000001A   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
   \   0000001C   0x2920             CMP      R1,#+32
   \   0000001E   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_2
   \   00000020   0x2930             CMP      R1,#+48
   \   00000022   0xD10A             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_3
   1451            {
   1452              /* Select the Input trigger */
   1453              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_2:
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x689B             LDR      R3,[R3, #+8]
   \   00000028   0xF033 0x0370      BICS     R3,R3,#0x70
   \   0000002C   0x6804             LDR      R4,[R0, #+0]
   \   0000002E   0x60A3             STR      R3,[R4, #+8]
   1454              htim->Instance->SMCR |= InputTrigger;
   \   00000030   0x6803             LDR      R3,[R0, #+0]
   \   00000032   0x689B             LDR      R3,[R3, #+8]
   \   00000034   0x4319             ORRS     R1,R1,R3
   \   00000036   0x6803             LDR      R3,[R0, #+0]
   \   00000038   0x6099             STR      R1,[R3, #+8]
   1455            }
   1456          
   1457            /* Select the Capture Compare preload feature */
   1458            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_3:
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x6849             LDR      R1,[R1, #+4]
   \   0000003E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000042   0x6803             LDR      R3,[R0, #+0]
   \   00000044   0x6059             STR      R1,[R3, #+4]
   1459            /* Select the Commutation event source */
   1460            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x6849             LDR      R1,[R1, #+4]
   \   0000004A   0xF031 0x0104      BICS     R1,R1,#0x4
   \   0000004E   0x6803             LDR      R3,[R0, #+0]
   \   00000050   0x6059             STR      R1,[R3, #+4]
   1461            htim->Instance->CR2 |= CommutationSource;
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x6849             LDR      R1,[R1, #+4]
   \   00000056   0x4311             ORRS     R1,R2,R1
   \   00000058   0x6802             LDR      R2,[R0, #+0]
   \   0000005A   0x6051             STR      R1,[R2, #+4]
   1462          
   1463            /* Enable the Commutation Interrupt Request */
   1464            __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x68C9             LDR      R1,[R1, #+12]
   \   00000060   0xF051 0x0120      ORRS     R1,R1,#0x20
   \   00000064   0x6802             LDR      R2,[R0, #+0]
   \   00000066   0x60D1             STR      R1,[R2, #+12]
   1465          
   1466            __HAL_UNLOCK(htim);
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0xF880 0x103C      STRB     R1,[R0, #+60]
   1467          
   1468            return HAL_OK;
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_1:
   \   00000070   0xBC10             POP      {R4}
   \   00000072   0x4770             BX       LR               ;; return
   1469          }
   1470          
   1471          /**
   1472            * @brief  Configure the TIM commutation event sequence with DMA.
   1473            * @note: this function is mandatory to use the commutation event in order to
   1474            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1475            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1476            *        configured in Hall sensor interface, this interface Timer will generate the
   1477            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1478            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1479            * @note: The user should configure the DMA in his own software, in This function only the COMDE bit is set
   1480            * @param  htim : TIM handle
   1481            * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1482            *          This parameter can be one of the following values:
   1483            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1484            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1485            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1486            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1487            *            @arg TIM_TS_NONE: No trigger is needed
   1488            * @param  CommutationSource : the Commutation Event source
   1489            *          This parameter can be one of the following values:
   1490            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1491            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1492            * @retval HAL status
   1493            */

   \                                 In section .text, align 2, keep-with-next
   1494          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1495          {
   \                     HAL_TIMEx_ConfigCommutationEvent_DMA:
   \   00000000   0xB410             PUSH     {R4}
   1496            /* Check the parameters */
   1497            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1498            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1499          
   1500            __HAL_LOCK(htim);
   \   00000002   0xF890 0x303C      LDRB     R3,[R0, #+60]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE037             B.N      ??HAL_TIMEx_ConfigCommutationEvent_DMA_1
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_0:
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x303C      STRB     R3,[R0, #+60]
   1501          
   1502            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1503                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
   \   00000018   0x2910             CMP      R1,#+16
   \   0000001A   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
   \   0000001C   0x2920             CMP      R1,#+32
   \   0000001E   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_2
   \   00000020   0x2930             CMP      R1,#+48
   \   00000022   0xD10A             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_3
   1504            {
   1505              /* Select the Input trigger */
   1506              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_2:
   \   00000024   0x6803             LDR      R3,[R0, #+0]
   \   00000026   0x689B             LDR      R3,[R3, #+8]
   \   00000028   0xF033 0x0370      BICS     R3,R3,#0x70
   \   0000002C   0x6804             LDR      R4,[R0, #+0]
   \   0000002E   0x60A3             STR      R3,[R4, #+8]
   1507              htim->Instance->SMCR |= InputTrigger;
   \   00000030   0x6803             LDR      R3,[R0, #+0]
   \   00000032   0x689B             LDR      R3,[R3, #+8]
   \   00000034   0x4319             ORRS     R1,R1,R3
   \   00000036   0x6803             LDR      R3,[R0, #+0]
   \   00000038   0x6099             STR      R1,[R3, #+8]
   1508            }
   1509          
   1510            /* Select the Capture Compare preload feature */
   1511            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_3:
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x6849             LDR      R1,[R1, #+4]
   \   0000003E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000042   0x6803             LDR      R3,[R0, #+0]
   \   00000044   0x6059             STR      R1,[R3, #+4]
   1512            /* Select the Commutation event source */
   1513            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x6849             LDR      R1,[R1, #+4]
   \   0000004A   0xF031 0x0104      BICS     R1,R1,#0x4
   \   0000004E   0x6803             LDR      R3,[R0, #+0]
   \   00000050   0x6059             STR      R1,[R3, #+4]
   1514            htim->Instance->CR2 |= CommutationSource;
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x6849             LDR      R1,[R1, #+4]
   \   00000056   0x4311             ORRS     R1,R2,R1
   \   00000058   0x6802             LDR      R2,[R0, #+0]
   \   0000005A   0x6051             STR      R1,[R2, #+4]
   1515          
   1516            /* Enable the Commutation DMA Request */
   1517            /* Set the DMA Commutation Callback */
   1518            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   \   0000005C   0x6B41             LDR      R1,[R0, #+52]
   \   0000005E   0x.... 0x....      ADR.W    R2,TIMEx_DMACommutationCplt
   \   00000062   0x628A             STR      R2,[R1, #+40]
   1519            /* Set the DMA error callback */
   1520            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
   \   00000064   0x6B41             LDR      R1,[R0, #+52]
   \   00000066   0x....             LDR.N    R2,??DataTable3_1
   \   00000068   0x630A             STR      R2,[R1, #+48]
   1521          
   1522            /* Enable the Commutation DMA Request */
   1523            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x68C9             LDR      R1,[R1, #+12]
   \   0000006E   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \   00000072   0x6802             LDR      R2,[R0, #+0]
   \   00000074   0x60D1             STR      R1,[R2, #+12]
   1524          
   1525            __HAL_UNLOCK(htim);
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0xF880 0x103C      STRB     R1,[R0, #+60]
   1526          
   1527            return HAL_OK;
   \   0000007C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_1:
   \   0000007E   0xBC10             POP      {R4}
   \   00000080   0x4770             BX       LR               ;; return
   1528          }
   1529          
   1530          /**
   1531            * @brief   Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   1532            *          and the AOE(automatic output enable).
   1533            * @param  htim : TIM handle
   1534            * @param  sBreakDeadTimeConfig : pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that
   1535            *         contains the BDTR Register configuration  information for the TIM peripheral.
   1536            * @retval HAL status
   1537            */

   \                                 In section .text, align 2, keep-with-next
   1538          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
   1539                                                          TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
   1540          {
   1541            uint32_t tmpbdtr = 0U;
   \                     HAL_TIMEx_ConfigBreakDeadTime:
   \   00000000   0x2200             MOVS     R2,#+0
   1542          
   1543            /* Check the parameters */
   1544            assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
   1545            assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
   1546            assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
   1547            assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
   1548            assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
   1549            assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
   1550            assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
   1551            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
   1552          
   1553            /* Process Locked */
   1554            __HAL_LOCK(htim);
   \   00000002   0xF890 0x303C      LDRB     R3,[R0, #+60]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIMEx_ConfigBreakDeadTime_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE028             B.N      ??HAL_TIMEx_ConfigBreakDeadTime_1
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_0:
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x303C      STRB     R3,[R0, #+60]
   1555          
   1556            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   1557               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   1558          
   1559            /* Set the BDTR bits */
   1560            MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
   \   00000014   0x0A12             LSRS     R2,R2,#+8
   \   00000016   0x0212             LSLS     R2,R2,#+8
   \   00000018   0x68CB             LDR      R3,[R1, #+12]
   \   0000001A   0x431A             ORRS     R2,R3,R2
   1561            MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
   \   0000001C   0xF432 0x7240      BICS     R2,R2,#0x300
   \   00000020   0x688B             LDR      R3,[R1, #+8]
   \   00000022   0x431A             ORRS     R2,R3,R2
   1562            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
   \   00000024   0xF432 0x6280      BICS     R2,R2,#0x400
   \   00000028   0x684B             LDR      R3,[R1, #+4]
   \   0000002A   0x431A             ORRS     R2,R3,R2
   1563            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
   \   0000002C   0xF432 0x6200      BICS     R2,R2,#0x800
   \   00000030   0x680B             LDR      R3,[R1, #+0]
   \   00000032   0x431A             ORRS     R2,R3,R2
   1564            MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
   \   00000034   0xF432 0x5280      BICS     R2,R2,#0x1000
   \   00000038   0x690B             LDR      R3,[R1, #+16]
   \   0000003A   0x431A             ORRS     R2,R3,R2
   1565            MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
   \   0000003C   0xF432 0x5200      BICS     R2,R2,#0x2000
   \   00000040   0x694B             LDR      R3,[R1, #+20]
   \   00000042   0x431A             ORRS     R2,R3,R2
   1566            MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
   \   00000044   0xF432 0x4280      BICS     R2,R2,#0x4000
   \   00000048   0x698B             LDR      R3,[R1, #+24]
   \   0000004A   0x431A             ORRS     R2,R3,R2
   1567            MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
   \   0000004C   0xF432 0x4200      BICS     R2,R2,#0x8000
   \   00000050   0x6989             LDR      R1,[R1, #+24]
   \   00000052   0x430A             ORRS     R2,R1,R2
   1568          
   1569            /* Set TIMx_BDTR */
   1570            htim->Instance->BDTR = tmpbdtr;
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x644A             STR      R2,[R1, #+68]
   1571          
   1572            __HAL_UNLOCK(htim);
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0xF880 0x103C      STRB     R1,[R0, #+60]
   1573          
   1574            return HAL_OK;
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_1:
   \   00000060   0x4770             BX       LR               ;; return
   1575          }
   1576          
   1577          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
   1578                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
   1579                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
   1580          
   1581          /**
   1582            * @brief  Configures the TIM in master mode.
   1583            * @param  htim : TIM handle.
   1584            * @param  sMasterConfig : pointer to a TIM_MasterConfigTypeDef structure that
   1585            *         contains the selected trigger output (TRGO) and the Master/Slave
   1586            *         mode.
   1587            * @retval HAL status
   1588            */

   \                                 In section .text, align 2, keep-with-next
   1589          HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
   1590          {
   1591            /* Check the parameters */
   1592            assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   1593            assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   1594            assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   1595          
   1596            __HAL_LOCK(htim);
   \                     HAL_TIMEx_MasterConfigSynchronization:
   \   00000000   0xF890 0x203C      LDRB     R2,[R0, #+60]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIMEx_MasterConfigSynchronization_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xE024             B.N      ??HAL_TIMEx_MasterConfigSynchronization_1
   \                     ??HAL_TIMEx_MasterConfigSynchronization_0:
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x203C      STRB     R2,[R0, #+60]
   1597          
   1598            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x203D      STRB     R2,[R0, #+61]
   1599          
   1600            /* Reset the MMS Bits */
   1601            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6852             LDR      R2,[R2, #+4]
   \   0000001C   0xF032 0x0270      BICS     R2,R2,#0x70
   \   00000020   0x6803             LDR      R3,[R0, #+0]
   \   00000022   0x605A             STR      R2,[R3, #+4]
   1602            /* Select the TRGO source */
   1603            htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
   \   00000024   0x6802             LDR      R2,[R0, #+0]
   \   00000026   0x6852             LDR      R2,[R2, #+4]
   \   00000028   0x680B             LDR      R3,[R1, #+0]
   \   0000002A   0x431A             ORRS     R2,R3,R2
   \   0000002C   0x6803             LDR      R3,[R0, #+0]
   \   0000002E   0x605A             STR      R2,[R3, #+4]
   1604          
   1605            /* Reset the MSM Bit */
   1606            htim->Instance->SMCR &= ~TIM_SMCR_MSM;
   \   00000030   0x6802             LDR      R2,[R0, #+0]
   \   00000032   0x6892             LDR      R2,[R2, #+8]
   \   00000034   0xF032 0x0280      BICS     R2,R2,#0x80
   \   00000038   0x6803             LDR      R3,[R0, #+0]
   \   0000003A   0x609A             STR      R2,[R3, #+8]
   1607            /* Set or Reset the MSM Bit */
   1608            htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
   \   0000003C   0x6802             LDR      R2,[R0, #+0]
   \   0000003E   0x6892             LDR      R2,[R2, #+8]
   \   00000040   0x6849             LDR      R1,[R1, #+4]
   \   00000042   0x4311             ORRS     R1,R1,R2
   \   00000044   0x6802             LDR      R2,[R0, #+0]
   \   00000046   0x6091             STR      R1,[R2, #+8]
   1609          
   1610            htim->State = HAL_TIM_STATE_READY;
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0xF880 0x103D      STRB     R1,[R0, #+61]
   1611          
   1612            __HAL_UNLOCK(htim);
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0xF880 0x103C      STRB     R1,[R0, #+60]
   1613          
   1614            return HAL_OK;
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_MasterConfigSynchronization_1:
   \   00000056   0x4770             BX       LR               ;; return
   1615          }
   1616          
   1617          /**
   1618            * @}
   1619            */
   1620          
   1621          /** @defgroup TIMEx_Exported_Functions_Group6 Extension Callbacks functions
   1622           *  @brief   Extension Callbacks functions
   1623           *
   1624          @verbatim
   1625            ==============================================================================
   1626                              ##### Extension Callbacks functions #####
   1627            ==============================================================================
   1628            [..]
   1629              This section provides Extension TIM callback functions:
   1630              (+) Timer Commutation callback
   1631              (+) Timer Break callback
   1632          
   1633          @endverbatim
   1634            * @{
   1635            */
   1636          
   1637          /**
   1638            * @brief  Hall commutation changed callback in non blocking mode
   1639            * @param  htim : TIM handle
   1640            * @retval None
   1641            */

   \                                 In section .text, align 2, keep-with-next
   1642          __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
   1643          {
   1644            /* Prevent unused argument(s) compilation warning */
   1645            UNUSED(htim);
   1646            /* NOTE : This function Should not be modified, when the callback is needed,
   1647                      the HAL_TIMEx_CommutationCallback could be implemented in the user file
   1648             */
   1649          }
   \                     HAL_TIMEx_CommutationCallback:
   \   00000000   0x4770             BX       LR               ;; return
   1650          
   1651          /**
   1652            * @brief  Hall Break detection callback in non blocking mode
   1653            * @param  htim : TIM handle
   1654            * @retval None
   1655            */

   \                                 In section .text, align 2, keep-with-next
   1656          __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
   1657          {
   1658            /* Prevent unused argument(s) compilation warning */
   1659            UNUSED(htim);
   1660            /* NOTE : This function Should not be modified, when the callback is needed,
   1661                      the HAL_TIMEx_BreakCallback could be implemented in the user file
   1662             */
   1663          }
   \                     HAL_TIMEx_BreakCallback:
   \   00000000   0x4770             BX       LR               ;; return
   1664          
   1665          /**
   1666            * @brief  TIM DMA Commutation callback.
   1667            * @param  hdma : pointer to DMA handle.
   1668            * @retval None
   1669            */

   \                                 In section .text, align 4, keep-with-next
   1670          void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
   1671          {
   \                     TIMEx_DMACommutationCplt:
   \   00000000   0xB580             PUSH     {R7,LR}
   1672            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A40             LDR      R0,[R0, #+36]
   1673          
   1674            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF880 0x103D      STRB     R1,[R0, #+61]
   1675          
   1676            HAL_TIMEx_CommutationCallback(htim);
   \   0000000A   0x.... 0x....      BL       HAL_TIMEx_CommutationCallback
   1677          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   1678          
   1679          /**
   1680            * @}
   1681            */
   1682          
   1683          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
   1684              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
   1685              defined (STM32F105xC) || defined (STM32F107xC)
   1686          
   1687          /** @defgroup TIMEx_Exported_Functions_Group7 Extension Peripheral State functions
   1688           *  @brief   Extension Peripheral State functions
   1689           *
   1690          @verbatim
   1691            ==============================================================================
   1692                          ##### Extension Peripheral State functions #####
   1693            ==============================================================================
   1694            [..]
   1695              This subsection permit to get in run-time the status of the peripheral
   1696              and the data flow.
   1697          
   1698          @endverbatim
   1699            * @{
   1700            */
   1701          
   1702          /**
   1703            * @brief  Return the TIM Hall Sensor interface state
   1704            * @param  htim : TIM Hall Sensor handle
   1705            * @retval HAL state
   1706            */

   \                                 In section .text, align 2, keep-with-next
   1707          HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
   1708          {
   1709            return htim->State;
   \                     HAL_TIMEx_HallSensor_GetState:
   \   00000000   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000004   0x4770             BX       LR               ;; return
   1710          }
   1711          
   1712          /**
   1713            * @}
   1714            */
   1715          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
   1716                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
   1717                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
   1718          
   1719          /**
   1720            * @}
   1721            */
   1722          
   1723          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
   1724              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
   1725              defined (STM32F105xC) || defined (STM32F107xC)
   1726          
   1727          /** @addtogroup TIMEx_Private_Functions
   1728            * @{
   1729            */
   1730          
   1731          /**
   1732            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1733            * @param  TIMx  to select the TIM peripheral
   1734            * @param  Channel : specifies the TIM Channel
   1735            *          This parameter can be one of the following values:
   1736            *            @arg TIM_Channel_1: TIM Channel 1
   1737            *            @arg TIM_Channel_2: TIM Channel 2
   1738            *            @arg TIM_Channel_3: TIM Channel 3
   1739            * @param  ChannelNState : specifies the TIM Channel CCxNE bit new state.
   1740            *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
   1741            * @retval None
   1742            */

   \                                 In section .text, align 2, keep-with-next
   1743          static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
   1744          {
   \                     TIM_CCxNChannelCmd:
   \   00000000   0xB410             PUSH     {R4}
   1745            uint32_t tmp = 0U;
   \   00000002   0x2300             MOVS     R3,#+0
   1746          
   1747            tmp = TIM_CCER_CC1NE << Channel;
   \   00000004   0x2404             MOVS     R4,#+4
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x0023             MOVS     R3,R4
   1748          
   1749            /* Reset the CCxNE Bit */
   1750            TIMx->CCER &=  ~tmp;
   \   0000000A   0x6A04             LDR      R4,[R0, #+32]
   \   0000000C   0xEA34 0x0303      BICS     R3,R4,R3
   \   00000010   0x6203             STR      R3,[R0, #+32]
   1751          
   1752            /* Set or reset the CCxNE Bit */
   1753            TIMx->CCER |=  (uint32_t)(ChannelNState << Channel);
   \   00000012   0x6A03             LDR      R3,[R0, #+32]
   \   00000014   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000018   0x4319             ORRS     R1,R1,R3
   \   0000001A   0x6201             STR      R1,[R0, #+32]
   1754          }
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt
   1755          
   1756          /**
   1757            * @}
   1758            */
   1759          
   1760          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
   1761                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
   1762                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
   1763          
   1764          #endif /* HAL_TIM_MODULE_ENABLED */
   1765          /**
   1766            * @}
   1767            */
   1768          
   1769          /**
   1770            * @}
   1771            */
   1772          
   1773          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  HAL_TIMEx_BreakCallback
        0  HAL_TIMEx_CommutationCallback
        0  HAL_TIMEx_ConfigBreakDeadTime
        4  HAL_TIMEx_ConfigCommutationEvent
        4  HAL_TIMEx_ConfigCommutationEvent_DMA
        4  HAL_TIMEx_ConfigCommutationEvent_IT
        8  HAL_TIMEx_HallSensor_DeInit
              8 -> HAL_TIMEx_HallSensor_MspDeInit
        0  HAL_TIMEx_HallSensor_GetState
       40  HAL_TIMEx_HallSensor_Init
             40 -> HAL_TIMEx_HallSensor_MspInit
             40 -> TIM_Base_SetConfig
             40 -> TIM_OC2_SetConfig
             40 -> TIM_TI1_SetConfig
        0  HAL_TIMEx_HallSensor_MspDeInit
        0  HAL_TIMEx_HallSensor_MspInit
        8  HAL_TIMEx_HallSensor_Start
              8 -> TIM_CCxChannelCmd
       16  HAL_TIMEx_HallSensor_Start_DMA
             16 -> HAL_DMA_Start_IT
             16 -> TIM_CCxChannelCmd
        8  HAL_TIMEx_HallSensor_Start_IT
              8 -> TIM_CCxChannelCmd
        8  HAL_TIMEx_HallSensor_Stop
              8 -> TIM_CCxChannelCmd
        8  HAL_TIMEx_HallSensor_Stop_DMA
              8 -> TIM_CCxChannelCmd
        8  HAL_TIMEx_HallSensor_Stop_IT
              8 -> TIM_CCxChannelCmd
        0  HAL_TIMEx_MasterConfigSynchronization
        8  HAL_TIMEx_OCN_Start
              8 -> TIM_CCxNChannelCmd
       16  HAL_TIMEx_OCN_Start_DMA
             16 -> HAL_DMA_Start_IT
             16 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_OCN_Start_IT
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_OCN_Stop
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_OCN_Stop_DMA
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_OCN_Stop_IT
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_OnePulseN_Start
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_OnePulseN_Start_IT
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_OnePulseN_Stop
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_OnePulseN_Stop_IT
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_PWMN_Start
              8 -> TIM_CCxNChannelCmd
       16  HAL_TIMEx_PWMN_Start_DMA
             16 -> HAL_DMA_Start_IT
             16 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_PWMN_Start_IT
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_PWMN_Stop
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_PWMN_Stop_DMA
              8 -> TIM_CCxNChannelCmd
        8  HAL_TIMEx_PWMN_Stop_IT
              8 -> TIM_CCxNChannelCmd
        8  TIMEx_DMACommutationCplt
              8 -> HAL_TIMEx_CommutationCallback
        4  TIM_CCxNChannelCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       2  HAL_TIMEx_BreakCallback
       2  HAL_TIMEx_CommutationCallback
      98  HAL_TIMEx_ConfigBreakDeadTime
     104  HAL_TIMEx_ConfigCommutationEvent
     130  HAL_TIMEx_ConfigCommutationEvent_DMA
     116  HAL_TIMEx_ConfigCommutationEvent_IT
      68  HAL_TIMEx_HallSensor_DeInit
       6  HAL_TIMEx_HallSensor_GetState
     218  HAL_TIMEx_HallSensor_Init
       2  HAL_TIMEx_HallSensor_MspDeInit
       2  HAL_TIMEx_HallSensor_MspInit
      30  HAL_TIMEx_HallSensor_Start
     122  HAL_TIMEx_HallSensor_Start_DMA
      42  HAL_TIMEx_HallSensor_Start_IT
      54  HAL_TIMEx_HallSensor_Stop
      66  HAL_TIMEx_HallSensor_Stop_DMA
      66  HAL_TIMEx_HallSensor_Stop_IT
      88  HAL_TIMEx_MasterConfigSynchronization
      40  HAL_TIMEx_OCN_Start
     236  HAL_TIMEx_OCN_Start_DMA
     110  HAL_TIMEx_OCN_Start_IT
      88  HAL_TIMEx_OCN_Stop
     152  HAL_TIMEx_OCN_Stop_DMA
     172  HAL_TIMEx_OCN_Stop_IT
      28  HAL_TIMEx_OnePulseN_Start
      52  HAL_TIMEx_OnePulseN_Start_IT
      88  HAL_TIMEx_OnePulseN_Stop
     112  HAL_TIMEx_OnePulseN_Stop_IT
      40  HAL_TIMEx_PWMN_Start
     228  HAL_TIMEx_PWMN_Start_DMA
     110  HAL_TIMEx_PWMN_Start_IT
      88  HAL_TIMEx_PWMN_Stop
     152  HAL_TIMEx_PWMN_Stop_DMA
     172  HAL_TIMEx_PWMN_Stop_IT
      16  TIMEx_DMACommutationCplt
      32  TIM_CCxNChannelCmd

 
 3 144 bytes in section .text
 
 3 144 bytes of CODE memory

Errors: none
Warnings: 1
