###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  06:16:05 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1 #
#                    xx_HAL_Driver\Src\stm32f1xx_hal_gpio.c                   #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F #
#                    1xx_HAL_Driver\Src\stm32f1xx_hal_gpio.c" -D              #
#                    USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F103xB -lC  #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    List\" -o "D:\projects\задания от                        #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/Obj\" --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\stm32f1xx_hal_gpio.lst                               #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\stm32f1xx_hal_gpio.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                              ##### GPIO Peripheral features #####
     14            ==============================================================================
     15            [..]
     16            Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each
     17            port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software
     18            in several modes:
     19            (+) Input mode
     20            (+) Analog mode
     21            (+) Output mode
     22            (+) Alternate function mode
     23            (+) External interrupt/event lines
     24          
     25            [..]
     26            During and just after reset, the alternate functions and external interrupt
     27            lines are not active and the I/O ports are configured in input floating mode.
     28          
     29            [..]
     30            All GPIO pins have weak internal pull-up and pull-down resistors, which can be
     31            activated or not.
     32          
     33            [..]
     34            In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     35            type and the IO speed can be selected depending on the VDD value.
     36          
     37            [..]
     38            All ports have external interrupt/event capability. To use external interrupt
     39            lines, the port must be configured in input mode. All available GPIO pins are
     40            connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     41          
     42            [..]
     43            The external interrupt/event controller consists of up to 20 edge detectors in connectivity
     44            line devices, or 19 edge detectors in other devices for generating event/interrupt requests.
     45            Each input line can be independently configured to select the type (event or interrupt) and
     46            the corresponding trigger event (rising or falling or both). Each line can also masked
     47            independently. A pending register maintains the status line of the interrupt requests
     48          
     49                               ##### How to use this driver #####
     50            ==============================================================================
     51           [..]
     52             (#) Enable the GPIO APB2 clock using the following function : __HAL_RCC_GPIOx_CLK_ENABLE().
     53          
     54             (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     55                 (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     56                 (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef
     57                      structure.
     58                 (++) In case of Output or alternate function mode selection: the speed is
     59                      configured through "Speed" member from GPIO_InitTypeDef structure
     60                 (++) Analog mode is required when a pin is to be used as ADC channel
     61                      or DAC output.
     62                 (++) In case of external interrupt/event selection the "Mode" member from
     63                      GPIO_InitTypeDef structure select the type (interrupt or event) and
     64                      the corresponding trigger event (rising or falling or both).
     65          
     66             (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority
     67                 mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     68                 HAL_NVIC_EnableIRQ().
     69          
     70             (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     71          
     72             (#) To set/reset the level of a pin configured in output mode use
     73                 HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     74          
     75             (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     76          
     77             (#) During and just after reset, the alternate functions are not
     78                 active and the GPIO pins are configured in input floating mode (except JTAG
     79                 pins).
     80          
     81             (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose
     82                 (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has
     83                 priority over the GPIO function.
     84          
     85             (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as
     86                 general purpose PD0 and PD1, respectively, when the HSE oscillator is off.
     87                 The HSE has priority over the GPIO function.
     88          
     89            @endverbatim
     90            ******************************************************************************
     91            * @attention
     92            *
     93            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     94            *
     95            * Redistribution and use in source and binary forms, with or without modification,
     96            * are permitted provided that the following conditions are met:
     97            *   1. Redistributions of source code must retain the above copyright notice,
     98            *      this list of conditions and the following disclaimer.
     99            *   2. Redistributions in binary form must reproduce the above copyright notice,
    100            *      this list of conditions and the following disclaimer in the documentation
    101            *      and/or other materials provided with the distribution.
    102            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    103            *      may be used to endorse or promote products derived from this software
    104            *      without specific prior written permission.
    105            *
    106            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    107            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    108            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    109            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    110            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    111            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    112            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    113            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    114            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    115            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    116            *
    117            ******************************************************************************
    118            */
    119          
    120          /* Includes ------------------------------------------------------------------*/
    121          #include "stm32f1xx_hal.h"

  /**
    ^
"D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal.h",1  Warning[Pa050]: 
          non-native end of line sequence detected (this diagnostic is only
          issued once)
    122          
    123          /** @addtogroup STM32F1xx_HAL_Driver
    124            * @{
    125            */
    126          
    127          /** @defgroup GPIO GPIO
    128            * @brief GPIO HAL module driver
    129            * @{
    130            */
    131          
    132          #ifdef HAL_GPIO_MODULE_ENABLED
    133          
    134          /* Private typedef -----------------------------------------------------------*/
    135          /* Private define ------------------------------------------------------------*/
    136          /** @addtogroup GPIO_Private_Constants GPIO Private Constants
    137            * @{
    138            */
    139          #define GPIO_MODE             0x00000003U
    140          #define EXTI_MODE             0x10000000U
    141          #define GPIO_MODE_IT          0x00010000U
    142          #define GPIO_MODE_EVT         0x00020000U
    143          #define RISING_EDGE           0x00100000U
    144          #define FALLING_EDGE          0x00200000U
    145          #define GPIO_OUTPUT_TYPE      0x00000010U
    146          
    147          #define GPIO_NUMBER           16U
    148          
    149          /* Definitions for bit manipulation of CRL and CRH register */
    150          #define  GPIO_CR_MODE_INPUT         0x00000000U /*!< 00: Input mode (reset state)  */
    151          #define  GPIO_CR_CNF_ANALOG         0x00000000U /*!< 00: Analog mode  */
    152          #define  GPIO_CR_CNF_INPUT_FLOATING 0x00000004U /*!< 01: Floating input (reset state)  */
    153          #define  GPIO_CR_CNF_INPUT_PU_PD    0x00000008U /*!< 10: Input with pull-up / pull-down  */
    154          #define  GPIO_CR_CNF_GP_OUTPUT_PP   0x00000000U /*!< 00: General purpose output push-pull  */
    155          #define  GPIO_CR_CNF_GP_OUTPUT_OD   0x00000004U /*!< 01: General purpose output Open-drain  */
    156          #define  GPIO_CR_CNF_AF_OUTPUT_PP   0x00000008U /*!< 10: Alternate function output Push-pull  */
    157          #define  GPIO_CR_CNF_AF_OUTPUT_OD   0x0000000CU /*!< 11: Alternate function output Open-drain  */
    158          
    159          /**
    160            * @}
    161            */
    162          /* Private macro -------------------------------------------------------------*/
    163          /* Private variables ---------------------------------------------------------*/
    164          /* Private function prototypes -----------------------------------------------*/
    165          /* Private functions ---------------------------------------------------------*/
    166          /* Exported functions --------------------------------------------------------*/
    167          /** @defgroup GPIO_Exported_Functions GPIO Exported Functions
    168            * @{
    169            */
    170          
    171          /** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
    172           *  @brief    Initialization and Configuration functions
    173           *
    174          @verbatim
    175           ===============================================================================
    176                        ##### Initialization and de-initialization functions #####
    177           ===============================================================================
    178            [..]
    179              This section provides functions allowing to initialize and de-initialize the GPIOs
    180              to be ready for use.
    181          
    182          @endverbatim
    183            * @{
    184            */
    185          
    186          
    187          /**
    188            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    189            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
    190            * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
    191            *         the configuration information for the specified GPIO peripheral.
    192            * @retval None
    193            */

   \                                 In section .text, align 2, keep-with-next
    194          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    195          {
   \                     HAL_GPIO_Init:
   \   00000000   0xB4F8             PUSH     {R3-R7}
    196            uint32_t position;
    197            uint32_t ioposition = 0x00U;
   \   00000002   0x2600             MOVS     R6,#+0
    198            uint32_t iocurrent = 0x00U;
   \   00000004   0x2400             MOVS     R4,#+0
    199            uint32_t temp = 0x00U;
   \   00000006   0x2500             MOVS     R5,#+0
    200            uint32_t config = 0x00U;
   \   00000008   0x2200             MOVS     R2,#+0
    201            __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
    202            uint32_t registeroffset = 0U; /* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */
   \   0000000A   0x2700             MOVS     R7,#+0
    203          
    204            /* Check the parameters */
    205            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    206            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    207            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    208          
    209            /* Configure the port pins */
    210            for (position = 0U; position < GPIO_NUMBER; position++)
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0xE008             B.N      ??HAL_GPIO_Init_0
    211            {
    212              /* Get the IO position */
    213              ioposition = (0x01U << position);
    214          
    215              /* Get the current IO position */
    216              iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
    217          
    218              if (iocurrent == ioposition)
    219              {
    220                /* Check the Alternate function parameters */
    221                assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    222          
    223                /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
    224                switch (GPIO_Init->Mode)
    225                {
    226                  /* If we are configuring the pin in OUTPUT push-pull mode */
    227                  case GPIO_MODE_OUTPUT_PP:
    228                    /* Check the GPIO speed parameter */
    229                    assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    230                    config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
    231                    break;
    232          
    233                  /* If we are configuring the pin in OUTPUT open-drain mode */
    234                  case GPIO_MODE_OUTPUT_OD:
    235                    /* Check the GPIO speed parameter */
    236                    assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    237                    config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
    238                    break;
    239          
    240                  /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
    241                  case GPIO_MODE_AF_PP:
    242                    /* Check the GPIO speed parameter */
    243                    assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    244                    config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
    245                    break;
    246          
    247                  /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
    248                  case GPIO_MODE_AF_OD:
    249                    /* Check the GPIO speed parameter */
    250                    assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    251                    config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
    252                    break;
    253          
    254                  /* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */
    255                  case GPIO_MODE_INPUT:
    256                  case GPIO_MODE_IT_RISING:
    257                  case GPIO_MODE_IT_FALLING:
    258                  case GPIO_MODE_IT_RISING_FALLING:
    259                  case GPIO_MODE_EVT_RISING:
    260                  case GPIO_MODE_EVT_FALLING:
    261                  case GPIO_MODE_EVT_RISING_FALLING:
    262                    /* Check the GPIO pull parameter */
    263                    assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    264                    if (GPIO_Init->Pull == GPIO_NOPULL)
    265                    {
    266                      config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
    267                    }
    268                    else if (GPIO_Init->Pull == GPIO_PULLUP)
    269                    {
    270                      config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
    271          
    272                      /* Set the corresponding ODR bit */
    273                      GPIOx->BSRR = ioposition;
    274                    }
    275                    else /* GPIO_PULLDOWN */
    276                    {
    277                      config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
    278          
    279                      /* Reset the corresponding ODR bit */
    280                      GPIOx->BRR = ioposition;
    281                    }
    282                    break;
    283          
    284                  /* If we are configuring the pin in INPUT analog mode */
    285                  case GPIO_MODE_ANALOG:
    286                    config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
    287                    break;
    288          
    289                  /* Parameters are checked with assert_param */
    290                  default:
    291                    break;
    292                }
    293          
    294                /* Check if the current bit belongs to first half or last half of the pin count number
    295                 in order to address CRH or CRL register*/
    296                configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
    297                registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
    298          
    299                /* Apply the new configuration of the pin to the register */
    300                MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
    301          
    302                /*--------------------- EXTI Mode Configuration ------------------------*/
    303                /* Configure the External Interrupt or event for the current IO */
    304                if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
    305                {
    306                  /* Enable AFIO Clock */
    307                  __HAL_RCC_AFIO_CLK_ENABLE();
    308                  temp = AFIO->EXTICR[position >> 2U];
    309                  CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
    310                  SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
    311                  AFIO->EXTICR[position >> 2U] = temp;
    312          
    313          
    314                  /* Configure the interrupt mask */
    315                  if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
    316                  {
    317                    SET_BIT(EXTI->IMR, iocurrent);
    318                  }
    319                  else
    320                  {
    321                    CLEAR_BIT(EXTI->IMR, iocurrent);
    322                  }
    323          
    324                  /* Configure the event mask */
    325                  if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
    326                  {
    327                    SET_BIT(EXTI->EMR, iocurrent);
    328                  }
    329                  else
    330                  {
    331                    CLEAR_BIT(EXTI->EMR, iocurrent);
    332                  }
    333          
    334                  /* Enable or disable the rising trigger */
    335                  if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
    336                  {
    337                    SET_BIT(EXTI->RTSR, iocurrent);
    338                  }
    339                  else
    340                  {
    341                    CLEAR_BIT(EXTI->RTSR, iocurrent);
    342                  }
    343          
    344                  /* Enable or disable the falling trigger */
    345                  if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
    346                  {
    347                    SET_BIT(EXTI->FTSR, iocurrent);
    348                  }
    349                  else
    350                  {
    351                    CLEAR_BIT(EXTI->FTSR, iocurrent);
   \                     ??HAL_GPIO_Init_1:
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable2  ;; 0x4001040c
   \   00000014   0x682D             LDR      R5,[R5, #+0]
   \   00000016   0xEA35 0x0404      BICS     R4,R5,R4
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable2  ;; 0x4001040c
   \   0000001E   0x602C             STR      R4,[R5, #+0]
    352                  }
   \                     ??HAL_GPIO_Init_2:
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \                     ??HAL_GPIO_Init_0:
   \   00000022   0x2B10             CMP      R3,#+16
   \   00000024   0xF080 0x80C9      BCS.W    ??HAL_GPIO_Init_3
   \   00000028   0x2401             MOVS     R4,#+1
   \   0000002A   0xFA14 0xF603      LSLS     R6,R4,R3
   \   0000002E   0x680C             LDR      R4,[R1, #+0]
   \   00000030   0x4034             ANDS     R4,R6,R4
   \   00000032   0x42B4             CMP      R4,R6
   \   00000034   0xD1F4             BNE.N    ??HAL_GPIO_Init_2
   \   00000036   0x684D             LDR      R5,[R1, #+4]
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD027             BEQ.N    ??HAL_GPIO_Init_4
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD01A             BEQ.N    ??HAL_GPIO_Init_5
   \   00000040   0x2D02             CMP      R5,#+2
   \   00000042   0xD01D             BEQ.N    ??HAL_GPIO_Init_6
   \   00000044   0x2D03             CMP      R5,#+3
   \   00000046   0xD02F             BEQ.N    ??HAL_GPIO_Init_7
   \   00000048   0x2D11             CMP      R5,#+17
   \   0000004A   0xD016             BEQ.N    ??HAL_GPIO_Init_8
   \   0000004C   0x2D12             CMP      R5,#+18
   \   0000004E   0xD01A             BEQ.N    ??HAL_GPIO_Init_9
   \   00000050   0x....             LDR.N    R7,??DataTable2_1  ;; 0x10110000
   \   00000052   0x42BD             CMP      R5,R7
   \   00000054   0xD01A             BEQ.N    ??HAL_GPIO_Init_4
   \   00000056   0x....             LDR.N    R7,??DataTable2_2  ;; 0x10120000
   \   00000058   0x42BD             CMP      R5,R7
   \   0000005A   0xD017             BEQ.N    ??HAL_GPIO_Init_4
   \   0000005C   0x....             LDR.N    R7,??DataTable2_3  ;; 0x10210000
   \   0000005E   0x42BD             CMP      R5,R7
   \   00000060   0xD014             BEQ.N    ??HAL_GPIO_Init_4
   \   00000062   0x....             LDR.N    R7,??DataTable2_4  ;; 0x10220000
   \   00000064   0x42BD             CMP      R5,R7
   \   00000066   0xD011             BEQ.N    ??HAL_GPIO_Init_4
   \   00000068   0x....             LDR.N    R7,??DataTable2_5  ;; 0x10310000
   \   0000006A   0x42BD             CMP      R5,R7
   \   0000006C   0xD00E             BEQ.N    ??HAL_GPIO_Init_4
   \   0000006E   0x....             LDR.N    R7,??DataTable2_6  ;; 0x10320000
   \   00000070   0x42BD             CMP      R5,R7
   \   00000072   0xD00B             BEQ.N    ??HAL_GPIO_Init_4
   \   00000074   0xE01A             B.N      ??HAL_GPIO_Init_10
   \                     ??HAL_GPIO_Init_5:
   \   00000076   0x68CA             LDR      R2,[R1, #+12]
   \   00000078   0xE018             B.N      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_8:
   \   0000007A   0x68CA             LDR      R2,[R1, #+12]
   \   0000007C   0x1D12             ADDS     R2,R2,#+4
   \   0000007E   0xE015             B.N      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_6:
   \   00000080   0x68CA             LDR      R2,[R1, #+12]
   \   00000082   0x3208             ADDS     R2,R2,#+8
   \   00000084   0xE012             B.N      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_9:
   \   00000086   0x68CA             LDR      R2,[R1, #+12]
   \   00000088   0x320C             ADDS     R2,R2,#+12
   \   0000008A   0xE00F             B.N      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_4:
   \   0000008C   0x688A             LDR      R2,[R1, #+8]
   \   0000008E   0x2A00             CMP      R2,#+0
   \   00000090   0xD101             BNE.N    ??HAL_GPIO_Init_12
   \   00000092   0x2204             MOVS     R2,#+4
   \   00000094   0xE007             B.N      ??HAL_GPIO_Init_13
   \                     ??HAL_GPIO_Init_12:
   \   00000096   0x688A             LDR      R2,[R1, #+8]
   \   00000098   0x2A01             CMP      R2,#+1
   \   0000009A   0xD102             BNE.N    ??HAL_GPIO_Init_14
   \   0000009C   0x2208             MOVS     R2,#+8
   \   0000009E   0x6106             STR      R6,[R0, #+16]
   \   000000A0   0xE001             B.N      ??HAL_GPIO_Init_13
   \                     ??HAL_GPIO_Init_14:
   \   000000A2   0x2208             MOVS     R2,#+8
   \   000000A4   0x6146             STR      R6,[R0, #+20]
   \                     ??HAL_GPIO_Init_13:
   \   000000A6   0xE001             B.N      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_7:
   \   000000A8   0x2200             MOVS     R2,#+0
   \   000000AA   0xE7FF             B.N      ??HAL_GPIO_Init_11
   \                     ??HAL_GPIO_Init_10:
   \                     ??HAL_GPIO_Init_11:
   \   000000AC   0x2CFF             CMP      R4,#+255
   \   000000AE   0xD801             BHI.N    ??HAL_GPIO_Init_15
   \   000000B0   0x0005             MOVS     R5,R0
   \   000000B2   0xE000             B.N      ??HAL_GPIO_Init_16
   \                     ??HAL_GPIO_Init_15:
   \   000000B4   0x1D05             ADDS     R5,R0,#+4
   \                     ??HAL_GPIO_Init_16:
   \   000000B6   0x2CFF             CMP      R4,#+255
   \   000000B8   0xD801             BHI.N    ??HAL_GPIO_Init_17
   \   000000BA   0x009F             LSLS     R7,R3,#+2
   \   000000BC   0xE002             B.N      ??HAL_GPIO_Init_18
   \                     ??HAL_GPIO_Init_17:
   \   000000BE   0xF1B3 0x0608      SUBS     R6,R3,#+8
   \   000000C2   0x00B7             LSLS     R7,R6,#+2
   \                     ??HAL_GPIO_Init_18:
   \   000000C4   0x682E             LDR      R6,[R5, #+0]
   \   000000C6   0xF05F 0x0C0F      MOVS     R12,#+15
   \   000000CA   0xFA1C 0xFC07      LSLS     R12,R12,R7
   \   000000CE   0xEA36 0x060C      BICS     R6,R6,R12
   \   000000D2   0xFA12 0xF707      LSLS     R7,R2,R7
   \   000000D6   0x433E             ORRS     R6,R7,R6
   \   000000D8   0x602E             STR      R6,[R5, #+0]
   \   000000DA   0x684D             LDR      R5,[R1, #+4]
   \   000000DC   0x00ED             LSLS     R5,R5,#+3
   \   000000DE   0xD59F             BPL.N    ??HAL_GPIO_Init_2
   \   000000E0   0x....             LDR.N    R5,??DataTable2_7  ;; 0x40021018
   \   000000E2   0x682D             LDR      R5,[R5, #+0]
   \   000000E4   0xF055 0x0501      ORRS     R5,R5,#0x1
   \   000000E8   0x....             LDR.N    R6,??DataTable2_7  ;; 0x40021018
   \   000000EA   0x6035             STR      R5,[R6, #+0]
   \   000000EC   0x....             LDR.N    R5,??DataTable2_7  ;; 0x40021018
   \   000000EE   0x682D             LDR      R5,[R5, #+0]
   \   000000F0   0xF015 0x0501      ANDS     R5,R5,#0x1
   \   000000F4   0x9500             STR      R5,[SP, #+0]
   \   000000F6   0x9E00             LDR      R6,[SP, #+0]
   \   000000F8   0x089D             LSRS     R5,R3,#+2
   \   000000FA   0x....             LDR.N    R7,??DataTable2_8  ;; 0x40010008
   \   000000FC   0xF857 0x5025      LDR      R5,[R7, R5, LSL #+2]
   \   00000100   0x270F             MOVS     R7,#+15
   \   00000102   0xF013 0x0C03      ANDS     R12,R3,#0x3
   \   00000106   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000010A   0xEA5F 0x0C8C      LSLS     R12,R12,#+2
   \   0000010E   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000112   0x43BD             BICS     R5,R5,R7
   \   00000114   0x....             LDR.N    R7,??DataTable2_9  ;; 0x40010800
   \   00000116   0x42B8             CMP      R0,R7
   \   00000118   0xD101             BNE.N    ??HAL_GPIO_Init_19
   \   0000011A   0x2600             MOVS     R6,#+0
   \   0000011C   0xE00F             B.N      ??HAL_GPIO_Init_20
   \                     ??HAL_GPIO_Init_19:
   \   0000011E   0x....             LDR.N    R6,??DataTable2_10  ;; 0x40010c00
   \   00000120   0x42B0             CMP      R0,R6
   \   00000122   0xD101             BNE.N    ??HAL_GPIO_Init_21
   \   00000124   0x2601             MOVS     R6,#+1
   \   00000126   0xE00A             B.N      ??HAL_GPIO_Init_20
   \                     ??HAL_GPIO_Init_21:
   \   00000128   0x....             LDR.N    R6,??DataTable2_11  ;; 0x40011000
   \   0000012A   0x42B0             CMP      R0,R6
   \   0000012C   0xD101             BNE.N    ??HAL_GPIO_Init_22
   \   0000012E   0x2602             MOVS     R6,#+2
   \   00000130   0xE005             B.N      ??HAL_GPIO_Init_20
   \                     ??HAL_GPIO_Init_22:
   \   00000132   0x....             LDR.N    R6,??DataTable2_12  ;; 0x40011400
   \   00000134   0x42B0             CMP      R0,R6
   \   00000136   0xD101             BNE.N    ??HAL_GPIO_Init_23
   \   00000138   0x2603             MOVS     R6,#+3
   \   0000013A   0xE000             B.N      ??HAL_GPIO_Init_20
   \                     ??HAL_GPIO_Init_23:
   \   0000013C   0x2604             MOVS     R6,#+4
   \                     ??HAL_GPIO_Init_20:
   \   0000013E   0xF013 0x0703      ANDS     R7,R3,#0x3
   \   00000142   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000144   0x00BF             LSLS     R7,R7,#+2
   \   00000146   0x40BE             LSLS     R6,R6,R7
   \   00000148   0x4335             ORRS     R5,R6,R5
   \   0000014A   0x089E             LSRS     R6,R3,#+2
   \   0000014C   0x....             LDR.N    R7,??DataTable2_8  ;; 0x40010008
   \   0000014E   0xF847 0x5026      STR      R5,[R7, R6, LSL #+2]
   \   00000152   0x684D             LDR      R5,[R1, #+4]
   \   00000154   0x03ED             LSLS     R5,R5,#+15
   \   00000156   0xD505             BPL.N    ??HAL_GPIO_Init_24
   \   00000158   0x....             LDR.N    R5,??DataTable2_13  ;; 0x40010400
   \   0000015A   0x682D             LDR      R5,[R5, #+0]
   \   0000015C   0x4325             ORRS     R5,R4,R5
   \   0000015E   0x....             LDR.N    R6,??DataTable2_13  ;; 0x40010400
   \   00000160   0x6035             STR      R5,[R6, #+0]
   \   00000162   0xE004             B.N      ??HAL_GPIO_Init_25
   \                     ??HAL_GPIO_Init_24:
   \   00000164   0x....             LDR.N    R5,??DataTable2_13  ;; 0x40010400
   \   00000166   0x682D             LDR      R5,[R5, #+0]
   \   00000168   0x43A5             BICS     R5,R5,R4
   \   0000016A   0x....             LDR.N    R6,??DataTable2_13  ;; 0x40010400
   \   0000016C   0x6035             STR      R5,[R6, #+0]
   \                     ??HAL_GPIO_Init_25:
   \   0000016E   0x684D             LDR      R5,[R1, #+4]
   \   00000170   0x03AD             LSLS     R5,R5,#+14
   \   00000172   0xD505             BPL.N    ??HAL_GPIO_Init_26
   \   00000174   0x....             LDR.N    R5,??DataTable2_14  ;; 0x40010404
   \   00000176   0x682D             LDR      R5,[R5, #+0]
   \   00000178   0x4325             ORRS     R5,R4,R5
   \   0000017A   0x....             LDR.N    R6,??DataTable2_14  ;; 0x40010404
   \   0000017C   0x6035             STR      R5,[R6, #+0]
   \   0000017E   0xE004             B.N      ??HAL_GPIO_Init_27
   \                     ??HAL_GPIO_Init_26:
   \   00000180   0x....             LDR.N    R5,??DataTable2_14  ;; 0x40010404
   \   00000182   0x682D             LDR      R5,[R5, #+0]
   \   00000184   0x43A5             BICS     R5,R5,R4
   \   00000186   0x....             LDR.N    R6,??DataTable2_14  ;; 0x40010404
   \   00000188   0x6035             STR      R5,[R6, #+0]
   \                     ??HAL_GPIO_Init_27:
   \   0000018A   0x684D             LDR      R5,[R1, #+4]
   \   0000018C   0x02ED             LSLS     R5,R5,#+11
   \   0000018E   0xD505             BPL.N    ??HAL_GPIO_Init_28
   \   00000190   0x....             LDR.N    R5,??DataTable2_15  ;; 0x40010408
   \   00000192   0x682D             LDR      R5,[R5, #+0]
   \   00000194   0x4325             ORRS     R5,R4,R5
   \   00000196   0x....             LDR.N    R6,??DataTable2_15  ;; 0x40010408
   \   00000198   0x6035             STR      R5,[R6, #+0]
   \   0000019A   0xE004             B.N      ??HAL_GPIO_Init_29
   \                     ??HAL_GPIO_Init_28:
   \   0000019C   0x....             LDR.N    R5,??DataTable2_15  ;; 0x40010408
   \   0000019E   0x682D             LDR      R5,[R5, #+0]
   \   000001A0   0x43A5             BICS     R5,R5,R4
   \   000001A2   0x....             LDR.N    R6,??DataTable2_15  ;; 0x40010408
   \   000001A4   0x6035             STR      R5,[R6, #+0]
   \                     ??HAL_GPIO_Init_29:
   \   000001A6   0x684D             LDR      R5,[R1, #+4]
   \   000001A8   0x02AD             LSLS     R5,R5,#+10
   \   000001AA   0xF57F 0xAF31      BPL.W    ??HAL_GPIO_Init_1
   \   000001AE   0x....             LDR.N    R5,??DataTable2  ;; 0x4001040c
   \   000001B0   0x682D             LDR      R5,[R5, #+0]
   \   000001B2   0x432C             ORRS     R4,R4,R5
   \   000001B4   0x....             LDR.N    R5,??DataTable2  ;; 0x4001040c
   \   000001B6   0x602C             STR      R4,[R5, #+0]
   \   000001B8   0xE732             B.N      ??HAL_GPIO_Init_2
    353                }
    354              }
    355            }
    356          }
   \                     ??HAL_GPIO_Init_3:
   \   000001BA   0xBCF1             POP      {R0,R4-R7}
   \   000001BC   0x4770             BX       LR               ;; return
    357          
    358          /**
    359            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    360            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
    361            * @param  GPIO_Pin: specifies the port bit to be written.
    362            *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
    363            * @retval None
    364            */

   \                                 In section .text, align 2, keep-with-next
    365          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    366          {
   \                     HAL_GPIO_DeInit:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    367            uint32_t position = 0x00U;
   \   00000002   0x2200             MOVS     R2,#+0
    368            uint32_t iocurrent = 0x00U;
   \   00000004   0x2300             MOVS     R3,#+0
    369            uint32_t tmp = 0x00U;
   \   00000006   0x2400             MOVS     R4,#+0
    370            __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
    371            uint32_t registeroffset = 0U;
   \   00000008   0x2500             MOVS     R5,#+0
    372          
    373            /* Check the parameters */
    374            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    375            assert_param(IS_GPIO_PIN(GPIO_Pin));
   \   0000000A   0xE02D             B.N      ??HAL_GPIO_DeInit_0
    376          
    377            /* Configure the port pins */
    378            while ((GPIO_Pin >> position) != 0U)
    379            {
    380              /* Get current io position */
    381              iocurrent = (GPIO_Pin) & (1U << position);
    382          
    383              if (iocurrent)
    384              {
    385                /*------------------------- GPIO Mode Configuration --------------------*/
    386                /* Check if the current bit belongs to first half or last half of the pin count number
    387                 in order to address CRH or CRL register */
    388                configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
    389                registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
    390          
    391                /* CRL/CRH default value is floating input(0x04) shifted to correct position */
    392                MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), GPIO_CRL_CNF0_0 << registeroffset);
    393          
    394                /* ODR default value is 0 */
    395                CLEAR_BIT(GPIOx->ODR, iocurrent);
    396          
    397                /*------------------------- EXTI Mode Configuration --------------------*/
    398                /* Clear the External Interrupt or Event for the current IO */
    399          
    400                tmp = AFIO->EXTICR[position >> 2U];
    401                tmp &= 0x0FU << (4U * (position & 0x03U));
    402                if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
   \                     ??HAL_GPIO_DeInit_1:
   \   0000000C   0x2504             MOVS     R5,#+4
   \                     ??HAL_GPIO_DeInit_2:
   \   0000000E   0xF012 0x0603      ANDS     R6,R2,#0x3
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x00B6             LSLS     R6,R6,#+2
   \   00000016   0x40B5             LSLS     R5,R5,R6
   \   00000018   0x42AC             CMP      R4,R5
   \   0000001A   0xD124             BNE.N    ??HAL_GPIO_DeInit_3
    403                {
    404                  tmp = 0x0FU << (4U * (position & 0x03U));
   \   0000001C   0x240F             MOVS     R4,#+15
   \   0000001E   0xF012 0x0503      ANDS     R5,R2,#0x3
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x00AD             LSLS     R5,R5,#+2
   \   00000026   0x40AC             LSLS     R4,R4,R5
    405                  CLEAR_BIT(AFIO->EXTICR[position >> 2U], tmp);
   \   00000028   0x0895             LSRS     R5,R2,#+2
   \   0000002A   0x....             LDR.N    R6,??DataTable2_8  ;; 0x40010008
   \   0000002C   0xF856 0x5025      LDR      R5,[R6, R5, LSL #+2]
   \   00000030   0xEA35 0x0404      BICS     R4,R5,R4
   \   00000034   0x0895             LSRS     R5,R2,#+2
   \   00000036   0x....             LDR.N    R6,??DataTable2_8  ;; 0x40010008
   \   00000038   0xF846 0x4025      STR      R4,[R6, R5, LSL #+2]
    406          
    407                  /* Clear EXTI line configuration */
    408                  CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
   \   0000003C   0x....             LDR.N    R4,??DataTable2_13  ;; 0x40010400
   \   0000003E   0x6824             LDR      R4,[R4, #+0]
   \   00000040   0x439C             BICS     R4,R4,R3
   \   00000042   0x....             LDR.N    R5,??DataTable2_13  ;; 0x40010400
   \   00000044   0x602C             STR      R4,[R5, #+0]
    409                  CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
   \   00000046   0x....             LDR.N    R4,??DataTable2_14  ;; 0x40010404
   \   00000048   0x6824             LDR      R4,[R4, #+0]
   \   0000004A   0x439C             BICS     R4,R4,R3
   \   0000004C   0x....             LDR.N    R5,??DataTable2_14  ;; 0x40010404
   \   0000004E   0x602C             STR      R4,[R5, #+0]
    410          
    411                  /* Clear Rising Falling edge configuration */
    412                  CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
   \   00000050   0x....             LDR.N    R4,??DataTable2_15  ;; 0x40010408
   \   00000052   0x6824             LDR      R4,[R4, #+0]
   \   00000054   0x439C             BICS     R4,R4,R3
   \   00000056   0x....             LDR.N    R5,??DataTable2_15  ;; 0x40010408
   \   00000058   0x602C             STR      R4,[R5, #+0]
    413                  CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
   \   0000005A   0x....             LDR.N    R4,??DataTable2  ;; 0x4001040c
   \   0000005C   0x6824             LDR      R4,[R4, #+0]
   \   0000005E   0xEA34 0x0303      BICS     R3,R4,R3
   \   00000062   0x....             LDR.N    R4,??DataTable2  ;; 0x4001040c
   \   00000064   0x6023             STR      R3,[R4, #+0]
    414                }
    415              }
    416          
    417              position++;
   \                     ??HAL_GPIO_DeInit_3:
   \   00000066   0x1C52             ADDS     R2,R2,#+1
   \                     ??HAL_GPIO_DeInit_0:
   \   00000068   0xFA31 0xF302      LSRS     R3,R1,R2
   \   0000006C   0x2B00             CMP      R3,#+0
   \   0000006E   0xD03B             BEQ.N    ??HAL_GPIO_DeInit_4
   \   00000070   0x2301             MOVS     R3,#+1
   \   00000072   0x4093             LSLS     R3,R3,R2
   \   00000074   0x400B             ANDS     R3,R3,R1
   \   00000076   0x2B00             CMP      R3,#+0
   \   00000078   0xD0F5             BEQ.N    ??HAL_GPIO_DeInit_3
   \   0000007A   0x2BFF             CMP      R3,#+255
   \   0000007C   0xD801             BHI.N    ??HAL_GPIO_DeInit_5
   \   0000007E   0x0004             MOVS     R4,R0
   \   00000080   0xE000             B.N      ??HAL_GPIO_DeInit_6
   \                     ??HAL_GPIO_DeInit_5:
   \   00000082   0x1D04             ADDS     R4,R0,#+4
   \                     ??HAL_GPIO_DeInit_6:
   \   00000084   0x2BFF             CMP      R3,#+255
   \   00000086   0xD801             BHI.N    ??HAL_GPIO_DeInit_7
   \   00000088   0x0095             LSLS     R5,R2,#+2
   \   0000008A   0xE002             B.N      ??HAL_GPIO_DeInit_8
   \                     ??HAL_GPIO_DeInit_7:
   \   0000008C   0xF1B2 0x0508      SUBS     R5,R2,#+8
   \   00000090   0x00AD             LSLS     R5,R5,#+2
   \                     ??HAL_GPIO_DeInit_8:
   \   00000092   0x6826             LDR      R6,[R4, #+0]
   \   00000094   0x270F             MOVS     R7,#+15
   \   00000096   0x40AF             LSLS     R7,R7,R5
   \   00000098   0x43BE             BICS     R6,R6,R7
   \   0000009A   0x2704             MOVS     R7,#+4
   \   0000009C   0xFA17 0xF505      LSLS     R5,R7,R5
   \   000000A0   0x4335             ORRS     R5,R5,R6
   \   000000A2   0x6025             STR      R5,[R4, #+0]
   \   000000A4   0x68C4             LDR      R4,[R0, #+12]
   \   000000A6   0x439C             BICS     R4,R4,R3
   \   000000A8   0x60C4             STR      R4,[R0, #+12]
   \   000000AA   0x0894             LSRS     R4,R2,#+2
   \   000000AC   0x....             LDR.N    R5,??DataTable2_8  ;; 0x40010008
   \   000000AE   0xF855 0x4024      LDR      R4,[R5, R4, LSL #+2]
   \   000000B2   0x250F             MOVS     R5,#+15
   \   000000B4   0xF012 0x0603      ANDS     R6,R2,#0x3
   \   000000B8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BA   0x00B6             LSLS     R6,R6,#+2
   \   000000BC   0x40B5             LSLS     R5,R5,R6
   \   000000BE   0x402C             ANDS     R4,R5,R4
   \   000000C0   0x....             LDR.N    R5,??DataTable2_9  ;; 0x40010800
   \   000000C2   0x42A8             CMP      R0,R5
   \   000000C4   0xD101             BNE.N    ??HAL_GPIO_DeInit_9
   \   000000C6   0x2500             MOVS     R5,#+0
   \   000000C8   0xE7A1             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_9:
   \   000000CA   0x....             LDR.N    R5,??DataTable2_10  ;; 0x40010c00
   \   000000CC   0x42A8             CMP      R0,R5
   \   000000CE   0xD101             BNE.N    ??HAL_GPIO_DeInit_10
   \   000000D0   0x2501             MOVS     R5,#+1
   \   000000D2   0xE79C             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_10:
   \   000000D4   0x....             LDR.N    R5,??DataTable2_11  ;; 0x40011000
   \   000000D6   0x42A8             CMP      R0,R5
   \   000000D8   0xD101             BNE.N    ??HAL_GPIO_DeInit_11
   \   000000DA   0x2502             MOVS     R5,#+2
   \   000000DC   0xE797             B.N      ??HAL_GPIO_DeInit_2
   \                     ??HAL_GPIO_DeInit_11:
   \   000000DE   0x....             LDR.N    R5,??DataTable2_12  ;; 0x40011400
   \   000000E0   0x42A8             CMP      R0,R5
   \   000000E2   0xD193             BNE.N    ??HAL_GPIO_DeInit_1
   \   000000E4   0x2503             MOVS     R5,#+3
   \   000000E6   0xE792             B.N      ??HAL_GPIO_DeInit_2
    418            }
    419          }
   \                     ??HAL_GPIO_DeInit_4:
   \   000000E8   0xBCF0             POP      {R4-R7}
   \   000000EA   0x4770             BX       LR               ;; return
    420          
    421          /**
    422            * @}
    423            */
    424          
    425          /** @defgroup GPIO_Exported_Functions_Group2 IO operation functions
    426           *  @brief   GPIO Read and Write
    427           *
    428          @verbatim
    429           ===============================================================================
    430                                 ##### IO operation functions #####
    431           ===============================================================================
    432            [..]
    433              This subsection provides a set of functions allowing to manage the GPIOs.
    434          
    435          @endverbatim
    436            * @{
    437            */
    438          
    439          /**
    440            * @brief  Reads the specified input port pin.
    441            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
    442            * @param  GPIO_Pin: specifies the port bit to read.
    443            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    444            * @retval The input port pin value.
    445            */

   \                                 In section .text, align 2, keep-with-next
    446          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    447          {
    448            GPIO_PinState bitstatus;
    449          
    450            /* Check the parameters */
    451            assert_param(IS_GPIO_PIN(GPIO_Pin));
    452          
    453            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \                     HAL_GPIO_ReadPin:
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD001             BEQ.N    ??HAL_GPIO_ReadPin_0
    454            {
    455              bitstatus = GPIO_PIN_SET;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??HAL_GPIO_ReadPin_1
    456            }
    457            else
    458            {
    459              bitstatus = GPIO_PIN_RESET;
   \                     ??HAL_GPIO_ReadPin_0:
   \   0000000C   0x2000             MOVS     R0,#+0
    460            }
    461            return bitstatus;
   \                     ??HAL_GPIO_ReadPin_1:
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4770             BX       LR               ;; return
    462          }
    463          
    464          /**
    465            * @brief  Sets or clears the selected data port bit.
    466            *
    467            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
    468            *         accesses. In this way, there is no risk of an IRQ occurring between
    469            *         the read and the modify access.
    470            *
    471            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
    472            * @param  GPIO_Pin: specifies the port bit to be written.
    473            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    474            * @param  PinState: specifies the value to be written to the selected bit.
    475            *          This parameter can be one of the GPIO_PinState enum values:
    476            *            @arg GPIO_PIN_RESET: to clear the port pin
    477            *            @arg GPIO_PIN_SET: to set the port pin
    478            * @retval None
    479            */

   \                                 In section .text, align 2, keep-with-next
    480          void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    481          {
    482            /* Check the parameters */
    483            assert_param(IS_GPIO_PIN(GPIO_Pin));
    484            assert_param(IS_GPIO_PIN_ACTION(PinState));
    485          
    486            if (PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD002             BEQ.N    ??HAL_GPIO_WritePin_0
    487            {
    488              GPIOx->BSRR = GPIO_Pin;
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0x6101             STR      R1,[R0, #+16]
   \   0000000A   0xE002             B.N      ??HAL_GPIO_WritePin_1
    489            }
    490            else
    491            {
    492              GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
   \                     ??HAL_GPIO_WritePin_0:
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x0409             LSLS     R1,R1,#+16
   \   00000010   0x6101             STR      R1,[R0, #+16]
    493            }
    494          }
   \                     ??HAL_GPIO_WritePin_1:
   \   00000012   0x4770             BX       LR               ;; return
    495          
    496          /**
    497            * @brief  Toggles the specified GPIO pin
    498            * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
    499            * @param  GPIO_Pin: Specifies the pins to be toggled.
    500            * @retval None
    501            */

   \                                 In section .text, align 2, keep-with-next
    502          void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    503          {
    504            /* Check the parameters */
    505            assert_param(IS_GPIO_PIN(GPIO_Pin));
    506          
    507            GPIOx->ODR ^= GPIO_Pin;
   \                     HAL_GPIO_TogglePin:
   \   00000000   0x68C2             LDR      R2,[R0, #+12]
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x4051             EORS     R1,R1,R2
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    508          }
   \   00000008   0x4770             BX       LR               ;; return
    509          
    510          /**
    511          * @brief  Locks GPIO Pins configuration registers.
    512          * @note   The locking mechanism allows the IO configuration to be frozen. When the LOCK sequence
    513          *         has been applied on a port bit, it is no longer possible to modify the value of the port bit until
    514          *         the next reset.
    515          * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
    516          * @param  GPIO_Pin: specifies the port bit to be locked.
    517          *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    518          * @retval None
    519          */

   \                                 In section .text, align 2, keep-with-next
    520          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    521          {
   \                     HAL_GPIO_LockPin:
   \   00000000   0xB081             SUB      SP,SP,#+4
    522            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \   00000002   0xF45F 0x3280      MOVS     R2,#+65536
   \   00000006   0x9200             STR      R2,[SP, #+0]
    523          
    524            /* Check the parameters */
    525            assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
    526            assert_param(IS_GPIO_PIN(GPIO_Pin));
    527          
    528            /* Apply lock key write sequence */
    529            SET_BIT(tmp, GPIO_Pin);
   \   00000008   0x9A00             LDR      R2,[SP, #+0]
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x9200             STR      R2,[SP, #+0]
    530            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    531            GPIOx->LCKR = tmp;
   \   00000010   0x9A00             LDR      R2,[SP, #+0]
   \   00000012   0x6182             STR      R2,[R0, #+24]
    532            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    533            GPIOx->LCKR = GPIO_Pin;
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x6181             STR      R1,[R0, #+24]
    534            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    535            GPIOx->LCKR = tmp;
   \   00000018   0x9900             LDR      R1,[SP, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    536            /* Read LCKK bit*/
    537            tmp = GPIOx->LCKR;
   \   0000001C   0x6981             LDR      R1,[R0, #+24]
   \   0000001E   0x9100             STR      R1,[SP, #+0]
    538          
    539            if ((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
   \   00000020   0x6980             LDR      R0,[R0, #+24]
   \   00000022   0x03C0             LSLS     R0,R0,#+15
   \   00000024   0xD501             BPL.N    ??HAL_GPIO_LockPin_0
    540            {
    541              return HAL_OK;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE000             B.N      ??HAL_GPIO_LockPin_1
    542            }
    543            else
    544            {
    545              return HAL_ERROR;
   \                     ??HAL_GPIO_LockPin_0:
   \   0000002A   0x2001             MOVS     R0,#+1
   \                     ??HAL_GPIO_LockPin_1:
   \   0000002C   0xB001             ADD      SP,SP,#+4
   \   0000002E   0x4770             BX       LR               ;; return
    546            }
    547          }
    548          
    549          /**
    550            * @brief  This function handles EXTI interrupt request.
    551            * @param  GPIO_Pin: Specifies the pins connected EXTI line
    552            * @retval None
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    555          {
   \                     HAL_GPIO_EXTI_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    556            /* EXTI line interrupt detected */
    557            if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
   \   00000002   0x....             LDR.N    R1,??DataTable2_16  ;; 0x40010414
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0x4201             TST      R1,R0
   \   0000000A   0xD005             BEQ.N    ??HAL_GPIO_EXTI_IRQHandler_0
    558            {
    559              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \   0000000C   0x....             LDR.N    R1,??DataTable2_16  ;; 0x40010414
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x6008             STR      R0,[R1, #+0]
    560              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x.... 0x....      BL       HAL_GPIO_EXTI_Callback
    561            }
    562          }
   \                     ??HAL_GPIO_EXTI_IRQHandler_0:
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    563          
    564          /**
    565            * @brief  EXTI line detection callbacks.
    566            * @param  GPIO_Pin: Specifies the pins connected EXTI line
    567            * @retval None
    568            */

   \                                 In section .text, align 2, keep-with-next
    569          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    570          {
    571            /* Prevent unused argument(s) compilation warning */
    572            UNUSED(GPIO_Pin);
    573            /* NOTE: This function Should not be modified, when the callback is needed,
    574                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    575             */
    576          }
   \                     HAL_GPIO_EXTI_Callback:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x4001040C         DC32     0x4001040c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x10120000         DC32     0x10120000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x10210000         DC32     0x10210000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x10220000         DC32     0x10220000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x10310000         DC32     0x10310000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x10320000         DC32     0x10320000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40021018         DC32     0x40021018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x40010008         DC32     0x40010008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \   00000000   0x40010404         DC32     0x40010404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_15:
   \   00000000   0x40010408         DC32     0x40010408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_16:
   \   00000000   0x40010414         DC32     0x40010414
    577          
    578          /**
    579            * @}
    580            */
    581          
    582          /**
    583            * @}
    584            */
    585          
    586          #endif /* HAL_GPIO_MODULE_ENABLED */
    587          /**
    588            * @}
    589            */
    590          
    591          /**
    592            * @}
    593            */
    594          
    595          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  HAL_GPIO_DeInit
        0  HAL_GPIO_EXTI_Callback
        8  HAL_GPIO_EXTI_IRQHandler
             8 -> HAL_GPIO_EXTI_Callback
       20  HAL_GPIO_Init
        4  HAL_GPIO_LockPin
        0  HAL_GPIO_ReadPin
        0  HAL_GPIO_TogglePin
        0  HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     236  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      26  HAL_GPIO_EXTI_IRQHandler
     446  HAL_GPIO_Init
      48  HAL_GPIO_LockPin
      18  HAL_GPIO_ReadPin
      10  HAL_GPIO_TogglePin
      20  HAL_GPIO_WritePin

 
 874 bytes in section .text
 
 874 bytes of CODE memory

Errors: none
Warnings: 1
