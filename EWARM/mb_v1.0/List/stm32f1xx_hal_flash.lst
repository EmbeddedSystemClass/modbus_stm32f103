###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  06:16:03 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1 #
#                    xx_HAL_Driver\Src\stm32f1xx_hal_flash.c                  #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F #
#                    1xx_HAL_Driver\Src\stm32f1xx_hal_flash.c" -D             #
#                    USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F103xB -lC  #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    List\" -o "D:\projects\задания от                        #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/Obj\" --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\stm32f1xx_hal_flash.lst                              #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\stm32f1xx_hal_flash.o                                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @brief   FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the internal FLASH memory:
      8            *           + Program operations functions
      9            *           + Memory Control functions 
     10            *           + Peripheral State functions
     11            *         
     12            @verbatim
     13            ==============================================================================
     14                                  ##### FLASH peripheral features #####
     15            ==============================================================================
     16            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     17                 to the Flash memory. It implements the erase and program Flash memory operations 
     18                 and the read and write protection mechanisms.
     19          
     20            [..] The Flash memory interface accelerates code execution with a system of instruction
     21                prefetch. 
     22          
     23            [..] The FLASH main features are:
     24                (+) Flash memory read operations
     25                (+) Flash memory program/erase operations
     26                (+) Read / write protections
     27                (+) Prefetch on I-Code
     28                (+) Option Bytes programming
     29          
     30          
     31                               ##### How to use this driver #####
     32            ==============================================================================
     33            [..]                             
     34                This driver provides functions and macros to configure and program the FLASH 
     35                memory of all STM32F1xx devices.
     36              
     37                (#) FLASH Memory I/O Programming functions: this group includes all needed
     38                    functions to erase and program the main memory:
     39                  (++) Lock and Unlock the FLASH interface
     40                  (++) Erase function: Erase page, erase all pages
     41                  (++) Program functions: half word, word and doubleword
     42                (#) FLASH Option Bytes Programming functions: this group includes all needed
     43                    functions to manage the Option Bytes:
     44                  (++) Lock and Unlock the Option Bytes
     45                  (++) Set/Reset the write protection
     46                  (++) Set the Read protection Level
     47                  (++) Program the user Option Bytes
     48                  (++) Launch the Option Bytes loader
     49                  (++) Erase Option Bytes
     50                  (++) Program the data Option Bytes
     51                  (++) Get the Write protection.
     52                  (++) Get the user option bytes.
     53              
     54                (#) Interrupts and flags management functions : this group 
     55                    includes all needed functions to:
     56                  (++) Handle FLASH interrupts
     57                  (++) Wait for last FLASH operation according to its status
     58                  (++) Get error flag status
     59          
     60            [..] In addition to these function, this driver includes a set of macros allowing
     61                 to handle the following operations:
     62                
     63                (+) Set/Get the latency
     64                (+) Enable/Disable the prefetch buffer
     65                (+) Enable/Disable the half cycle access
     66                (+) Enable/Disable the FLASH interrupts
     67                (+) Monitor the FLASH flags status
     68                    
     69            @endverbatim
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     74            *
     75            * Redistribution and use in source and binary forms, with or without modification,
     76            * are permitted provided that the following conditions are met:
     77            *   1. Redistributions of source code must retain the above copyright notice,
     78            *      this list of conditions and the following disclaimer.
     79            *   2. Redistributions in binary form must reproduce the above copyright notice,
     80            *      this list of conditions and the following disclaimer in the documentation
     81            *      and/or other materials provided with the distribution.
     82            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     83            *      may be used to endorse or promote products derived from this software
     84            *      without specific prior written permission.
     85            *
     86            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     87            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     88            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     89            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     90            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     91            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     92            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     93            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     94            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     95            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     96            *
     97            ******************************************************************************  
     98            */
     99          
    100          /* Includes ------------------------------------------------------------------*/
    101          #include "stm32f1xx_hal.h"
    102          
    103          /** @addtogroup STM32F1xx_HAL_Driver
    104            * @{
    105            */
    106          
    107          #ifdef HAL_FLASH_MODULE_ENABLED
    108          
    109          /** @defgroup FLASH FLASH
    110            * @brief FLASH HAL module driver
    111            * @{
    112            */
    113          
    114          /* Private typedef -----------------------------------------------------------*/
    115          /* Private define ------------------------------------------------------------*/
    116          /** @defgroup FLASH_Private_Constants FLASH Private Constants
    117            * @{
    118            */
    119          /**
    120            * @}
    121            */
    122          
    123          /* Private macro ---------------------------- ---------------------------------*/
    124          /** @defgroup FLASH_Private_Macros FLASH Private Macros
    125            * @{
    126            */
    127           
    128          /**
    129            * @}
    130            */
    131          
    132          /* Private variables ---------------------------------------------------------*/
    133          /** @defgroup FLASH_Private_Variables FLASH Private Variables
    134            * @{
    135            */
    136          /* Variables used for Erase pages under interruption*/

   \                                 In section .bss, align 8
    137          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \   00000000                      DS8 32
    138          /**
    139            * @}
    140            */
    141          
    142          /* Private function prototypes -----------------------------------------------*/
    143          /** @defgroup FLASH_Private_Functions FLASH Private Functions
    144            * @{
    145            */
    146          static  void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);
    147          static  void   FLASH_SetErrorCode(void);
    148          extern void    FLASH_PageErase(uint32_t PageAddress);
    149          /**
    150            * @}
    151            */
    152          
    153          /* Exported functions ---------------------------------------------------------*/
    154          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    155            * @{
    156            */
    157            
    158          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    159            *  @brief   Programming operation functions 
    160            *
    161          @verbatim   
    162          @endverbatim
    163            * @{
    164            */
    165          
    166          /**
    167            * @brief  Program halfword, word or double word at a specified address
    168            * @note   The function HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    169            *         The function HAL_FLASH_Lock() should be called after to lock the FLASH interface
    170            *
    171            * @note   If an erase and a program operations are requested simultaneously,    
    172            *         the erase operation is performed before the program one.
    173            *  
    174            * @note   FLASH should be previously erased before new programmation (only exception to this 
    175            *         is when 0x0000 is programmed)
    176            *
    177            * @param  TypeProgram:  Indicate the way to program at a specified address.
    178            *                       This parameter can be a value of @ref FLASH_Type_Program
    179            * @param  Address:      Specifies the address to be programmed.
    180            * @param  Data:         Specifies the data to be programmed
    181            * 
    182            * @retval HAL_StatusTypeDef HAL Status
    183            */

   \                                 In section .text, align 2, keep-with-next
    184          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    185          {
   \                     HAL_FLASH_Program:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
    186            HAL_StatusTypeDef status = HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
    187            uint8_t index = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
    188            uint8_t nbiterations = 0;
   \   00000010   0xF05F 0x0800      MOVS     R8,#+0
    189            
    190            /* Process Locked */
    191            __HAL_LOCK(&pFlash);
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000018   0x7E09             LDRB     R1,[R1, #+24]
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xD101             BNE.N    ??HAL_FLASH_Program_0
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE041             B.N      ??HAL_FLASH_Program_1
   \                     ??HAL_FLASH_Program_0:
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x7601             STRB     R1,[R0, #+24]
    192          
    193            /* Check the parameters */
    194            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    195            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    196          
    197          #if defined(FLASH_BANK2_END)
    198            if(Address <= FLASH_BANK1_END)
    199            {
    200          #endif /* FLASH_BANK2_END */
    201              /* Wait for last operation to be completed */
    202              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000002A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    203          #if defined(FLASH_BANK2_END)
    204            }
    205            else
    206            {
    207              /* Wait for last operation to be completed */
    208              status = FLASH_WaitForLastOperationBank2(FLASH_TIMEOUT_VALUE);
    209            }
    210          #endif /* FLASH_BANK2_END */
    211            
    212            if(status == HAL_OK)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD131             BNE.N    ??HAL_FLASH_Program_2
    213            {
    214              if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
   \   00000038   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000003C   0xD102             BNE.N    ??HAL_FLASH_Program_3
    215              {
    216                /* Program halfword (16-bit) at a specified address. */
    217                nbiterations = 1U;
   \   0000003E   0xF05F 0x0801      MOVS     R8,#+1
   \   00000042   0xE007             B.N      ??HAL_FLASH_Program_4
    218              }
    219              else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \                     ??HAL_FLASH_Program_3:
   \   00000044   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000048   0xD102             BNE.N    ??HAL_FLASH_Program_5
    220              {
    221                /* Program word (32-bit = 2*16-bit) at a specified address. */
    222                nbiterations = 2U;
   \   0000004A   0xF05F 0x0802      MOVS     R8,#+2
   \   0000004E   0xE001             B.N      ??HAL_FLASH_Program_4
    223              }
    224              else
    225              {
    226                /* Program double word (64-bit = 4*16-bit) at a specified address. */
    227                nbiterations = 4U;
   \                     ??HAL_FLASH_Program_5:
   \   00000050   0xF05F 0x0804      MOVS     R8,#+4
    228              }
    229          
    230              for (index = 0U; index < nbiterations; index++)
   \                     ??HAL_FLASH_Program_4:
   \   00000054   0x2700             MOVS     R7,#+0
   \   00000056   0xE000             B.N      ??HAL_FLASH_Program_6
   \                     ??HAL_FLASH_Program_7:
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
   \                     ??HAL_FLASH_Program_6:
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000060   0x4547             CMP      R7,R8
   \   00000062   0xD21B             BCS.N    ??HAL_FLASH_Program_2
    231              {
    232                FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006A   0x013A             LSLS     R2,R7,#+4
   \   0000006C   0x.... 0x....      BL       __aeabi_llsr
   \   00000070   0x0001             MOVS     R1,R0
   \   00000072   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000074   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000076   0xEB16 0x0047      ADDS     R0,R6,R7, LSL #+1
   \   0000007A   0x.... 0x....      BL       FLASH_Program_HalfWord
    233          
    234          #if defined(FLASH_BANK2_END)
    235                if(Address <= FLASH_BANK1_END)
    236                {
    237          #endif /* FLASH_BANK2_END */
    238                  /* Wait for last operation to be completed */
    239                  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \   0000007E   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000082   0x.... 0x....      BL       FLASH_WaitForLastOperation
    240              
    241                  /* If the program operation is completed, disable the PG Bit */
    242                  CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x40022010
   \   0000008A   0x6809             LDR      R1,[R1, #+0]
   \   0000008C   0x0849             LSRS     R1,R1,#+1
   \   0000008E   0x0049             LSLS     R1,R1,#+1
   \   00000090   0x.... 0x....      LDR.W    R2,??DataTable10_1  ;; 0x40022010
   \   00000094   0x6011             STR      R1,[R2, #+0]
    243          #if defined(FLASH_BANK2_END)
    244                }
    245                else
    246                {
    247                  /* Wait for last operation to be completed */
    248                  status = FLASH_WaitForLastOperationBank2(FLASH_TIMEOUT_VALUE);
    249                  
    250                  /* If the program operation is completed, disable the PG Bit */
    251                  CLEAR_BIT(FLASH->CR2, FLASH_CR2_PG);
    252                }
    253          #endif /* FLASH_BANK2_END */
    254                /* In case of error, stop programation procedure */
    255                if (status != HAL_OK)
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD0DD             BEQ.N    ??HAL_FLASH_Program_7
    256                {
    257                  break;
    258                }
    259              }
    260            }
    261          
    262            /* Process Unlocked */
    263            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_2:
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable10
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x760A             STRB     R2,[R1, #+24]
    264          
    265            return status;
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_1:
   \   000000A6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    266          }
    267          
    268          /**
    269            * @brief  Program halfword, word or double word at a specified address  with interrupt enabled.
    270            * @note   The function HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    271            *         The function HAL_FLASH_Lock() should be called after to lock the FLASH interface
    272            *
    273            * @note   If an erase and a program operations are requested simultaneously,    
    274            *         the erase operation is performed before the program one.
    275            *
    276            * @param  TypeProgram: Indicate the way to program at a specified address.
    277            *                      This parameter can be a value of @ref FLASH_Type_Program
    278            * @param  Address:     Specifies the address to be programmed.
    279            * @param  Data:        Specifies the data to be programmed
    280            * 
    281            * @retval HAL_StatusTypeDef HAL Status
    282            */

   \                                 In section .text, align 2, keep-with-next
    283          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    284          {
   \                     HAL_FLASH_Program_IT:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x000C             MOVS     R4,R1
    285            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    286            
    287            /* Process Locked */
    288            __HAL_LOCK(&pFlash);
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000000A   0x7E09             LDRB     R1,[R1, #+24]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_FLASH_Program_IT_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE035             B.N      ??HAL_FLASH_Program_IT_1
   \                     ??HAL_FLASH_Program_IT_0:
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000018   0x2601             MOVS     R6,#+1
   \   0000001A   0x760E             STRB     R6,[R1, #+24]
    289          
    290            /* Check the parameters */
    291            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    292            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    293          
    294          #if defined(FLASH_BANK2_END)
    295            /* If procedure already ongoing, reject the next one */
    296            if (pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
    297            {
    298              return HAL_ERROR;
    299            }
    300            
    301            if(Address <= FLASH_BANK1_END)
    302            {
    303              /* Enable End of FLASH Operation and Error source interrupts */
    304              __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP_BANK1 | FLASH_IT_ERR_BANK1);
    305          
    306            }else
    307            {
    308              /* Enable End of FLASH Operation and Error source interrupts */
    309              __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP_BANK2 | FLASH_IT_ERR_BANK2);
    310            }
    311          #else
    312            /* Enable End of FLASH Operation and Error source interrupts */
    313            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable10_1  ;; 0x40022010
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF451 0x51A0      ORRS     R1,R1,#0x1400
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable10_1  ;; 0x40022010
   \   0000002A   0x6031             STR      R1,[R6, #+0]
    314          #endif /* FLASH_BANK2_END */
    315            
    316            pFlash.Address = Address;
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000030   0x608C             STR      R4,[R1, #+8]
    317            pFlash.Data = Data;
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable10
   \   00000036   0xE9C1 0x2304      STRD     R2,R3,[R1, #+16]
    318          
    319            if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD108             BNE.N    ??HAL_FLASH_Program_IT_2
    320            {
    321              pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAMHALFWORD;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000042   0x2103             MOVS     R1,#+3
   \   00000044   0x7001             STRB     R1,[R0, #+0]
    322              /* Program halfword (16-bit) at a specified address. */
    323              pFlash.DataRemaining = 1U;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x6041             STR      R1,[R0, #+4]
   \   0000004E   0xE010             B.N      ??HAL_FLASH_Program_IT_3
    324            }
    325            else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \                     ??HAL_FLASH_Program_IT_2:
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD108             BNE.N    ??HAL_FLASH_Program_IT_4
    326            {
    327              pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAMWORD;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000058   0x2104             MOVS     R1,#+4
   \   0000005A   0x7001             STRB     R1,[R0, #+0]
    328              /* Program word (32-bit : 2*16-bit) at a specified address. */
    329              pFlash.DataRemaining = 2U;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000060   0x2102             MOVS     R1,#+2
   \   00000062   0x6041             STR      R1,[R0, #+4]
   \   00000064   0xE005             B.N      ??HAL_FLASH_Program_IT_3
    330            }
    331            else
    332            {
    333              pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAMDOUBLEWORD;
   \                     ??HAL_FLASH_Program_IT_4:
   \   00000066   0x....             LDR.N    R0,??DataTable10
   \   00000068   0x2105             MOVS     R1,#+5
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
    334              /* Program double word (64-bit : 4*16-bit) at a specified address. */
    335              pFlash.DataRemaining = 4U;
   \   0000006C   0x....             LDR.N    R0,??DataTable10
   \   0000006E   0x2104             MOVS     R1,#+4
   \   00000070   0x6041             STR      R1,[R0, #+4]
    336            }
    337          
    338            /* Program halfword (16-bit) at a specified address. */
    339            FLASH_Program_HalfWord(Address, (uint16_t)Data);
   \                     ??HAL_FLASH_Program_IT_3:
   \   00000072   0x0011             MOVS     R1,R2
   \   00000074   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       FLASH_Program_HalfWord
    340          
    341            return status;
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASH_Program_IT_1:
   \   00000080   0xBD70             POP      {R4-R6,PC}       ;; return
    342          }
    343          
    344          /**
    345            * @brief This function handles FLASH interrupt request.
    346            * @retval None
    347            */

   \                                 In section .text, align 2, keep-with-next
    348          void HAL_FLASH_IRQHandler(void)
    349          {
   \                     HAL_FLASH_IRQHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
    350            uint32_t addresstmp = 0U;
   \   00000002   0x2400             MOVS     R4,#+0
    351            
    352            /* Check FLASH operation error flags */
    353          #if defined(FLASH_BANK2_END)
    354            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK1) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK1) || \
    355              (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2)))
    356          #else
    357            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) ||__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
   \   00000004   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x06C0             LSLS     R0,R0,#+27
   \   0000000A   0xD403             BMI.N    ??HAL_FLASH_IRQHandler_0
   \   0000000C   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0740             LSLS     R0,R0,#+29
   \   00000012   0xD50D             BPL.N    ??HAL_FLASH_IRQHandler_1
    358          #endif /* FLASH_BANK2_END */
    359            {
    360              /* Return the faulty address */
    361              addresstmp = pFlash.Address;
   \                     ??HAL_FLASH_IRQHandler_0:
   \   00000014   0x....             LDR.N    R0,??DataTable10
   \   00000016   0x6884             LDR      R4,[R0, #+8]
    362              /* Reset address */
    363              pFlash.Address = 0xFFFFFFFFU;
   \   00000018   0x....             LDR.N    R0,??DataTable10
   \   0000001A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000001E   0x6081             STR      R1,[R0, #+8]
    364            
    365              /* Save the Error code */
    366              FLASH_SetErrorCode();
   \   00000020   0x.... 0x....      BL       FLASH_SetErrorCode
    367              
    368              /* FLASH error interrupt user callback */
    369              HAL_FLASH_OperationErrorCallback(addresstmp);
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    370          
    371              /* Stop the procedure ongoing */
    372              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   0000002A   0x....             LDR.N    R0,??DataTable10
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
    373            }
    374          
    375            /* Check FLASH End of Operation flag  */
    376          #if defined(FLASH_BANK2_END)
    377            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP_BANK1))
    378            {
    379              /* Clear FLASH End of Operation pending bit */
    380              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP_BANK1);
    381          #else
    382            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??HAL_FLASH_IRQHandler_1:
   \   00000030   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0680             LSLS     R0,R0,#+26
   \   00000036   0xF140 0x808D      BPL.W    ??HAL_FLASH_IRQHandler_2
    383            {
    384              /* Clear FLASH End of Operation pending bit */
    385              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   0000003A   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   0000003C   0x2120             MOVS     R1,#+32
   \   0000003E   0x6001             STR      R1,[R0, #+0]
    386          #endif /* FLASH_BANK2_END */
    387              
    388              /* Process can continue only if no error detected */
    389              if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
   \   00000040   0x....             LDR.N    R0,??DataTable10
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xF000 0x8085      BEQ.W    ??HAL_FLASH_IRQHandler_2
    390              {
    391                if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
   \   0000004A   0x....             LDR.N    R0,??DataTable10
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD128             BNE.N    ??HAL_FLASH_IRQHandler_3
    392                {
    393                  /* Nb of pages to erased can be decreased */
    394                  pFlash.DataRemaining--;
   \   00000052   0x....             LDR.N    R0,??DataTable10
   \   00000054   0x6840             LDR      R0,[R0, #+4]
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x....             LDR.N    R1,??DataTable10
   \   0000005A   0x6048             STR      R0,[R1, #+4]
    395          
    396                  /* Check if there are still pages to erase */
    397                  if(pFlash.DataRemaining != 0U)
   \   0000005C   0x....             LDR.N    R0,??DataTable10
   \   0000005E   0x6840             LDR      R0,[R0, #+4]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD014             BEQ.N    ??HAL_FLASH_IRQHandler_4
    398                  {
    399                    addresstmp = pFlash.Address;
   \   00000064   0x....             LDR.N    R0,??DataTable10
   \   00000066   0x6884             LDR      R4,[R0, #+8]
    400                    /*Indicate user which sector has been erased */
    401                    HAL_FLASH_EndOfOperationCallback(addresstmp);
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    402          
    403                    /*Increment sector number*/
    404                    addresstmp = pFlash.Address + FLASH_PAGE_SIZE;
   \   0000006E   0x....             LDR.N    R0,??DataTable10
   \   00000070   0x6880             LDR      R0,[R0, #+8]
   \   00000072   0xF510 0x6480      ADDS     R4,R0,#+1024
    405                    pFlash.Address = addresstmp;
   \   00000076   0x....             LDR.N    R0,??DataTable10
   \   00000078   0x6084             STR      R4,[R0, #+8]
    406          
    407                    /* If the erase operation is completed, disable the PER Bit */
    408                    CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
   \   0000007A   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40022010
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000082   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   00000084   0x6008             STR      R0,[R1, #+0]
    409          
    410                    FLASH_PageErase(addresstmp);
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       FLASH_PageErase
   \   0000008C   0xE062             B.N      ??HAL_FLASH_IRQHandler_2
    411                  }
    412                  else
    413                  {
    414                    /* No more pages to Erase, user callback can be called. */
    415                    /* Reset Sector and stop Erase pages procedure */
    416                    pFlash.Address = addresstmp = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_4:
   \   0000008E   0xF05F 0x34FF      MOVS     R4,#-1
   \   00000092   0x....             LDR.N    R0,??DataTable10
   \   00000094   0x6084             STR      R4,[R0, #+8]
    417                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   00000096   0x....             LDR.N    R0,??DataTable10
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x7001             STRB     R1,[R0, #+0]
    418                    /* FLASH EOP interrupt user callback */
    419                    HAL_FLASH_EndOfOperationCallback(addresstmp);
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \   000000A2   0xE057             B.N      ??HAL_FLASH_IRQHandler_2
    420                  }
    421                }
    422                else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
   \                     ??HAL_FLASH_IRQHandler_3:
   \   000000A4   0x....             LDR.N    R0,??DataTable10
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2802             CMP      R0,#+2
   \   000000AA   0xD10C             BNE.N    ??HAL_FLASH_IRQHandler_5
    423                {
    424                  /* Operation is completed, disable the MER Bit */
    425                  CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
   \   000000AC   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40022010
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000B4   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    426          
    427          #if defined(FLASH_BANK2_END)
    428                  /* Stop Mass Erase procedure if no pending mass erase on other bank */
    429                  if (HAL_IS_BIT_CLR(FLASH->CR2, FLASH_CR2_MER))
    430                  {
    431          #endif /* FLASH_BANK2_END */
    432                    /* MassErase ended. Return the selected bank */
    433                    /* FLASH EOP interrupt user callback */
    434                    HAL_FLASH_EndOfOperationCallback(0U);
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    435          
    436                    /* Stop Mass Erase procedure*/
    437                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   000000BE   0x....             LDR.N    R0,??DataTable10
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0x7001             STRB     R1,[R0, #+0]
   \   000000C4   0xE046             B.N      ??HAL_FLASH_IRQHandler_2
    438                  }
    439          #if defined(FLASH_BANK2_END)
    440                }
    441          #endif /* FLASH_BANK2_END */
    442                else
    443                {
    444                  /* Nb of 16-bit data to program can be decreased */
    445                  pFlash.DataRemaining--;
   \                     ??HAL_FLASH_IRQHandler_5:
   \   000000C6   0x....             LDR.N    R0,??DataTable10
   \   000000C8   0x6840             LDR      R0,[R0, #+4]
   \   000000CA   0x1E40             SUBS     R0,R0,#+1
   \   000000CC   0x....             LDR.N    R1,??DataTable10
   \   000000CE   0x6048             STR      R0,[R1, #+4]
    446                  
    447                  /* Check if there are still 16-bit data to program */
    448                  if(pFlash.DataRemaining != 0U)
   \   000000D0   0x....             LDR.N    R0,??DataTable10
   \   000000D2   0x6840             LDR      R0,[R0, #+4]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD01E             BEQ.N    ??HAL_FLASH_IRQHandler_6
    449                  {
    450                    /* Increment address to 16-bit */
    451                    pFlash.Address += 2U;
   \   000000D8   0x....             LDR.N    R0,??DataTable10
   \   000000DA   0x6880             LDR      R0,[R0, #+8]
   \   000000DC   0x1C80             ADDS     R0,R0,#+2
   \   000000DE   0x....             LDR.N    R1,??DataTable10
   \   000000E0   0x6088             STR      R0,[R1, #+8]
    452                    addresstmp = pFlash.Address;
   \   000000E2   0x....             LDR.N    R0,??DataTable10
   \   000000E4   0x6884             LDR      R4,[R0, #+8]
    453                    
    454                    /* Shift to have next 16-bit data */
    455                    pFlash.Data = (pFlash.Data >> 16U);
   \   000000E6   0x....             LDR.N    R0,??DataTable10
   \   000000E8   0xE9D0 0x2304      LDRD     R2,R3,[R0, #+16]
   \   000000EC   0x0C12             LSRS     R2,R2,#+16
   \   000000EE   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   000000F2   0x0C1B             LSRS     R3,R3,#+16
   \   000000F4   0x....             LDR.N    R0,??DataTable10
   \   000000F6   0xE9C0 0x2304      STRD     R2,R3,[R0, #+16]
    456                    
    457                    /* Operation is completed, disable the PG Bit */
    458                    CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
   \   000000FA   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40022010
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x0840             LSRS     R0,R0,#+1
   \   00000100   0x0040             LSLS     R0,R0,#+1
   \   00000102   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   00000104   0x6008             STR      R0,[R1, #+0]
    459          
    460                    /*Program halfword (16-bit) at a specified address.*/
    461                    FLASH_Program_HalfWord(addresstmp, (uint16_t)pFlash.Data);
   \   00000106   0x....             LDR.N    R0,??DataTable10
   \   00000108   0xE9D0 0x1204      LDRD     R1,R2,[R0, #+16]
   \   0000010C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000010E   0x0020             MOVS     R0,R4
   \   00000110   0x.... 0x....      BL       FLASH_Program_HalfWord
   \   00000114   0xE01E             B.N      ??HAL_FLASH_IRQHandler_2
    462                  }
    463                  else
    464                  {
    465                    /* Program ended. Return the selected address */
    466                    /* FLASH EOP interrupt user callback */
    467                    if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMHALFWORD)
   \                     ??HAL_FLASH_IRQHandler_6:
   \   00000116   0x....             LDR.N    R0,??DataTable10
   \   00000118   0x7800             LDRB     R0,[R0, #+0]
   \   0000011A   0x2803             CMP      R0,#+3
   \   0000011C   0xD104             BNE.N    ??HAL_FLASH_IRQHandler_7
    468                    {
    469                      HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \   0000011E   0x....             LDR.N    R0,??DataTable10
   \   00000120   0x6880             LDR      R0,[R0, #+8]
   \   00000122   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \   00000126   0xE00E             B.N      ??HAL_FLASH_IRQHandler_8
    470                    }
    471                    else if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMWORD)
   \                     ??HAL_FLASH_IRQHandler_7:
   \   00000128   0x....             LDR.N    R0,??DataTable10
   \   0000012A   0x7800             LDRB     R0,[R0, #+0]
   \   0000012C   0x2804             CMP      R0,#+4
   \   0000012E   0xD105             BNE.N    ??HAL_FLASH_IRQHandler_9
    472                    {
    473                      HAL_FLASH_EndOfOperationCallback(pFlash.Address - 2U);
   \   00000130   0x....             LDR.N    R0,??DataTable10
   \   00000132   0x6880             LDR      R0,[R0, #+8]
   \   00000134   0x1E80             SUBS     R0,R0,#+2
   \   00000136   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \   0000013A   0xE004             B.N      ??HAL_FLASH_IRQHandler_8
    474                    }
    475                    else 
    476                    {
    477                      HAL_FLASH_EndOfOperationCallback(pFlash.Address - 6U);
   \                     ??HAL_FLASH_IRQHandler_9:
   \   0000013C   0x....             LDR.N    R0,??DataTable10
   \   0000013E   0x6880             LDR      R0,[R0, #+8]
   \   00000140   0x1F80             SUBS     R0,R0,#+6
   \   00000142   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    478                    }
    479                  
    480                    /* Reset Address and stop Program procedure */
    481                    pFlash.Address = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_8:
   \   00000146   0x....             LDR.N    R0,??DataTable10
   \   00000148   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000014C   0x6081             STR      R1,[R0, #+8]
    482                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   0000014E   0x....             LDR.N    R0,??DataTable10
   \   00000150   0x2100             MOVS     R1,#+0
   \   00000152   0x7001             STRB     R1,[R0, #+0]
    483                  }
    484                }
    485              }
    486            }
    487            
    488          #if defined(FLASH_BANK2_END)
    489            /* Check FLASH End of Operation flag  */
    490            if(__HAL_FLASH_GET_FLAG( FLASH_FLAG_EOP_BANK2))
    491            {
    492              /* Clear FLASH End of Operation pending bit */
    493              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP_BANK2);
    494              
    495              /* Process can continue only if no error detected */
    496              if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
    497              {
    498                if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
    499                {
    500                  /* Nb of pages to erased can be decreased */
    501                  pFlash.DataRemaining--;
    502                  
    503                  /* Check if there are still pages to erase*/
    504                  if(pFlash.DataRemaining != 0U)
    505                  {
    506                    /* Indicate user which page address has been erased*/
    507                    HAL_FLASH_EndOfOperationCallback(pFlash.Address);
    508                  
    509                    /* Increment page address to next page */
    510                    pFlash.Address += FLASH_PAGE_SIZE;
    511                    addresstmp = pFlash.Address;
    512          
    513                    /* Operation is completed, disable the PER Bit */
    514                    CLEAR_BIT(FLASH->CR2, FLASH_CR2_PER);
    515          
    516                    FLASH_PageErase(addresstmp);
    517                  }
    518                  else
    519                  {
    520                    /*No more pages to Erase*/
    521                    
    522                    /*Reset Address and stop Erase pages procedure*/
    523                    pFlash.Address = 0xFFFFFFFFU;
    524                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    525          
    526                    /* FLASH EOP interrupt user callback */
    527                    HAL_FLASH_EndOfOperationCallback(pFlash.Address);
    528                  }
    529                }
    530                else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
    531                {
    532                  /* Operation is completed, disable the MER Bit */
    533                  CLEAR_BIT(FLASH->CR2, FLASH_CR2_MER);
    534          
    535                  if (HAL_IS_BIT_CLR(FLASH->CR, FLASH_CR_MER))
    536                  {
    537                    /* MassErase ended. Return the selected bank*/
    538                    /* FLASH EOP interrupt user callback */
    539                    HAL_FLASH_EndOfOperationCallback(0U);
    540                  
    541                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    542                  }
    543                }
    544                else
    545                {
    546                  /* Nb of 16-bit data to program can be decreased */
    547                  pFlash.DataRemaining--;
    548                  
    549                  /* Check if there are still 16-bit data to program */
    550                  if(pFlash.DataRemaining != 0U)
    551                  {
    552                    /* Increment address to 16-bit */
    553                    pFlash.Address += 2U;
    554                    addresstmp = pFlash.Address;
    555                    
    556                    /* Shift to have next 16-bit data */
    557                    pFlash.Data = (pFlash.Data >> 16U);
    558                    
    559                    /* Operation is completed, disable the PG Bit */
    560                    CLEAR_BIT(FLASH->CR2, FLASH_CR2_PG);
    561          
    562                    /*Program halfword (16-bit) at a specified address.*/
    563                    FLASH_Program_HalfWord(addresstmp, (uint16_t)pFlash.Data);
    564                  }
    565                  else
    566                  {
    567                    /*Program ended. Return the selected address*/
    568                    /* FLASH EOP interrupt user callback */
    569                    if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMHALFWORD)
    570                    {
    571                      HAL_FLASH_EndOfOperationCallback(pFlash.Address);
    572                    }
    573                    else if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMWORD)
    574                    {
    575                      HAL_FLASH_EndOfOperationCallback(pFlash.Address-2U);
    576                    }
    577                    else 
    578                    {
    579                      HAL_FLASH_EndOfOperationCallback(pFlash.Address-6U);
    580                    }
    581                    
    582                    /* Reset Address and stop Program procedure*/
    583                    pFlash.Address = 0xFFFFFFFFU;
    584                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    585                  }
    586                }
    587              }
    588            }
    589          #endif 
    590          
    591            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_2:
   \   00000154   0x....             LDR.N    R0,??DataTable10
   \   00000156   0x7800             LDRB     R0,[R0, #+0]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD10E             BNE.N    ??HAL_FLASH_IRQHandler_10
    592            {
    593          #if defined(FLASH_BANK2_END)
    594              /* Operation is completed, disable the PG, PER and MER Bits for both bank */
    595              CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_PER | FLASH_CR_MER));
    596              CLEAR_BIT(FLASH->CR2, (FLASH_CR2_PG | FLASH_CR2_PER | FLASH_CR2_MER));  
    597            
    598              /* Disable End of FLASH Operation and Error source interrupts for both banks */
    599              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP_BANK1 | FLASH_IT_ERR_BANK1 | FLASH_IT_EOP_BANK2 | FLASH_IT_ERR_BANK2);
    600          #else
    601              /* Operation is completed, disable the PG, PER and MER Bits */
    602              CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_PER | FLASH_CR_MER));
   \   0000015C   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40022010
   \   0000015E   0x6800             LDR      R0,[R0, #+0]
   \   00000160   0x08C0             LSRS     R0,R0,#+3
   \   00000162   0x00C0             LSLS     R0,R0,#+3
   \   00000164   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   00000166   0x6008             STR      R0,[R1, #+0]
    603          
    604              /* Disable End of FLASH Operation and Error source interrupts */
    605              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \   00000168   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40022010
   \   0000016A   0x6800             LDR      R0,[R0, #+0]
   \   0000016C   0xF430 0x50A0      BICS     R0,R0,#0x1400
   \   00000170   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   00000172   0x6008             STR      R0,[R1, #+0]
    606          #endif /* FLASH_BANK2_END */
    607          
    608              /* Process Unlocked */
    609              __HAL_UNLOCK(&pFlash);
   \   00000174   0x....             LDR.N    R0,??DataTable10
   \   00000176   0x2100             MOVS     R1,#+0
   \   00000178   0x7601             STRB     R1,[R0, #+24]
    610            }
    611          }
   \                     ??HAL_FLASH_IRQHandler_10:
   \   0000017A   0xBD10             POP      {R4,PC}          ;; return
    612          
    613          /**
    614            * @brief  FLASH end of operation interrupt callback
    615            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    616            *                 - Mass Erase: No return value expected
    617            *                 - Pages Erase: Address of the page which has been erased 
    618            *                    (if 0xFFFFFFFF, it means that all the selected pages have been erased)
    619            *                 - Program: Address which was selected for data program
    620            * @retval none
    621            */

   \                                 In section .text, align 2, keep-with-next
    622          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    623          {
    624            /* Prevent unused argument(s) compilation warning */
    625            UNUSED(ReturnValue);
    626          
    627            /* NOTE : This function Should not be modified, when the callback is needed,
    628                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    629             */ 
    630          }
   \                     HAL_FLASH_EndOfOperationCallback:
   \   00000000   0x4770             BX       LR               ;; return
    631          
    632          /**
    633            * @brief  FLASH operation error interrupt callback
    634            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    635            *                 - Mass Erase: No return value expected
    636            *                 - Pages Erase: Address of the page which returned an error
    637            *                 - Program: Address which was selected for data program
    638            * @retval none
    639            */

   \                                 In section .text, align 2, keep-with-next
    640          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    641          {
    642            /* Prevent unused argument(s) compilation warning */
    643            UNUSED(ReturnValue);
    644          
    645            /* NOTE : This function Should not be modified, when the callback is needed,
    646                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    647             */ 
    648          }
   \                     HAL_FLASH_OperationErrorCallback:
   \   00000000   0x4770             BX       LR               ;; return
    649          
    650          /**
    651            * @}
    652            */
    653          
    654          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    655           *  @brief   management functions 
    656           *
    657          @verbatim   
    658           ===============================================================================
    659                                ##### Peripheral Control functions #####
    660           ===============================================================================  
    661              [..]
    662              This subsection provides a set of functions allowing to control the FLASH 
    663              memory operations.
    664          
    665          @endverbatim
    666            * @{
    667            */
    668          
    669          /**
    670            * @brief  Unlock the FLASH control register access
    671            * @retval HAL Status
    672            */

   \                                 In section .text, align 2, keep-with-next
    673          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    674          {
    675            HAL_StatusTypeDef status = HAL_OK;
   \                     HAL_FLASH_Unlock:
   \   00000000   0x2000             MOVS     R0,#+0
    676          
    677            if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
   \   00000002   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x0609             LSLS     R1,R1,#+24
   \   00000008   0xD50A             BPL.N    ??HAL_FLASH_Unlock_0
    678            {
    679              /* Authorize the FLASH Registers access */
    680              WRITE_REG(FLASH->KEYR, FLASH_KEY1);
   \   0000000A   0x....             LDR.N    R1,??DataTable10_3  ;; 0x40022004
   \   0000000C   0x....             LDR.N    R2,??DataTable10_4  ;; 0x45670123
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    681              WRITE_REG(FLASH->KEYR, FLASH_KEY2);
   \   00000010   0x....             LDR.N    R1,??DataTable10_3  ;; 0x40022004
   \   00000012   0x....             LDR.N    R2,??DataTable10_5  ;; 0xcdef89ab
   \   00000014   0x600A             STR      R2,[R1, #+0]
    682          
    683              /* Verify Flash is unlocked */
    684              if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
   \   00000016   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x0609             LSLS     R1,R1,#+24
   \   0000001C   0xD500             BPL.N    ??HAL_FLASH_Unlock_0
    685              {
    686                status = HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
    687              }
    688            }
    689          #if defined(FLASH_BANK2_END)
    690            if(READ_BIT(FLASH->CR2, FLASH_CR2_LOCK) != RESET)
    691            {
    692              /* Authorize the FLASH BANK2 Registers access */
    693              WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    694              WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    695              
    696              /* Verify Flash BANK2 is unlocked */
    697              if(READ_BIT(FLASH->CR2, FLASH_CR2_LOCK) != RESET)
    698              {
    699                status = HAL_ERROR;
    700              }
    701            }
    702          #endif /* FLASH_BANK2_END */
    703          
    704            return status;
   \                     ??HAL_FLASH_Unlock_0:
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x4770             BX       LR               ;; return
    705          }
    706          
    707          /**
    708            * @brief  Locks the FLASH control register access
    709            * @retval HAL Status
    710            */

   \                                 In section .text, align 2, keep-with-next
    711          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    712          {
    713            /* Set the LOCK Bit to lock the FLASH Registers access */
    714            SET_BIT(FLASH->CR, FLASH_CR_LOCK);
   \                     HAL_FLASH_Lock:
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40022010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000008   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    715            
    716          #if defined(FLASH_BANK2_END)
    717            /* Set the LOCK Bit to lock the FLASH BANK2 Registers access */
    718            SET_BIT(FLASH->CR2, FLASH_CR2_LOCK);
    719          
    720          #endif /* FLASH_BANK2_END */
    721            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    722          }
    723          
    724          /**
    725            * @brief  Unlock the FLASH Option Control Registers access.
    726            * @retval HAL Status
    727            */

   \                                 In section .text, align 2, keep-with-next
    728          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    729          {
    730            if (HAL_IS_BIT_CLR(FLASH->CR, FLASH_CR_OPTWRE))
   \                     HAL_FLASH_OB_Unlock:
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40022010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0580             LSLS     R0,R0,#+22
   \   00000006   0xD407             BMI.N    ??HAL_FLASH_OB_Unlock_0
    731            {
    732              /* Authorizes the Option Byte register programming */
    733              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
   \   00000008   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40022008
   \   0000000A   0x....             LDR.N    R1,??DataTable10_4  ;; 0x45670123
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    734              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
   \   0000000E   0x....             LDR.N    R0,??DataTable10_6  ;; 0x40022008
   \   00000010   0x....             LDR.N    R1,??DataTable10_5  ;; 0xcdef89ab
   \   00000012   0x6001             STR      R1,[R0, #+0]
    735            }
    736            else
    737            {
    738              return HAL_ERROR;
    739            }  
    740            
    741            return HAL_OK;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE000             B.N      ??HAL_FLASH_OB_Unlock_1
   \                     ??HAL_FLASH_OB_Unlock_0:
   \   00000018   0x2001             MOVS     R0,#+1
   \                     ??HAL_FLASH_OB_Unlock_1:
   \   0000001A   0x4770             BX       LR               ;; return
    742          }
    743          
    744          /**
    745            * @brief  Lock the FLASH Option Control Registers access.
    746            * @retval HAL Status 
    747            */

   \                                 In section .text, align 2, keep-with-next
    748          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    749          {
    750            /* Clear the OPTWRE Bit to lock the FLASH Option Byte Registers access */
    751            CLEAR_BIT(FLASH->CR, FLASH_CR_OPTWRE);
   \                     HAL_FLASH_OB_Lock:
   \   00000000   0x....             LDR.N    R0,??DataTable10_1  ;; 0x40022010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF430 0x7000      BICS     R0,R0,#0x200
   \   00000008   0x....             LDR.N    R1,??DataTable10_1  ;; 0x40022010
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    752            
    753            return HAL_OK;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    754          }
    755            
    756          /**
    757            * @brief  Launch the option byte loading.
    758            * @note   This function will reset automatically the MCU.
    759            * @retval None
    760            */

   \                                 In section .text, align 2, keep-with-next
    761          void HAL_FLASH_OB_Launch(void)
    762          {
   \                     HAL_FLASH_OB_Launch:
   \   00000000   0xB580             PUSH     {R7,LR}
    763            /* Initiates a system reset request to launch the option byte loading */
    764            HAL_NVIC_SystemReset();
   \   00000002   0x.... 0x....      BL       HAL_NVIC_SystemReset
    765          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    766          
    767          /**
    768            * @}
    769            */  
    770          
    771          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral errors functions 
    772           *  @brief    Peripheral errors functions 
    773           *
    774          @verbatim   
    775           ===============================================================================
    776                                ##### Peripheral Errors functions #####
    777           ===============================================================================  
    778              [..]
    779              This subsection permit to get in run-time errors of  the FLASH peripheral.
    780          
    781          @endverbatim
    782            * @{
    783            */
    784          
    785          /**
    786            * @brief  Get the specific FLASH error flag.
    787            * @retval FLASH_ErrorCode The returned value can be:
    788            *            @ref FLASH_Error_Codes
    789            */

   \                                 In section .text, align 2, keep-with-next
    790          uint32_t HAL_FLASH_GetError(void)
    791          {
    792             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError:
   \   00000000   0x....             LDR.N    R0,??DataTable10
   \   00000002   0x69C0             LDR      R0,[R0, #+28]
   \   00000004   0x4770             BX       LR               ;; return
    793          }
    794          
    795          /**
    796            * @}
    797            */
    798          
    799          /**
    800            * @}
    801            */
    802          
    803          /** @addtogroup FLASH_Private_Functions
    804           * @{
    805           */
    806          
    807          /**
    808            * @brief  Program a half-word (16-bit) at a specified address.
    809            * @param  Address specify the address to be programmed.
    810            * @param  Data    specify the data to be programmed.
    811            * @retval None
    812            */

   \                                 In section .text, align 2, keep-with-next
    813          static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
    814          {
    815            /* Clean the error context */
    816            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     FLASH_Program_HalfWord:
   \   00000000   0x....             LDR.N    R2,??DataTable10
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x61D3             STR      R3,[R2, #+28]
    817            
    818          #if defined(FLASH_BANK2_END)
    819            if(Address <= FLASH_BANK1_END)
    820            {
    821          #endif /* FLASH_BANK2_END */
    822              /* Proceed to program the new data */
    823              SET_BIT(FLASH->CR, FLASH_CR_PG);
   \   00000006   0x....             LDR.N    R2,??DataTable10_1  ;; 0x40022010
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   0000000E   0x....             LDR.N    R3,??DataTable10_1  ;; 0x40022010
   \   00000010   0x601A             STR      R2,[R3, #+0]
    824          #if defined(FLASH_BANK2_END)
    825            }
    826            else
    827            {
    828              /* Proceed to program the new data */
    829              SET_BIT(FLASH->CR2, FLASH_CR2_PG);
    830            }
    831          #endif /* FLASH_BANK2_END */
    832          
    833            /* Write data in the address */
    834            *(__IO uint16_t*)Address = Data;
   \   00000012   0x8001             STRH     R1,[R0, #+0]
    835          }
   \   00000014   0x4770             BX       LR               ;; return
    836          
    837          /**
    838            * @brief  Wait for a FLASH operation to complete.
    839            * @param  Timeout  maximum flash operation timeout
    840            * @retval HAL Status
    841            */

   \                                 In section .text, align 2, keep-with-next
    842          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    843          {
   \                     FLASH_WaitForLastOperation:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    844            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    845               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    846               flag will be set */
    847               
    848            uint32_t tickstart = HAL_GetTick();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x0005             MOVS     R5,R0
    849               
    850            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
   \                     ??FLASH_WaitForLastOperation_0:
   \   0000000A   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD50B             BPL.N    ??FLASH_WaitForLastOperation_1
    851            { 
    852              if (Timeout != HAL_MAX_DELAY)
   \   00000012   0xF114 0x0F01      CMN      R4,#+1
   \   00000016   0xD0F8             BEQ.N    ??FLASH_WaitForLastOperation_0
    853              {
    854                if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD004             BEQ.N    ??FLASH_WaitForLastOperation_2
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD2F1             BCS.N    ??FLASH_WaitForLastOperation_0
    855                {
    856                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2:
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xE017             B.N      ??FLASH_WaitForLastOperation_3
    857                }
    858              }
    859            }
    860            
    861            /* Check FLASH End of Operation flag  */
    862            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
   \                     ??FLASH_WaitForLastOperation_1:
   \   0000002A   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0680             LSLS     R0,R0,#+26
   \   00000030   0xD502             BPL.N    ??FLASH_WaitForLastOperation_4
    863            {
    864              /* Clear FLASH End of Operation pending bit */
    865              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000032   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   00000034   0x2120             MOVS     R1,#+32
   \   00000036   0x6001             STR      R1,[R0, #+0]
    866            }
    867            
    868            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
    869               __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
    870               __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
   \                     ??FLASH_WaitForLastOperation_4:
   \   00000038   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x06C0             LSLS     R0,R0,#+27
   \   0000003E   0xD407             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000040   0x....             LDR.N    R0,??DataTable10_7  ;; 0x4002201c
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x07C0             LSLS     R0,R0,#+31
   \   00000046   0xD403             BMI.N    ??FLASH_WaitForLastOperation_5
   \   00000048   0x....             LDR.N    R0,??DataTable10_2  ;; 0x4002200c
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x0740             LSLS     R0,R0,#+29
   \   0000004E   0xD503             BPL.N    ??FLASH_WaitForLastOperation_6
    871            {
    872              /*Save the error code*/
    873              FLASH_SetErrorCode();
   \                     ??FLASH_WaitForLastOperation_5:
   \   00000050   0x.... 0x....      BL       FLASH_SetErrorCode
    874              return HAL_ERROR;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xE000             B.N      ??FLASH_WaitForLastOperation_3
    875            }
    876          
    877            /* There is no error flag set */
    878            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_6:
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_3:
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    879          }
    880          
    881          #if defined(FLASH_BANK2_END)
    882          /**
    883            * @brief  Wait for a FLASH BANK2 operation to complete.
    884            * @param  Timeout maximum flash operation timeout
    885            * @retval HAL_StatusTypeDef HAL Status
    886            */
    887          HAL_StatusTypeDef FLASH_WaitForLastOperationBank2(uint32_t Timeout)
    888          { 
    889            /* Wait for the FLASH BANK2 operation to complete by polling on BUSY flag to be reset.
    890               Even if the FLASH BANK2 operation fails, the BUSY flag will be reset and an error
    891               flag will be set */
    892               
    893            uint32_t tickstart = HAL_GetTick();
    894               
    895            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY_BANK2)) 
    896            { 
    897              if (Timeout != HAL_MAX_DELAY)
    898              {
    899                if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
    900                {
    901                  return HAL_TIMEOUT;
    902                }
    903              }
    904            }
    905            
    906            /* Check FLASH End of Operation flag  */
    907            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP_BANK2))
    908            {
    909              /* Clear FLASH End of Operation pending bit */
    910              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP_BANK2);
    911            }
    912          
    913            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2))
    914            {
    915              /*Save the error code*/
    916              FLASH_SetErrorCode();
    917              return HAL_ERROR;
    918            }
    919          
    920            /* If there is an error flag set */
    921            return HAL_OK;
    922            
    923          }
    924          #endif /* FLASH_BANK2_END */
    925          
    926          /**
    927            * @brief  Set the specific FLASH error flag.
    928            * @retval None
    929            */

   \                                 In section .text, align 2, keep-with-next
    930          static void FLASH_SetErrorCode(void)
    931          {
    932            uint32_t flags = 0U;
   \                     FLASH_SetErrorCode:
   \   00000000   0x2000             MOVS     R0,#+0
    933            
    934          #if defined(FLASH_BANK2_END)
    935            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2))
    936          #else
    937            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
   \   00000002   0x....             LDR.N    R1,??DataTable10_2  ;; 0x4002200c
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x06C9             LSLS     R1,R1,#+27
   \   00000008   0xD507             BPL.N    ??FLASH_SetErrorCode_0
    938          #endif /* FLASH_BANK2_END */
    939            {
    940              pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \   0000000A   0x....             LDR.N    R1,??DataTable10
   \   0000000C   0x69C9             LDR      R1,[R1, #+28]
   \   0000000E   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   00000012   0x....             LDR.N    R2,??DataTable10
   \   00000014   0x61D1             STR      R1,[R2, #+28]
    941          #if defined(FLASH_BANK2_END)
    942              flags |= FLASH_FLAG_WRPERR | FLASH_FLAG_WRPERR_BANK2;
    943          #else
    944              flags |= FLASH_FLAG_WRPERR;
   \   00000016   0xF050 0x0010      ORRS     R0,R0,#0x10
    945          #endif /* FLASH_BANK2_END */
    946            }
    947          #if defined(FLASH_BANK2_END)
    948            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2))
    949          #else
    950            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
   \                     ??FLASH_SetErrorCode_0:
   \   0000001A   0x....             LDR.N    R1,??DataTable10_2  ;; 0x4002200c
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x0749             LSLS     R1,R1,#+29
   \   00000020   0xD507             BPL.N    ??FLASH_SetErrorCode_1
    951          #endif /* FLASH_BANK2_END */
    952            {
    953              pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
   \   00000022   0x....             LDR.N    R1,??DataTable10
   \   00000024   0x69C9             LDR      R1,[R1, #+28]
   \   00000026   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   0000002A   0x....             LDR.N    R2,??DataTable10
   \   0000002C   0x61D1             STR      R1,[R2, #+28]
    954          #if defined(FLASH_BANK2_END)
    955              flags |= FLASH_FLAG_PGERR | FLASH_FLAG_PGERR_BANK2;
    956          #else
    957              flags |= FLASH_FLAG_PGERR;
   \   0000002E   0xF050 0x0004      ORRS     R0,R0,#0x4
    958          #endif /* FLASH_BANK2_END */
    959            }
    960            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
   \                     ??FLASH_SetErrorCode_1:
   \   00000032   0x....             LDR.N    R1,??DataTable10_7  ;; 0x4002201c
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x07C9             LSLS     R1,R1,#+31
   \   00000038   0xD50B             BPL.N    ??FLASH_SetErrorCode_2
    961            {
    962              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
   \   0000003A   0x....             LDR.N    R1,??DataTable10
   \   0000003C   0x69C9             LDR      R1,[R1, #+28]
   \   0000003E   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000042   0x....             LDR.N    R2,??DataTable10
   \   00000044   0x61D1             STR      R1,[R2, #+28]
    963            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
   \   00000046   0x....             LDR.N    R1,??DataTable10_7  ;; 0x4002201c
   \   00000048   0x6809             LDR      R1,[R1, #+0]
   \   0000004A   0x0849             LSRS     R1,R1,#+1
   \   0000004C   0x0049             LSLS     R1,R1,#+1
   \   0000004E   0x....             LDR.N    R2,??DataTable10_7  ;; 0x4002201c
   \   00000050   0x6011             STR      R1,[R2, #+0]
    964            }
    965          
    966            /* Clear FLASH error pending bits */
    967            __HAL_FLASH_CLEAR_FLAG(flags);
   \                     ??FLASH_SetErrorCode_2:
   \   00000052   0xF240 0x1101      MOVW     R1,#+257
   \   00000056   0x4288             CMP      R0,R1
   \   00000058   0xD106             BNE.N    ??FLASH_SetErrorCode_3
   \   0000005A   0x....             LDR.N    R0,??DataTable10_7  ;; 0x4002201c
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x0840             LSRS     R0,R0,#+1
   \   00000060   0x0040             LSLS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable10_7  ;; 0x4002201c
   \   00000064   0x6008             STR      R0,[R1, #+0]
   \   00000066   0xE001             B.N      ??FLASH_SetErrorCode_4
   \                     ??FLASH_SetErrorCode_3:
   \   00000068   0x....             LDR.N    R1,??DataTable10_2  ;; 0x4002200c
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    968          }  
   \                     ??FLASH_SetErrorCode_4:
   \   0000006C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40022010         DC32     0x40022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x4002200C         DC32     0x4002200c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40022004         DC32     0x40022004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x40022008         DC32     0x40022008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x4002201C         DC32     0x4002201c
    969          /**
    970            * @}
    971            */
    972          
    973          /**
    974            * @}
    975            */
    976          
    977          #endif /* HAL_FLASH_MODULE_ENABLED */
    978          
    979          /**
    980            * @}
    981            */
    982          
    983          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  FLASH_Program_HalfWord
        0  FLASH_SetErrorCode
       16  FLASH_WaitForLastOperation
             16 -> FLASH_SetErrorCode
             16 -> HAL_GetTick
        0  HAL_FLASH_EndOfOperationCallback
        0  HAL_FLASH_GetError
        8  HAL_FLASH_IRQHandler
              8 -> FLASH_PageErase
              8 -> FLASH_Program_HalfWord
              8 -> FLASH_SetErrorCode
              8 -> HAL_FLASH_EndOfOperationCallback
              8 -> HAL_FLASH_OperationErrorCallback
        0  HAL_FLASH_Lock
        8  HAL_FLASH_OB_Launch
              8 -> HAL_NVIC_SystemReset
        0  HAL_FLASH_OB_Lock
        0  HAL_FLASH_OB_Unlock
        0  HAL_FLASH_OperationErrorCallback
       32  HAL_FLASH_Program
             32 -> FLASH_Program_HalfWord
             32 -> FLASH_WaitForLastOperation
             32 -> __aeabi_llsr
       16  HAL_FLASH_Program_IT
             16 -> FLASH_Program_HalfWord
        0  HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
      22  FLASH_Program_HalfWord
     110  FLASH_SetErrorCode
      92  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     380  HAL_FLASH_IRQHandler
      16  HAL_FLASH_Lock
       8  HAL_FLASH_OB_Launch
      16  HAL_FLASH_OB_Lock
      28  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     170  HAL_FLASH_Program
     130  HAL_FLASH_Program_IT
      36  HAL_FLASH_Unlock
      32  pFlash

 
    32 bytes in section .bss
 1 050 bytes in section .text
 
 1 050 bytes of CODE memory
    32 bytes of DATA memory

Errors: none
Warnings: 1
