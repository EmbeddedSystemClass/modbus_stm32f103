###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  06:16:04 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1 #
#                    xx_HAL_Driver\Src\stm32f1xx_hal_flash_ex.c               #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F #
#                    1xx_HAL_Driver\Src\stm32f1xx_hal_flash_ex.c" -D          #
#                    USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F103xB -lC  #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    List\" -o "D:\projects\задания от                        #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/Obj\" --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\stm32f1xx_hal_flash_ex.lst                           #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\stm32f1xx_hal_flash_ex.o                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash_ex.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_flash_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended FLASH HAL module driver.
      6            *    
      7            *          This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *           + Extended Initialization/de-initialization functions
     10            *           + Extended I/O operation functions
     11            *           + Extended Peripheral Control functions 
     12            *         
     13            @verbatim
     14            ==============================================================================
     15                         ##### Flash peripheral extended features  #####
     16            ==============================================================================
     17                     
     18                                ##### How to use this driver #####
     19            ==============================================================================
     20            [..] This driver provides functions to configure and program the FLASH memory 
     21                 of all STM32F1xxx devices. It includes
     22                 
     23                  (++) Set/Reset the write protection
     24                  (++) Program the user Option Bytes
     25                  (++) Get the Read protection Level
     26            
     27            @endverbatim
     28            ******************************************************************************
     29            * @attention
     30            *
     31            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     32            *
     33            * Redistribution and use in source and binary forms, with or without modification,
     34            * are permitted provided that the following conditions are met:
     35            *   1. Redistributions of source code must retain the above copyright notice,
     36            *      this list of conditions and the following disclaimer.
     37            *   2. Redistributions in binary form must reproduce the above copyright notice,
     38            *      this list of conditions and the following disclaimer in the documentation
     39            *      and/or other materials provided with the distribution.
     40            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     41            *      may be used to endorse or promote products derived from this software
     42            *      without specific prior written permission.
     43            *
     44            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     45            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     46            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     47            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     48            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     49            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     50            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     51            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     52            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     53            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     54            *
     55            ******************************************************************************  
     56            */
     57          
     58          /* Includes ------------------------------------------------------------------*/
     59          #include "stm32f1xx_hal.h"
     60          
     61          /** @addtogroup STM32F1xx_HAL_Driver
     62            * @{
     63            */
     64          #ifdef HAL_FLASH_MODULE_ENABLED
     65          
     66          /** @addtogroup FLASH
     67            * @{
     68            */
     69          /** @addtogroup FLASH_Private_Variables
     70           * @{
     71           */
     72          /* Variables used for Erase pages under interruption*/
     73          extern FLASH_ProcessTypeDef pFlash;
     74          /**
     75            * @}
     76            */
     77          
     78          /**
     79            * @}
     80            */
     81            
     82          /** @defgroup FLASHEx FLASHEx
     83            * @brief FLASH HAL Extension module driver
     84            * @{
     85            */
     86          
     87          /* Private typedef -----------------------------------------------------------*/
     88          /* Private define ------------------------------------------------------------*/
     89          /** @defgroup FLASHEx_Private_Constants FLASHEx Private Constants
     90           * @{
     91           */
     92          #define FLASH_POSITION_IWDGSW_BIT        FLASH_OBR_IWDG_SW_Pos
     93          #define FLASH_POSITION_OB_USERDATA0_BIT  FLASH_OBR_DATA0_Pos
     94          #define FLASH_POSITION_OB_USERDATA1_BIT  FLASH_OBR_DATA1_Pos
     95          /**
     96            * @}
     97            */
     98          
     99          /* Private macro -------------------------------------------------------------*/
    100          /** @defgroup FLASHEx_Private_Macros FLASHEx Private Macros
    101            * @{
    102            */
    103          /**
    104            * @}
    105            */ 
    106          
    107          /* Private variables ---------------------------------------------------------*/
    108          /* Private function prototypes -----------------------------------------------*/
    109          /** @defgroup FLASHEx_Private_Functions FLASHEx Private Functions
    110           * @{
    111           */
    112          /* Erase operations */
    113          static void              FLASH_MassErase(uint32_t Banks);
    114          void    FLASH_PageErase(uint32_t PageAddress);
    115          
    116          /* Option bytes control */
    117          static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WriteProtectPage);
    118          static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WriteProtectPage);
    119          static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t ReadProtectLevel);
    120          static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t UserConfig);
    121          static HAL_StatusTypeDef FLASH_OB_ProgramData(uint32_t Address, uint8_t Data);
    122          static uint32_t          FLASH_OB_GetWRP(void);
    123          static uint32_t          FLASH_OB_GetRDP(void);
    124          static uint8_t           FLASH_OB_GetUser(void);
    125          
    126          /**
    127            * @}
    128            */
    129          
    130          /* Exported functions ---------------------------------------------------------*/
    131          /** @defgroup FLASHEx_Exported_Functions FLASHEx Exported Functions
    132            * @{
    133            */
    134            
    135          /** @defgroup FLASHEx_Exported_Functions_Group1 FLASHEx Memory Erasing functions
    136           *  @brief   FLASH Memory Erasing functions
    137            *
    138          @verbatim   
    139            ==============================================================================
    140                          ##### FLASH Erasing Programming functions ##### 
    141            ==============================================================================
    142          
    143              [..] The FLASH Memory Erasing functions, includes the following functions:
    144              (+) @ref HAL_FLASHEx_Erase: return only when erase has been done
    145              (+) @ref HAL_FLASHEx_Erase_IT: end of erase is done when @ref HAL_FLASH_EndOfOperationCallback 
    146                  is called with parameter 0xFFFFFFFF
    147          
    148              [..] Any operation of erase should follow these steps:
    149              (#) Call the @ref HAL_FLASH_Unlock() function to enable the flash control register and 
    150                  program memory access.
    151              (#) Call the desired function to erase page.
    152              (#) Call the @ref HAL_FLASH_Lock() to disable the flash program memory access 
    153                 (recommended to protect the FLASH memory against possible unwanted operation).
    154          
    155          @endverbatim
    156            * @{
    157            */
    158            
    159          
    160          /**
    161            * @brief  Perform a mass erase or erase the specified FLASH memory pages
    162            * @note   To correctly run this function, the @ref HAL_FLASH_Unlock() function
    163            *         must be called before.
    164            *         Call the @ref HAL_FLASH_Lock() to disable the flash memory access 
    165            *         (recommended to protect the FLASH memory against possible unwanted operation)
    166            * @param[in]  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
    167            *         contains the configuration information for the erasing.
    168            *
    169            * @param[out]  PageError pointer to variable  that
    170            *         contains the configuration information on faulty page in case of error
    171            *         (0xFFFFFFFF means that all the pages have been correctly erased)
    172            *
    173            * @retval HAL_StatusTypeDef HAL Status
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
    176          {
   \                     HAL_FLASHEx_Erase:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    177            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000006   0x2601             MOVS     R6,#+1
    178            uint32_t address = 0U;
   \   00000008   0x2700             MOVS     R7,#+0
    179          
    180            /* Process Locked */
    181            __HAL_LOCK(&pFlash);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000000E   0x7E00             LDRB     R0,[R0, #+24]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD101             BNE.N    ??HAL_FLASHEx_Erase_0
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE04C             B.N      ??HAL_FLASHEx_Erase_1
   \                     ??HAL_FLASHEx_Erase_0:
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x7601             STRB     R1,[R0, #+24]
    182          
    183            /* Check the parameters */
    184            assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    185          
    186            if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD116             BNE.N    ??HAL_FLASHEx_Erase_2
    187            {
    188          #if defined(FLASH_BANK2_END)
    189              if (pEraseInit->Banks == FLASH_BANK_BOTH)
    190              {
    191                /* Mass Erase requested for Bank1 and Bank2 */
    192                /* Wait for last operation to be completed */
    193                if ((FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK) && \
    194                    (FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK))
    195                {
    196                  /*Mass erase to be done*/
    197                  FLASH_MassErase(FLASH_BANK_BOTH);
    198                  
    199                  /* Wait for last operation to be completed */
    200                  if ((FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK) && \
    201                      (FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK))
    202                  {
    203                    status = HAL_OK;
    204                  }
    205                  
    206                  /* If the erase operation is completed, disable the MER Bit */
    207                  CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
    208                  CLEAR_BIT(FLASH->CR2, FLASH_CR2_MER);
    209                }
    210              }
    211              else if (pEraseInit->Banks == FLASH_BANK_2)
    212              {
    213                /* Mass Erase requested for Bank2 */
    214                /* Wait for last operation to be completed */
    215                if (FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
    216                {
    217                  /*Mass erase to be done*/
    218                  FLASH_MassErase(FLASH_BANK_2);
    219                  
    220                  /* Wait for last operation to be completed */
    221                  status = FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE);
    222                  
    223                  /* If the erase operation is completed, disable the MER Bit */
    224                  CLEAR_BIT(FLASH->CR2, FLASH_CR2_MER);
    225                }
    226              }
    227              else 
    228          #endif /* FLASH_BANK2_END */
    229              {
    230                /* Mass Erase requested for Bank1 */
    231                /* Wait for last operation to be completed */
    232                if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
   \   00000026   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000002A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD139             BNE.N    ??HAL_FLASHEx_Erase_3
    233                {
    234                  /*Mass erase to be done*/
    235                  FLASH_MassErase(FLASH_BANK_1);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       FLASH_MassErase
    236                  
    237                  /* Wait for last operation to be completed */
    238                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000038   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000003C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000040   0x0006             MOVS     R6,R0
    239                  
    240                  /* If the erase operation is completed, disable the MER Bit */
    241                  CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40022010
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40022010
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE028             B.N      ??HAL_FLASHEx_Erase_3
    242                }
    243              }
    244            }
    245            else
    246            {
    247              /* Page Erase is requested */
    248              /* Check the parameters */
    249              assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    250              assert_param(IS_FLASH_NB_PAGES(pEraseInit->PageAddress, pEraseInit->NbPages));
    251              
    252          #if defined(FLASH_BANK2_END)
    253              /* Page Erase requested on address located on bank2 */
    254              if(pEraseInit->PageAddress > FLASH_BANK1_END)
    255              {   
    256                /* Wait for last operation to be completed */
    257                if (FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
    258                {
    259                  /*Initialization of PageError variable*/
    260                  *PageError = 0xFFFFFFFFU;
    261                  
    262                  /* Erase by page by page to be done*/
    263                  for(address = pEraseInit->PageAddress;
    264                      address < (pEraseInit->PageAddress + (pEraseInit->NbPages)*FLASH_PAGE_SIZE);
    265                      address += FLASH_PAGE_SIZE)
    266                  {
    267                    FLASH_PageErase(address);
    268                    
    269                    /* Wait for last operation to be completed */
    270                    status = FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE);
    271                    
    272                    /* If the erase operation is completed, disable the PER Bit */
    273                    CLEAR_BIT(FLASH->CR2, FLASH_CR2_PER);
    274                    
    275                    if (status != HAL_OK)
    276                    {
    277                      /* In case of error, stop erase procedure and return the faulty address */
    278                      *PageError = address;
    279                      break;
    280                    }
    281                  }
    282                }
    283              }
    284              else
    285          #endif /* FLASH_BANK2_END */
    286             {
    287                /* Page Erase requested on address located on bank1 */
    288                /* Wait for last operation to be completed */
    289                if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
   \                     ??HAL_FLASHEx_Erase_2:
   \   00000054   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000058   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD122             BNE.N    ??HAL_FLASHEx_Erase_3
    290                {
    291                  /*Initialization of PageError variable*/
    292                  *PageError = 0xFFFFFFFFU;
   \   00000060   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000064   0x6028             STR      R0,[R5, #+0]
    293                  
    294                  /* Erase page by page to be done*/
    295                  for(address = pEraseInit->PageAddress;
   \   00000066   0x68A7             LDR      R7,[R4, #+8]
   \   00000068   0xE001             B.N      ??HAL_FLASHEx_Erase_4
    296                      address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
    297                      address += FLASH_PAGE_SIZE)
   \                     ??HAL_FLASHEx_Erase_5:
   \   0000006A   0xF517 0x6780      ADDS     R7,R7,#+1024
   \                     ??HAL_FLASHEx_Erase_4:
   \   0000006E   0x68E0             LDR      R0,[R4, #+12]
   \   00000070   0xF44F 0x6180      MOV      R1,#+1024
   \   00000074   0x68A2             LDR      R2,[R4, #+8]
   \   00000076   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000007A   0x4287             CMP      R7,R0
   \   0000007C   0xD213             BCS.N    ??HAL_FLASHEx_Erase_3
    298                  {
    299                    FLASH_PageErase(address);
   \   0000007E   0x0038             MOVS     R0,R7
   \   00000080   0x.... 0x....      BL       FLASH_PageErase
    300                    
    301                    /* Wait for last operation to be completed */
    302                    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000084   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000088   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000008C   0x0006             MOVS     R6,R0
    303                    
    304                    /* If the erase operation is completed, disable the PER Bit */
    305                    CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40022010
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40022010
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    306                    
    307                    if (status != HAL_OK)
   \   0000009E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A0   0x2E00             CMP      R6,#+0
   \   000000A2   0xD0E2             BEQ.N    ??HAL_FLASHEx_Erase_5
    308                    {
    309                      /* In case of error, stop erase procedure and return the faulty address */
    310                      *PageError = address;
   \   000000A4   0x602F             STR      R7,[R5, #+0]
    311                      break;
    312                    }
    313                  }
    314                }
    315              }
    316            }
    317          
    318            /* Process Unlocked */
    319            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_Erase_3:
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x7601             STRB     R1,[R0, #+24]
    320          
    321            return status;
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_Erase_1:
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    322          }
    323          
    324          /**
    325            * @brief  Perform a mass erase or erase the specified FLASH memory pages with interrupt enabled
    326            * @note   To correctly run this function, the @ref HAL_FLASH_Unlock() function
    327            *         must be called before.
    328            *         Call the @ref HAL_FLASH_Lock() to disable the flash memory access 
    329            *         (recommended to protect the FLASH memory against possible unwanted operation)
    330            * @param  pEraseInit pointer to an FLASH_EraseInitTypeDef structure that
    331            *         contains the configuration information for the erasing.
    332            *
    333            * @retval HAL_StatusTypeDef HAL Status
    334            */

   \                                 In section .text, align 2, keep-with-next
    335          HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
    336          {
   \                     HAL_FLASHEx_Erase_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
    337            HAL_StatusTypeDef status = HAL_OK;
   \   00000002   0x2400             MOVS     R4,#+0
    338          
    339            /* Process Locked */
    340            __HAL_LOCK(&pFlash);
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000008   0x7E09             LDRB     R1,[R1, #+24]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_FLASHEx_Erase_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE02E             B.N      ??HAL_FLASHEx_Erase_IT_1
   \                     ??HAL_FLASHEx_Erase_IT_0:
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x760A             STRB     R2,[R1, #+24]
    341          
    342            /* If procedure already ongoing, reject the next one */
    343            if (pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD001             BEQ.N    ??HAL_FLASHEx_Erase_IT_2
    344            {
    345              return HAL_ERROR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE023             B.N      ??HAL_FLASHEx_Erase_IT_1
    346            }
    347            
    348            /* Check the parameters */
    349            assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
    350          
    351            /* Enable End of FLASH Operation and Error source interrupts */
    352            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
   \                     ??HAL_FLASHEx_Erase_IT_2:
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40022010
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0xF451 0x51A0      ORRS     R1,R1,#0x1400
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable14_1  ;; 0x40022010
   \   00000036   0x6011             STR      R1,[R2, #+0]
    353          
    354          #if defined(FLASH_BANK2_END)
    355            /* Enable End of FLASH Operation and Error source interrupts */
    356            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP_BANK2 | FLASH_IT_ERR_BANK2);
    357            
    358          #endif
    359            if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x2902             CMP      R1,#+2
   \   0000003C   0xD107             BNE.N    ??HAL_FLASHEx_Erase_IT_3
    360            {
    361              /*Mass erase to be done*/
    362              pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000042   0x2202             MOVS     R2,#+2
   \   00000044   0x700A             STRB     R2,[R1, #+0]
    363                  FLASH_MassErase(pEraseInit->Banks);
   \   00000046   0x6840             LDR      R0,[R0, #+4]
   \   00000048   0x.... 0x....      BL       FLASH_MassErase
   \   0000004C   0xE00E             B.N      ??HAL_FLASHEx_Erase_IT_4
    364            }
    365            else
    366            {
    367              /* Erase by page to be done*/
    368          
    369              /* Check the parameters */
    370              assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
    371              assert_param(IS_FLASH_NB_PAGES(pEraseInit->PageAddress, pEraseInit->NbPages));
    372          
    373              pFlash.ProcedureOnGoing = FLASH_PROC_PAGEERASE;
   \                     ??HAL_FLASHEx_Erase_IT_3:
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x700A             STRB     R2,[R1, #+0]
    374              pFlash.DataRemaining = pEraseInit->NbPages;
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000005A   0x68C2             LDR      R2,[R0, #+12]
   \   0000005C   0x604A             STR      R2,[R1, #+4]
    375              pFlash.Address = pEraseInit->PageAddress;
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000062   0x6882             LDR      R2,[R0, #+8]
   \   00000064   0x608A             STR      R2,[R1, #+8]
    376          
    377              /*Erase 1st page and wait for IT*/
    378              FLASH_PageErase(pEraseInit->PageAddress);
   \   00000066   0x6880             LDR      R0,[R0, #+8]
   \   00000068   0x.... 0x....      BL       FLASH_PageErase
    379            }
    380          
    381            return status;
   \                     ??HAL_FLASHEx_Erase_IT_4:
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_Erase_IT_1:
   \   00000070   0xBD10             POP      {R4,PC}          ;; return
    382          }
    383          
    384          /**
    385            * @}
    386            */
    387          
    388          /** @defgroup FLASHEx_Exported_Functions_Group2 Option Bytes Programming functions
    389           *  @brief   Option Bytes Programming functions
    390            *
    391          @verbatim   
    392            ==============================================================================
    393                          ##### Option Bytes Programming functions ##### 
    394            ==============================================================================  
    395              [..]
    396              This subsection provides a set of functions allowing to control the FLASH 
    397              option bytes operations.
    398          
    399          @endverbatim
    400            * @{
    401            */
    402          
    403          /**
    404            * @brief  Erases the FLASH option bytes.
    405            * @note   This functions erases all option bytes except the Read protection (RDP).
    406            *         The function @ref HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    407            *         The function @ref HAL_FLASH_OB_Unlock() should be called before to unlock the options bytes
    408            *         The function @ref HAL_FLASH_OB_Launch() should be called after to force the reload of the options bytes
    409            *         (system reset will occur)
    410            * @retval HAL status
    411            */
    412          

   \                                 In section .text, align 2, keep-with-next
    413          HAL_StatusTypeDef HAL_FLASHEx_OBErase(void)
    414          {
   \                     HAL_FLASHEx_OBErase:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    415            uint8_t rdptmp = OB_RDP_LEVEL_0;
   \   00000002   0x24A5             MOVS     R4,#+165
    416            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000004   0x2501             MOVS     R5,#+1
    417          
    418            /* Get the actual read protection Option Byte value */
    419            rdptmp = FLASH_OB_GetRDP();
   \   00000006   0x.... 0x....      BL       FLASH_OB_GetRDP
   \   0000000A   0x0004             MOVS     R4,R0
    420          
    421            /* Wait for last operation to be completed */
    422            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   0000000C   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000010   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000014   0x0005             MOVS     R5,R0
    423          
    424            if(status == HAL_OK)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD128             BNE.N    ??HAL_FLASHEx_OBErase_0
    425            {
    426              /* Clean the error context */
    427              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x61C1             STR      R1,[R0, #+28]
    428          
    429              /* If the previous operation is completed, proceed to erase the option bytes */
    430              SET_BIT(FLASH->CR, FLASH_CR_OPTER);
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40022010
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40022010
   \   00000032   0x6008             STR      R0,[R1, #+0]
    431              SET_BIT(FLASH->CR, FLASH_CR_STRT);
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40022010
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40022010
   \   00000042   0x6008             STR      R0,[R1, #+0]
    432          
    433              /* Wait for last operation to be completed */
    434              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000044   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000048   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000004C   0x0005             MOVS     R5,R0
    435          
    436              /* If the erase operation is completed, disable the OPTER Bit */
    437              CLEAR_BIT(FLASH->CR, FLASH_CR_OPTER);
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40022010
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40022010
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    438          
    439              if(status == HAL_OK)
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD104             BNE.N    ??HAL_FLASHEx_OBErase_0
    440              {
    441                /* Restore the last read protection Option Byte value */
    442                status = FLASH_OB_RDP_LevelConfig(rdptmp);
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x.... 0x....      BL       FLASH_OB_RDP_LevelConfig
   \   0000006C   0x0005             MOVS     R5,R0
    443              }
    444            }
    445          
    446            /* Return the erase status */
    447            return status;
   \                     ??HAL_FLASHEx_OBErase_0:
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    448          }
    449          
    450          /**
    451            * @brief  Program option bytes
    452            * @note   The function @ref HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    453            *         The function @ref HAL_FLASH_OB_Unlock() should be called before to unlock the options bytes
    454            *         The function @ref HAL_FLASH_OB_Launch() should be called after to force the reload of the options bytes
    455            *         (system reset will occur)
    456            *
    457            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
    458            *         contains the configuration information for the programming.
    459            *
    460            * @retval HAL_StatusTypeDef HAL Status
    461            */

   \                                 In section .text, align 2, keep-with-next
    462          HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
    463          {
   \                     HAL_FLASHEx_OBProgram:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    464            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
    465          
    466            /* Process Locked */
    467            __HAL_LOCK(&pFlash);
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000000A   0x7E09             LDRB     R1,[R1, #+24]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_FLASHEx_OBProgram_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE04C             B.N      ??HAL_FLASHEx_OBProgram_1
   \                     ??HAL_FLASHEx_OBProgram_0:
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x760A             STRB     R2,[R1, #+24]
    468          
    469            /* Check the parameters */
    470            assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
    471          
    472            /* Write protection configuration */
    473            if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
   \   0000001C   0x7821             LDRB     R1,[R4, #+0]
   \   0000001E   0x07C9             LSLS     R1,R1,#+31
   \   00000020   0xD512             BPL.N    ??HAL_FLASHEx_OBProgram_2
    474            {
    475              assert_param(IS_WRPSTATE(pOBInit->WRPState));
    476              if (pOBInit->WRPState == OB_WRPSTATE_ENABLE)
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD103             BNE.N    ??HAL_FLASHEx_OBProgram_3
    477              {
    478                /* Enable of Write protection on the selected page */
    479                status = FLASH_OB_EnableWRP(pOBInit->WRPPage);
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0x.... 0x....      BL       FLASH_OB_EnableWRP
   \   0000002E   0xE002             B.N      ??HAL_FLASHEx_OBProgram_4
    480              }
    481              else
    482              {
    483                /* Disable of Write protection on the selected page */
    484                status = FLASH_OB_DisableWRP(pOBInit->WRPPage);
   \                     ??HAL_FLASHEx_OBProgram_3:
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x.... 0x....      BL       FLASH_OB_DisableWRP
    485              }
    486              if (status != HAL_OK)
   \                     ??HAL_FLASHEx_OBProgram_4:
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD005             BEQ.N    ??HAL_FLASHEx_OBProgram_2
    487              {
    488                /* Process Unlocked */
    489                __HAL_UNLOCK(&pFlash);
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x760A             STRB     R2,[R1, #+24]
    490                return status;
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xE032             B.N      ??HAL_FLASHEx_OBProgram_1
    491              }
    492            }
    493          
    494            /* Read protection configuration */
    495            if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
   \                     ??HAL_FLASHEx_OBProgram_2:
   \   00000048   0x7821             LDRB     R1,[R4, #+0]
   \   0000004A   0x0789             LSLS     R1,R1,#+30
   \   0000004C   0xD50B             BPL.N    ??HAL_FLASHEx_OBProgram_5
    496            {
    497              status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
   \   0000004E   0x7C20             LDRB     R0,[R4, #+16]
   \   00000050   0x.... 0x....      BL       FLASH_OB_RDP_LevelConfig
    498              if (status != HAL_OK)
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD005             BEQ.N    ??HAL_FLASHEx_OBProgram_5
    499              {
    500                /* Process Unlocked */
    501                __HAL_UNLOCK(&pFlash);
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x760A             STRB     R2,[R1, #+24]
    502                return status;
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xE023             B.N      ??HAL_FLASHEx_OBProgram_1
    503              }
    504            }
    505          
    506            /* USER configuration */
    507            if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
   \                     ??HAL_FLASHEx_OBProgram_5:
   \   00000066   0x7821             LDRB     R1,[R4, #+0]
   \   00000068   0x0749             LSLS     R1,R1,#+29
   \   0000006A   0xD50B             BPL.N    ??HAL_FLASHEx_OBProgram_6
    508            {
    509              status = FLASH_OB_UserConfig(pOBInit->USERConfig);
   \   0000006C   0x7C60             LDRB     R0,[R4, #+17]
   \   0000006E   0x.... 0x....      BL       FLASH_OB_UserConfig
    510              if (status != HAL_OK)
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD005             BEQ.N    ??HAL_FLASHEx_OBProgram_6
    511              {
    512                /* Process Unlocked */
    513                __HAL_UNLOCK(&pFlash);
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000007C   0x2200             MOVS     R2,#+0
   \   0000007E   0x760A             STRB     R2,[R1, #+24]
    514                return status;
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0xE014             B.N      ??HAL_FLASHEx_OBProgram_1
    515              }
    516            }
    517          
    518            /* DATA configuration*/
    519            if((pOBInit->OptionType & OPTIONBYTE_DATA) == OPTIONBYTE_DATA)
   \                     ??HAL_FLASHEx_OBProgram_6:
   \   00000084   0x7821             LDRB     R1,[R4, #+0]
   \   00000086   0x0709             LSLS     R1,R1,#+28
   \   00000088   0xD50C             BPL.N    ??HAL_FLASHEx_OBProgram_7
    520            {
    521              status = FLASH_OB_ProgramData(pOBInit->DATAAddress, pOBInit->DATAData);
   \   0000008A   0x7E21             LDRB     R1,[R4, #+24]
   \   0000008C   0x6960             LDR      R0,[R4, #+20]
   \   0000008E   0x.... 0x....      BL       FLASH_OB_ProgramData
    522              if (status != HAL_OK)
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD005             BEQ.N    ??HAL_FLASHEx_OBProgram_7
    523              {
    524                /* Process Unlocked */
    525                __HAL_UNLOCK(&pFlash);
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000009C   0x2200             MOVS     R2,#+0
   \   0000009E   0x760A             STRB     R2,[R1, #+24]
    526                return status;
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0xE004             B.N      ??HAL_FLASHEx_OBProgram_1
    527              }
    528            }
    529          
    530            /* Process Unlocked */
    531            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASHEx_OBProgram_7:
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000000A8   0x2200             MOVS     R2,#+0
   \   000000AA   0x760A             STRB     R2,[R1, #+24]
    532          
    533            return status;
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_FLASHEx_OBProgram_1:
   \   000000AE   0xBD10             POP      {R4,PC}          ;; return
    534          }
    535          
    536          /**
    537            * @brief  Get the Option byte configuration
    538            * @param  pOBInit pointer to an FLASH_OBInitStruct structure that
    539            *         contains the configuration information for the programming.
    540            *
    541            * @retval None
    542            */

   \                                 In section .text, align 2, keep-with-next
    543          void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
    544          {
   \                     HAL_FLASHEx_OBGetConfig:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    545            pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER;
   \   00000004   0x2007             MOVS     R0,#+7
   \   00000006   0x6020             STR      R0,[R4, #+0]
    546          
    547            /*Get WRP*/
    548            pOBInit->WRPPage = FLASH_OB_GetWRP();
   \   00000008   0x.... 0x....      BL       FLASH_OB_GetWRP
   \   0000000C   0x60A0             STR      R0,[R4, #+8]
    549          
    550            /*Get RDP Level*/
    551            pOBInit->RDPLevel = FLASH_OB_GetRDP();
   \   0000000E   0x.... 0x....      BL       FLASH_OB_GetRDP
   \   00000012   0x7420             STRB     R0,[R4, #+16]
    552          
    553            /*Get USER*/
    554            pOBInit->USERConfig = FLASH_OB_GetUser();
   \   00000014   0x.... 0x....      BL       FLASH_OB_GetUser
   \   00000018   0x7460             STRB     R0,[R4, #+17]
    555          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    556          
    557          /**
    558            * @brief  Get the Option byte user data
    559            * @param  DATAAdress Address of the option byte DATA
    560            *          This parameter can be one of the following values:
    561            *            @arg @ref OB_DATA_ADDRESS_DATA0
    562            *            @arg @ref OB_DATA_ADDRESS_DATA1
    563            * @retval Value programmed in USER data
    564            */

   \                                 In section .text, align 2, keep-with-next
    565          uint32_t HAL_FLASHEx_OBGetUserData(uint32_t DATAAdress)
    566          {
    567            uint32_t value = 0;
   \                     HAL_FLASHEx_OBGetUserData:
   \   00000000   0x2100             MOVS     R1,#+0
    568            
    569            if (DATAAdress == OB_DATA_ADDRESS_DATA0)
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable14_2  ;; 0x1ffff804
   \   00000006   0x4290             CMP      R0,R2
   \   00000008   0xD105             BNE.N    ??HAL_FLASHEx_OBGetUserData_0
    570            {
    571              /* Get value programmed in OB USER Data0 */
    572              value = READ_BIT(FLASH->OBR, FLASH_OBR_DATA0) >> FLASH_POSITION_OB_USERDATA0_BIT;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable14_3  ;; 0x4002201c
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF3C0 0x2187      UBFX     R1,R0,#+10,#+8
   \   00000014   0xE004             B.N      ??HAL_FLASHEx_OBGetUserData_1
    573            }
    574            else
    575            {
    576              /* Get value programmed in OB USER Data1 */
    577              value = READ_BIT(FLASH->OBR, FLASH_OBR_DATA1) >> FLASH_POSITION_OB_USERDATA1_BIT;
   \                     ??HAL_FLASHEx_OBGetUserData_0:
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14_3  ;; 0x4002201c
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF3C0 0x4187      UBFX     R1,R0,#+18,#+8
    578            }
    579            
    580            return value;
   \                     ??HAL_FLASHEx_OBGetUserData_1:
   \   00000020   0x0008             MOVS     R0,R1
   \   00000022   0x4770             BX       LR               ;; return
    581          }
    582          
    583          /**
    584            * @}
    585            */
    586          
    587          /**
    588            * @}
    589            */
    590          
    591          /** @addtogroup FLASHEx_Private_Functions
    592           * @{
    593           */
    594          
    595          /**
    596            * @brief  Full erase of FLASH memory Bank 
    597            * @param  Banks Banks to be erased
    598            *          This parameter can be one of the following values:
    599            *            @arg @ref FLASH_BANK_1 Bank1 to be erased
    600            @if STM32F101xG
    601            *            @arg @ref FLASH_BANK_2 Bank2 to be erased
    602            *            @arg @ref FLASH_BANK_BOTH Bank1 and Bank2 to be erased
    603            @endif
    604            @if STM32F103xG
    605            *            @arg @ref FLASH_BANK_2 Bank2 to be erased
    606            *            @arg @ref FLASH_BANK_BOTH Bank1 and Bank2 to be erased
    607            @endif
    608            *
    609            * @retval None
    610            */

   \                                 In section .text, align 2, keep-with-next
    611          static void FLASH_MassErase(uint32_t Banks)
    612          {
    613            /* Check the parameters */
    614            assert_param(IS_FLASH_BANK(Banks));
    615          
    616            /* Clean the error context */
    617            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     FLASH_MassErase:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x61C1             STR      R1,[R0, #+28]
    618          
    619          #if defined(FLASH_BANK2_END)
    620            if(Banks == FLASH_BANK_BOTH)
    621            {
    622              /* bank1 & bank2 will be erased*/
    623              SET_BIT(FLASH->CR, FLASH_CR_MER);
    624              SET_BIT(FLASH->CR2, FLASH_CR2_MER);
    625              SET_BIT(FLASH->CR, FLASH_CR_STRT);
    626              SET_BIT(FLASH->CR2, FLASH_CR2_STRT);
    627            }
    628            else if(Banks == FLASH_BANK_2)
    629            {
    630              /*Only bank2 will be erased*/
    631              SET_BIT(FLASH->CR2, FLASH_CR2_MER);
    632              SET_BIT(FLASH->CR2, FLASH_CR2_STRT);
    633            }
    634            else
    635            {
    636          #endif /* FLASH_BANK2_END */
    637          #if !defined(FLASH_BANK2_END)
    638            /* Prevent unused argument(s) compilation warning */
    639            UNUSED(Banks);
    640          #endif /* FLASH_BANK2_END */  
    641              /* Only bank1 will be erased*/
    642              SET_BIT(FLASH->CR, FLASH_CR_MER);
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40022010
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40022010
   \   00000016   0x6008             STR      R0,[R1, #+0]
    643              SET_BIT(FLASH->CR, FLASH_CR_STRT);
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40022010
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_1  ;; 0x40022010
   \   00000026   0x6008             STR      R0,[R1, #+0]
    644          #if defined(FLASH_BANK2_END)
    645            }
    646          #endif /* FLASH_BANK2_END */
    647          }
   \   00000028   0x4770             BX       LR               ;; return
    648          
    649          /**
    650            * @brief  Enable the write protection of the desired pages
    651            * @note   An option byte erase is done automatically in this function. 
    652            * @note   When the memory read protection level is selected (RDP level = 1), 
    653            *         it is not possible to program or erase the flash page i if
    654            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    655            * 
    656            * @param  WriteProtectPage specifies the page(s) to be write protected.
    657            *         The value of this parameter depend on device used within the same series 
    658            * @retval HAL status 
    659            */

   \                                 In section .text, align 2, keep-with-next
    660          static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WriteProtectPage)
    661          {
   \                     FLASH_OB_EnableWRP:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
    662            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2400             MOVS     R4,#+0
    663            uint16_t WRP0_Data = 0xFFFF;
   \   00000008   0xF64F 0x75FF      MOVW     R5,#+65535
    664          #if defined(FLASH_WRP1_WRP1)
    665            uint16_t WRP1_Data = 0xFFFF;
   \   0000000C   0xF64F 0x76FF      MOVW     R6,#+65535
    666          #endif /* FLASH_WRP1_WRP1 */
    667          #if defined(FLASH_WRP2_WRP2)
    668            uint16_t WRP2_Data = 0xFFFF;
   \   00000010   0xF64F 0x77FF      MOVW     R7,#+65535
    669          #endif /* FLASH_WRP2_WRP2 */
    670          #if defined(FLASH_WRP3_WRP3)
    671            uint16_t WRP3_Data = 0xFFFF;
   \   00000014   0xF64F 0x78FF      MOVW     R8,#+65535
    672          #endif /* FLASH_WRP3_WRP3 */
    673            
    674            /* Check the parameters */
    675            assert_param(IS_OB_WRP(WriteProtectPage));
    676              
    677            /* Get current write protected pages and the new pages to be protected ******/
    678            WriteProtectPage = (uint32_t)(~((~FLASH_OB_GetWRP()) | WriteProtectPage));
   \   00000018   0x.... 0x....      BL       FLASH_OB_GetWRP
   \   0000001C   0xEA30 0x0909      BICS     R9,R0,R9
    679            
    680          #if defined(OB_WRP_PAGES0TO15MASK)
    681            WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO15MASK);
    682          #elif defined(OB_WRP_PAGES0TO31MASK)
    683            WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO31MASK);
   \   00000020   0xF019 0x00FF      ANDS     R0,R9,#0xFF
   \   00000024   0x0005             MOVS     R5,R0
    684          #endif /* OB_WRP_PAGES0TO31MASK */
    685            
    686          #if defined(OB_WRP_PAGES16TO31MASK)
    687            WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES16TO31MASK) >> 8U);
    688          #elif defined(OB_WRP_PAGES32TO63MASK)
    689            WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO63MASK) >> 8U);
   \   00000026   0xF3C9 0x2007      UBFX     R0,R9,#+8,#+8
   \   0000002A   0x0006             MOVS     R6,R0
    690          #endif /* OB_WRP_PAGES32TO63MASK */
    691           
    692          #if defined(OB_WRP_PAGES64TO95MASK)
    693            WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES64TO95MASK) >> 16U);
   \   0000002C   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x0007             MOVS     R7,R0
    694          #endif /* OB_WRP_PAGES64TO95MASK */
    695          #if defined(OB_WRP_PAGES32TO47MASK)
    696            WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO47MASK) >> 16U);
    697          #endif /* OB_WRP_PAGES32TO47MASK */
    698          
    699          #if defined(OB_WRP_PAGES96TO127MASK)
    700            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES96TO127MASK) >> 24U); 
   \   00000034   0xEA5F 0x6019      LSRS     R0,R9,#+24
   \   00000038   0x4680             MOV      R8,R0
    701          #elif defined(OB_WRP_PAGES48TO255MASK)
    702            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO255MASK) >> 24U); 
    703          #elif defined(OB_WRP_PAGES48TO511MASK)
    704            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO511MASK) >> 24U); 
    705          #elif defined(OB_WRP_PAGES48TO127MASK)
    706            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO127MASK) >> 24U); 
    707          #endif /* OB_WRP_PAGES96TO127MASK */
    708            
    709            /* Wait for last operation to be completed */
    710            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   0000003A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000003E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000042   0x0004             MOVS     R4,R0
    711          
    712            if(status == HAL_OK)
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD154             BNE.N    ??FLASH_OB_EnableWRP_0
    713            { 
    714              /* Clean the error context */
    715              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000004A   0x....             LDR.N    R0,??DataTable14
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x61C1             STR      R1,[R0, #+28]
    716          
    717              /* To be able to write again option byte, need to perform a option byte erase */
    718              status = HAL_FLASHEx_OBErase();
   \   00000050   0x.... 0x....      BL       HAL_FLASHEx_OBErase
   \   00000054   0x0004             MOVS     R4,R0
    719              if (status == HAL_OK)  
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x2C00             CMP      R4,#+0
   \   0000005A   0xD14B             BNE.N    ??FLASH_OB_EnableWRP_0
    720              {
    721                /* Enable write protection */
    722                SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \   0000005C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000064   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000066   0x6008             STR      R0,[R1, #+0]
    723          
    724          #if defined(FLASH_WRP0_WRP0)
    725                if(WRP0_Data != 0xFFU)
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0x2DFF             CMP      R5,#+255
   \   0000006C   0xD009             BEQ.N    ??FLASH_OB_EnableWRP_1
    726                {
    727                  OB->WRP0 &= WRP0_Data;
   \   0000006E   0x....             LDR.N    R0,??DataTable14_4  ;; 0x1ffff808
   \   00000070   0x8800             LDRH     R0,[R0, #+0]
   \   00000072   0x4028             ANDS     R0,R5,R0
   \   00000074   0x....             LDR.N    R1,??DataTable14_4  ;; 0x1ffff808
   \   00000076   0x8008             STRH     R0,[R1, #+0]
    728                  
    729                  /* Wait for last operation to be completed */
    730                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000078   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000007C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000080   0x0004             MOVS     R4,R0
    731                }
    732          #endif /* FLASH_WRP0_WRP0 */
    733          
    734          #if defined(FLASH_WRP1_WRP1)
    735                if((status == HAL_OK) && (WRP1_Data != 0xFFU))
   \                     ??FLASH_OB_EnableWRP_1:
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x2C00             CMP      R4,#+0
   \   00000086   0xD10C             BNE.N    ??FLASH_OB_EnableWRP_2
   \   00000088   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000008A   0x2EFF             CMP      R6,#+255
   \   0000008C   0xD009             BEQ.N    ??FLASH_OB_EnableWRP_2
    736                {
    737                  OB->WRP1 &= WRP1_Data;
   \   0000008E   0x....             LDR.N    R0,??DataTable14_5  ;; 0x1ffff80a
   \   00000090   0x8800             LDRH     R0,[R0, #+0]
   \   00000092   0x4030             ANDS     R0,R6,R0
   \   00000094   0x....             LDR.N    R1,??DataTable14_5  ;; 0x1ffff80a
   \   00000096   0x8008             STRH     R0,[R1, #+0]
    738                  
    739                  /* Wait for last operation to be completed */
    740                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000098   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000009C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000A0   0x0004             MOVS     R4,R0
    741                }
    742          #endif /* FLASH_WRP1_WRP1 */
    743          
    744          #if defined(FLASH_WRP2_WRP2)
    745                if((status == HAL_OK) && (WRP2_Data != 0xFFU))
   \                     ??FLASH_OB_EnableWRP_2:
   \   000000A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A4   0x2C00             CMP      R4,#+0
   \   000000A6   0xD10C             BNE.N    ??FLASH_OB_EnableWRP_3
   \   000000A8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000AA   0x2FFF             CMP      R7,#+255
   \   000000AC   0xD009             BEQ.N    ??FLASH_OB_EnableWRP_3
    746                {
    747                  OB->WRP2 &= WRP2_Data;
   \   000000AE   0x....             LDR.N    R0,??DataTable14_6  ;; 0x1ffff80c
   \   000000B0   0x8800             LDRH     R0,[R0, #+0]
   \   000000B2   0x4038             ANDS     R0,R7,R0
   \   000000B4   0x....             LDR.N    R1,??DataTable14_6  ;; 0x1ffff80c
   \   000000B6   0x8008             STRH     R0,[R1, #+0]
    748                  
    749                  /* Wait for last operation to be completed */
    750                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   000000B8   0xF24C 0x3050      MOVW     R0,#+50000
   \   000000BC   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000C0   0x0004             MOVS     R4,R0
    751                }
    752          #endif /* FLASH_WRP2_WRP2 */
    753          
    754          #if defined(FLASH_WRP3_WRP3)
    755                if((status == HAL_OK) && (WRP3_Data != 0xFFU))
   \                     ??FLASH_OB_EnableWRP_3:
   \   000000C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C4   0x2C00             CMP      R4,#+0
   \   000000C6   0xD10F             BNE.N    ??FLASH_OB_EnableWRP_4
   \   000000C8   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000CC   0xF1B8 0x0FFF      CMP      R8,#+255
   \   000000D0   0xD00A             BEQ.N    ??FLASH_OB_EnableWRP_4
    756                {
    757                  OB->WRP3 &= WRP3_Data;
   \   000000D2   0x....             LDR.N    R0,??DataTable14_7  ;; 0x1ffff80e
   \   000000D4   0x8800             LDRH     R0,[R0, #+0]
   \   000000D6   0xEA18 0x0000      ANDS     R0,R8,R0
   \   000000DA   0x....             LDR.N    R1,??DataTable14_7  ;; 0x1ffff80e
   \   000000DC   0x8008             STRH     R0,[R1, #+0]
    758                  
    759                  /* Wait for last operation to be completed */
    760                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   000000DE   0xF24C 0x3050      MOVW     R0,#+50000
   \   000000E2   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000E6   0x0004             MOVS     R4,R0
    761                }
    762          #endif /* FLASH_WRP3_WRP3 */
    763          
    764                /* if the program operation is completed, disable the OPTPG Bit */
    765                CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \                     ??FLASH_OB_EnableWRP_4:
   \   000000E8   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0xF030 0x0010      BICS     R0,R0,#0x10
   \   000000F0   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    766              }
    767            }
    768            
    769            return status;
   \                     ??FLASH_OB_EnableWRP_0:
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    770          }
    771          
    772          /**
    773            * @brief  Disable the write protection of the desired pages
    774            * @note   An option byte erase is done automatically in this function. 
    775            * @note   When the memory read protection level is selected (RDP level = 1), 
    776            *         it is not possible to program or erase the flash page i if   
    777            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    778            * 
    779            * @param  WriteProtectPage specifies the page(s) to be write unprotected.
    780            *         The value of this parameter depend on device used within the same series 
    781            * @retval HAL status 
    782            */

   \                                 In section .text, align 2, keep-with-next
    783          static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WriteProtectPage)
    784          {
   \                     FLASH_OB_DisableWRP:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
    785            HAL_StatusTypeDef status = HAL_OK;
   \   00000006   0x2400             MOVS     R4,#+0
    786            uint16_t WRP0_Data = 0xFFFF;
   \   00000008   0xF64F 0x75FF      MOVW     R5,#+65535
    787          #if defined(FLASH_WRP1_WRP1)
    788            uint16_t WRP1_Data = 0xFFFF;
   \   0000000C   0xF64F 0x76FF      MOVW     R6,#+65535
    789          #endif /* FLASH_WRP1_WRP1 */
    790          #if defined(FLASH_WRP2_WRP2)
    791            uint16_t WRP2_Data = 0xFFFF;
   \   00000010   0xF64F 0x77FF      MOVW     R7,#+65535
    792          #endif /* FLASH_WRP2_WRP2 */
    793          #if defined(FLASH_WRP3_WRP3)
    794            uint16_t WRP3_Data = 0xFFFF;
   \   00000014   0xF64F 0x78FF      MOVW     R8,#+65535
    795          #endif /* FLASH_WRP3_WRP3 */
    796            
    797            /* Check the parameters */
    798            assert_param(IS_OB_WRP(WriteProtectPage));
    799          
    800            /* Get current write protected pages and the new pages to be unprotected ******/
    801            WriteProtectPage = (FLASH_OB_GetWRP() | WriteProtectPage);
   \   00000018   0x.... 0x....      BL       FLASH_OB_GetWRP
   \   0000001C   0xEA50 0x0909      ORRS     R9,R0,R9
    802          
    803          #if defined(OB_WRP_PAGES0TO15MASK)
    804            WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO15MASK);
    805          #elif defined(OB_WRP_PAGES0TO31MASK)
    806            WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO31MASK);
   \   00000020   0xF019 0x00FF      ANDS     R0,R9,#0xFF
   \   00000024   0x0005             MOVS     R5,R0
    807          #endif /* OB_WRP_PAGES0TO31MASK */
    808            
    809          #if defined(OB_WRP_PAGES16TO31MASK)
    810            WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES16TO31MASK) >> 8U);
    811          #elif defined(OB_WRP_PAGES32TO63MASK)
    812            WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO63MASK) >> 8U);
   \   00000026   0xF3C9 0x2007      UBFX     R0,R9,#+8,#+8
   \   0000002A   0x0006             MOVS     R6,R0
    813          #endif /* OB_WRP_PAGES32TO63MASK */
    814           
    815          #if defined(OB_WRP_PAGES64TO95MASK)
    816            WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES64TO95MASK) >> 16U);
   \   0000002C   0xEA5F 0x4019      LSRS     R0,R9,#+16
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x0007             MOVS     R7,R0
    817          #endif /* OB_WRP_PAGES64TO95MASK */
    818          #if defined(OB_WRP_PAGES32TO47MASK)
    819            WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO47MASK) >> 16U);
    820          #endif /* OB_WRP_PAGES32TO47MASK */
    821          
    822          #if defined(OB_WRP_PAGES96TO127MASK)
    823            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES96TO127MASK) >> 24U); 
   \   00000034   0xEA5F 0x6019      LSRS     R0,R9,#+24
   \   00000038   0x4680             MOV      R8,R0
    824          #elif defined(OB_WRP_PAGES48TO255MASK)
    825            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO255MASK) >> 24U); 
    826          #elif defined(OB_WRP_PAGES48TO511MASK)
    827            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO511MASK) >> 24U); 
    828          #elif defined(OB_WRP_PAGES48TO127MASK)
    829            WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO127MASK) >> 24U); 
    830          #endif /* OB_WRP_PAGES96TO127MASK */
    831          
    832              
    833            /* Wait for last operation to be completed */
    834            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   0000003A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000003E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000042   0x0004             MOVS     R4,R0
    835          
    836            if(status == HAL_OK)
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD154             BNE.N    ??FLASH_OB_DisableWRP_0
    837            { 
    838              /* Clean the error context */
    839              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   0000004A   0x....             LDR.N    R0,??DataTable14
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x61C1             STR      R1,[R0, #+28]
    840          
    841              /* To be able to write again option byte, need to perform a option byte erase */
    842              status = HAL_FLASHEx_OBErase();
   \   00000050   0x.... 0x....      BL       HAL_FLASHEx_OBErase
   \   00000054   0x0004             MOVS     R4,R0
    843              if (status == HAL_OK)  
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x2C00             CMP      R4,#+0
   \   0000005A   0xD14B             BNE.N    ??FLASH_OB_DisableWRP_0
    844              {
    845                SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \   0000005C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000064   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000066   0x6008             STR      R0,[R1, #+0]
    846          
    847          #if defined(FLASH_WRP0_WRP0)
    848                if(WRP0_Data != 0xFFU)
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0x2DFF             CMP      R5,#+255
   \   0000006C   0xD009             BEQ.N    ??FLASH_OB_DisableWRP_1
    849                {
    850                  OB->WRP0 |= WRP0_Data;
   \   0000006E   0x....             LDR.N    R0,??DataTable14_4  ;; 0x1ffff808
   \   00000070   0x8800             LDRH     R0,[R0, #+0]
   \   00000072   0x4328             ORRS     R0,R5,R0
   \   00000074   0x....             LDR.N    R1,??DataTable14_4  ;; 0x1ffff808
   \   00000076   0x8008             STRH     R0,[R1, #+0]
    851                  
    852                  /* Wait for last operation to be completed */
    853                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000078   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000007C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000080   0x0004             MOVS     R4,R0
    854                }
    855          #endif /* FLASH_WRP0_WRP0 */
    856          
    857          #if defined(FLASH_WRP1_WRP1)
    858                if((status == HAL_OK) && (WRP1_Data != 0xFFU))
   \                     ??FLASH_OB_DisableWRP_1:
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x2C00             CMP      R4,#+0
   \   00000086   0xD10C             BNE.N    ??FLASH_OB_DisableWRP_2
   \   00000088   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000008A   0x2EFF             CMP      R6,#+255
   \   0000008C   0xD009             BEQ.N    ??FLASH_OB_DisableWRP_2
    859                {
    860                  OB->WRP1 |= WRP1_Data;
   \   0000008E   0x....             LDR.N    R0,??DataTable14_5  ;; 0x1ffff80a
   \   00000090   0x8800             LDRH     R0,[R0, #+0]
   \   00000092   0x4330             ORRS     R0,R6,R0
   \   00000094   0x....             LDR.N    R1,??DataTable14_5  ;; 0x1ffff80a
   \   00000096   0x8008             STRH     R0,[R1, #+0]
    861                  
    862                  /* Wait for last operation to be completed */
    863                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000098   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000009C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000A0   0x0004             MOVS     R4,R0
    864                }
    865          #endif /* FLASH_WRP1_WRP1 */
    866          
    867          #if defined(FLASH_WRP2_WRP2)
    868                if((status == HAL_OK) && (WRP2_Data != 0xFFU))
   \                     ??FLASH_OB_DisableWRP_2:
   \   000000A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A4   0x2C00             CMP      R4,#+0
   \   000000A6   0xD10C             BNE.N    ??FLASH_OB_DisableWRP_3
   \   000000A8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000AA   0x2FFF             CMP      R7,#+255
   \   000000AC   0xD009             BEQ.N    ??FLASH_OB_DisableWRP_3
    869                {
    870                  OB->WRP2 |= WRP2_Data;
   \   000000AE   0x....             LDR.N    R0,??DataTable14_6  ;; 0x1ffff80c
   \   000000B0   0x8800             LDRH     R0,[R0, #+0]
   \   000000B2   0x4338             ORRS     R0,R7,R0
   \   000000B4   0x....             LDR.N    R1,??DataTable14_6  ;; 0x1ffff80c
   \   000000B6   0x8008             STRH     R0,[R1, #+0]
    871                  
    872                  /* Wait for last operation to be completed */
    873                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   000000B8   0xF24C 0x3050      MOVW     R0,#+50000
   \   000000BC   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000C0   0x0004             MOVS     R4,R0
    874                }
    875          #endif /* FLASH_WRP2_WRP2 */
    876          
    877          #if defined(FLASH_WRP3_WRP3)
    878                if((status == HAL_OK) && (WRP3_Data != 0xFFU))
   \                     ??FLASH_OB_DisableWRP_3:
   \   000000C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C4   0x2C00             CMP      R4,#+0
   \   000000C6   0xD10F             BNE.N    ??FLASH_OB_DisableWRP_4
   \   000000C8   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000CC   0xF1B8 0x0FFF      CMP      R8,#+255
   \   000000D0   0xD00A             BEQ.N    ??FLASH_OB_DisableWRP_4
    879                {
    880                  OB->WRP3 |= WRP3_Data;
   \   000000D2   0x....             LDR.N    R0,??DataTable14_7  ;; 0x1ffff80e
   \   000000D4   0x8800             LDRH     R0,[R0, #+0]
   \   000000D6   0xEA58 0x0000      ORRS     R0,R8,R0
   \   000000DA   0x....             LDR.N    R1,??DataTable14_7  ;; 0x1ffff80e
   \   000000DC   0x8008             STRH     R0,[R1, #+0]
    881                  
    882                  /* Wait for last operation to be completed */
    883                  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   000000DE   0xF24C 0x3050      MOVW     R0,#+50000
   \   000000E2   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   000000E6   0x0004             MOVS     R4,R0
    884                }
    885          #endif /* FLASH_WRP3_WRP3 */
    886          
    887                /* if the program operation is completed, disable the OPTPG Bit */
    888                CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \                     ??FLASH_OB_DisableWRP_4:
   \   000000E8   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0xF030 0x0010      BICS     R0,R0,#0x10
   \   000000F0   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    889              }
    890            }
    891            return status;
   \                     ??FLASH_OB_DisableWRP_0:
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    892          }
    893          
    894          /**
    895            * @brief  Set the read protection level.
    896            * @param  ReadProtectLevel specifies the read protection level.
    897            *         This parameter can be one of the following values:
    898            *            @arg @ref OB_RDP_LEVEL_0 No protection
    899            *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
    900            * @retval HAL status
    901            */

   \                                 In section .text, align 2, keep-with-next
    902          static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t ReadProtectLevel)
    903          {
   \                     FLASH_OB_RDP_LevelConfig:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    904            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    905            
    906            /* Check the parameters */
    907            assert_param(IS_OB_RDP_LEVEL(ReadProtectLevel));
    908            
    909            /* Wait for last operation to be completed */
    910            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000006   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000E   0x0005             MOVS     R5,R0
    911            
    912            if(status == HAL_OK)
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD130             BNE.N    ??FLASH_OB_RDP_LevelConfig_0
    913            { 
    914              /* Clean the error context */
    915              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000016   0x....             LDR.N    R0,??DataTable14
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x61C1             STR      R1,[R0, #+28]
    916              
    917              /* If the previous operation is completed, proceed to erase the option bytes */
    918              SET_BIT(FLASH->CR, FLASH_CR_OPTER);
   \   0000001C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000024   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000026   0x6008             STR      R0,[R1, #+0]
    919              SET_BIT(FLASH->CR, FLASH_CR_STRT);
   \   00000028   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000030   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000032   0x6008             STR      R0,[R1, #+0]
    920          
    921              /* Wait for last operation to be completed */
    922              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000034   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000038   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000003C   0x0005             MOVS     R5,R0
    923          
    924              /* If the erase operation is completed, disable the OPTER Bit */
    925              CLEAR_BIT(FLASH->CR, FLASH_CR_OPTER);
   \   0000003E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000046   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000048   0x6008             STR      R0,[R1, #+0]
    926          
    927              if(status == HAL_OK)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD113             BNE.N    ??FLASH_OB_RDP_LevelConfig_0
    928              {
    929                /* Enable the Option Bytes Programming operation */
    930                SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \   00000050   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000058   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    931                
    932                WRITE_REG(OB->RDP, ReadProtectLevel);
   \   0000005C   0x....             LDR.N    R0,??DataTable14_8  ;; 0x1ffff800
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0x8004             STRH     R4,[R0, #+0]
    933                
    934                /* Wait for last operation to be completed */
    935                status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); 
   \   00000062   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000066   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000006A   0x0005             MOVS     R5,R0
    936                
    937                /* if the program operation is completed, disable the OPTPG Bit */
    938                CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \   0000006C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000074   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000076   0x6008             STR      R0,[R1, #+0]
    939              }
    940            }
    941            
    942            return status;
   \                     ??FLASH_OB_RDP_LevelConfig_0:
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    943          }
    944          
    945          /**
    946            * @brief  Program the FLASH User Option Byte.    
    947            * @note   Programming of the OB should be performed only after an erase (otherwise PGERR occurs)
    948            * @param  UserConfig The FLASH User Option Bytes values FLASH_OBR_IWDG_SW(Bit2), 
    949            *         FLASH_OBR_nRST_STOP(Bit3),FLASH_OBR_nRST_STDBY(Bit4).
    950            *         And BFBF2(Bit5) for STM32F101xG and STM32F103xG . 
    951            * @retval HAL status
    952            */

   \                                 In section .text, align 2, keep-with-next
    953          static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t UserConfig)
    954          {
   \                     FLASH_OB_UserConfig:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    955            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    956          
    957            /* Check the parameters */
    958            assert_param(IS_OB_IWDG_SOURCE((UserConfig&OB_IWDG_SW)));
    959            assert_param(IS_OB_STOP_SOURCE((UserConfig&OB_STOP_NO_RST)));
    960            assert_param(IS_OB_STDBY_SOURCE((UserConfig&OB_STDBY_NO_RST)));
    961          #if defined(FLASH_BANK2_END)
    962            assert_param(IS_OB_BOOT1((UserConfig&OB_BOOT1_SET)));
    963          #endif /* FLASH_BANK2_END */
    964          
    965            /* Wait for last operation to be completed */
    966            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000006   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000A   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000E   0x0005             MOVS     R5,R0
    967            
    968            if(status == HAL_OK)
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD118             BNE.N    ??FLASH_OB_UserConfig_0
    969            {     
    970              /* Clean the error context */
    971              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000016   0x....             LDR.N    R0,??DataTable14
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x61C1             STR      R1,[R0, #+28]
    972          
    973              /* Enable the Option Bytes Programming operation */
    974              SET_BIT(FLASH->CR, FLASH_CR_OPTPG); 
   \   0000001C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000024   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000026   0x6008             STR      R0,[R1, #+0]
    975           
    976          #if defined(FLASH_BANK2_END)
    977              OB->USER = (UserConfig | 0xF0U);
    978          #else
    979              OB->USER = (UserConfig | 0x88U);
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0xF054 0x0088      ORRS     R0,R4,#0x88
   \   0000002E   0x....             LDR.N    R1,??DataTable14_9  ;; 0x1ffff802
   \   00000030   0x8008             STRH     R0,[R1, #+0]
    980          #endif /* FLASH_BANK2_END */
    981          
    982              /* Wait for last operation to be completed */
    983              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000032   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000036   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000003A   0x0005             MOVS     R5,R0
    984          
    985              /* if the program operation is completed, disable the OPTPG Bit */
    986              CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \   0000003C   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000044   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000046   0x6008             STR      R0,[R1, #+0]
    987            }
    988            
    989            return status; 
   \                     ??FLASH_OB_UserConfig_0:
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    990          }
    991          
    992          /**
    993            * @brief  Programs a half word at a specified Option Byte Data address.
    994            * @note   The function @ref HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    995            *         The function @ref HAL_FLASH_OB_Unlock() should be called before to unlock the options bytes
    996            *         The function @ref HAL_FLASH_OB_Launch() should be called after to force the reload of the options bytes 
    997            *         (system reset will occur)
    998            *         Programming of the OB should be performed only after an erase (otherwise PGERR occurs)
    999            * @param  Address specifies the address to be programmed.
   1000            *         This parameter can be 0x1FFFF804 or 0x1FFFF806. 
   1001            * @param  Data specifies the data to be programmed.
   1002            * @retval HAL status
   1003            */

   \                                 In section .text, align 2, keep-with-next
   1004          static HAL_StatusTypeDef FLASH_OB_ProgramData(uint32_t Address, uint8_t Data)
   1005          {
   \                     FLASH_OB_ProgramData:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1006            HAL_StatusTypeDef status = HAL_ERROR;
   \   00000006   0x2601             MOVS     R6,#+1
   1007            
   1008            /* Check the parameters */
   1009            assert_param(IS_OB_DATA_ADDRESS(Address));
   1010            
   1011            /* Wait for last operation to be completed */
   1012            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   00000008   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000C   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000010   0x0006             MOVS     R6,R0
   1013            
   1014            if(status == HAL_OK)
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD115             BNE.N    ??FLASH_OB_ProgramData_0
   1015            {
   1016              /* Clean the error context */
   1017              pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000018   0x....             LDR.N    R0,??DataTable14
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
   1018          
   1019              /* Enables the Option Bytes Programming operation */
   1020              SET_BIT(FLASH->CR, FLASH_CR_OPTPG); 
   \   0000001E   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000026   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1021              *(__IO uint16_t*)Address = Data;
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x8025             STRH     R5,[R4, #+0]
   1022              
   1023              /* Wait for last operation to be completed */
   1024              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   0000002E   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000032   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000036   0x0006             MOVS     R6,R0
   1025              
   1026              /* If the program operation is completed, disable the OPTPG Bit */
   1027              CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
   \   00000038   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000040   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000042   0x6008             STR      R0,[R1, #+0]
   1028            }
   1029            /* Return the Option Byte Data Program Status */
   1030            return status;
   \                     ??FLASH_OB_ProgramData_0:
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
   1031          }
   1032          
   1033          /**
   1034            * @brief  Return the FLASH Write Protection Option Bytes value.
   1035            * @retval The FLASH Write Protection Option Bytes value
   1036            */

   \                                 In section .text, align 2, keep-with-next
   1037          static uint32_t FLASH_OB_GetWRP(void)
   1038          {
   1039            /* Return the FLASH write protection Register value */
   1040            return (uint32_t)(READ_REG(FLASH->WRPR));
   \                     FLASH_OB_GetWRP:
   \   00000000   0x....             LDR.N    R0,??DataTable14_10  ;; 0x40022020
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1041          }
   1042          
   1043          /**
   1044            * @brief  Returns the FLASH Read Protection level.
   1045            * @retval FLASH RDP level
   1046            *         This parameter can be one of the following values:
   1047            *            @arg @ref OB_RDP_LEVEL_0 No protection
   1048            *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
   1049            */

   \                                 In section .text, align 2, keep-with-next
   1050          static uint32_t FLASH_OB_GetRDP(void)
   1051          {
   1052            uint32_t readstatus = OB_RDP_LEVEL_0;
   \                     FLASH_OB_GetRDP:
   \   00000000   0x20A5             MOVS     R0,#+165
   1053            uint32_t tmp_reg = 0U;
   \   00000002   0x2100             MOVS     R1,#+0
   1054            
   1055            /* Read RDP level bits */
   1056            tmp_reg = READ_BIT(FLASH->OBR, FLASH_OBR_RDPRT);
   \   00000004   0x....             LDR.N    R2,??DataTable14_3  ;; 0x4002201c
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   0000000C   0x0011             MOVS     R1,R2
   1057          
   1058            if (tmp_reg == FLASH_OBR_RDPRT)
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD101             BNE.N    ??FLASH_OB_GetRDP_0
   1059            {
   1060              readstatus = OB_RDP_LEVEL_1;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE000             B.N      ??FLASH_OB_GetRDP_1
   1061            }
   1062            else 
   1063            {
   1064              readstatus = OB_RDP_LEVEL_0;
   \                     ??FLASH_OB_GetRDP_0:
   \   00000016   0x20A5             MOVS     R0,#+165
   1065            }
   1066          
   1067            return readstatus;
   \                     ??FLASH_OB_GetRDP_1:
   \   00000018   0x4770             BX       LR               ;; return
   1068          }
   1069          
   1070          /**
   1071            * @brief  Return the FLASH User Option Byte value.
   1072            * @retval The FLASH User Option Bytes values: FLASH_OBR_IWDG_SW(Bit2), 
   1073            *         FLASH_OBR_nRST_STOP(Bit3),FLASH_OBR_nRST_STDBY(Bit4).
   1074            *         And FLASH_OBR_BFB2(Bit5) for STM32F101xG and STM32F103xG . 
   1075            */

   \                                 In section .text, align 2, keep-with-next
   1076          static uint8_t FLASH_OB_GetUser(void)
   1077          {
   1078            /* Return the User Option Byte */
   1079            return (uint8_t)((READ_REG(FLASH->OBR) & FLASH_OBR_USER) >> FLASH_POSITION_IWDGSW_BIT);
   \                     FLASH_OB_GetUser:
   \   00000000   0x....             LDR.N    R0,??DataTable14_3  ;; 0x4002201c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF3C0 0x0082      UBFX     R0,R0,#+2,#+3
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x4770             BX       LR               ;; return
   1080          }
   1081          
   1082          /**
   1083            * @}
   1084            */
   1085          
   1086          /**
   1087            * @}
   1088            */
   1089          
   1090          /** @addtogroup FLASH
   1091            * @{
   1092            */
   1093          
   1094          /** @addtogroup FLASH_Private_Functions
   1095           * @{
   1096           */
   1097          
   1098          /**
   1099            * @brief  Erase the specified FLASH memory page
   1100            * @param  PageAddress FLASH page to erase
   1101            *         The value of this parameter depend on device used within the same series      
   1102            * 
   1103            * @retval None
   1104            */

   \                                 In section .text, align 2, keep-with-next
   1105          void FLASH_PageErase(uint32_t PageAddress)
   1106          {
   1107            /* Clean the error context */
   1108            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \                     FLASH_PageErase:
   \   00000000   0x....             LDR.N    R1,??DataTable14
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x61CA             STR      R2,[R1, #+28]
   1109          
   1110          #if defined(FLASH_BANK2_END)
   1111            if(PageAddress > FLASH_BANK1_END)
   1112            { 
   1113              /* Proceed to erase the page */
   1114              SET_BIT(FLASH->CR2, FLASH_CR2_PER);
   1115              WRITE_REG(FLASH->AR2, PageAddress);
   1116              SET_BIT(FLASH->CR2, FLASH_CR2_STRT);
   1117            }
   1118            else
   1119            {
   1120          #endif /* FLASH_BANK2_END */
   1121              /* Proceed to erase the page */
   1122              SET_BIT(FLASH->CR, FLASH_CR_PER);
   \   00000006   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000000E   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40022010
   \   00000010   0x6011             STR      R1,[R2, #+0]
   1123              WRITE_REG(FLASH->AR, PageAddress);
   \   00000012   0x....             LDR.N    R1,??DataTable14_11  ;; 0x40022014
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1124              SET_BIT(FLASH->CR, FLASH_CR_STRT);
   \   00000016   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40022010
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000001E   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40022010
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1125          #if defined(FLASH_BANK2_END)
   1126            }
   1127          #endif /* FLASH_BANK2_END */
   1128          }
   \   00000022   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40022010         DC32     0x40022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x1FFFF804         DC32     0x1ffff804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x4002201C         DC32     0x4002201c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x1FFFF808         DC32     0x1ffff808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x1FFFF80A         DC32     0x1ffff80a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x1FFFF80C         DC32     0x1ffff80c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x1FFFF80E         DC32     0x1ffff80e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x1FFFF800         DC32     0x1ffff800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x1FFFF802         DC32     0x1ffff802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x40022020         DC32     0x40022020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x40022014         DC32     0x40022014
   1129          
   1130          /**
   1131            * @}
   1132            */
   1133          
   1134          /**
   1135            * @}
   1136            */
   1137          
   1138          #endif /* HAL_FLASH_MODULE_ENABLED */
   1139          /**
   1140            * @}
   1141            */
   1142          
   1143          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  FLASH_MassErase
       32  FLASH_OB_DisableWRP
             32 -> FLASH_OB_GetWRP
             32 -> FLASH_WaitForLastOperation
             32 -> HAL_FLASHEx_OBErase
       32  FLASH_OB_EnableWRP
             32 -> FLASH_OB_GetWRP
             32 -> FLASH_WaitForLastOperation
             32 -> HAL_FLASHEx_OBErase
        0  FLASH_OB_GetRDP
        0  FLASH_OB_GetUser
        0  FLASH_OB_GetWRP
       16  FLASH_OB_ProgramData
             16 -> FLASH_WaitForLastOperation
       16  FLASH_OB_RDP_LevelConfig
             16 -> FLASH_WaitForLastOperation
       16  FLASH_OB_UserConfig
             16 -> FLASH_WaitForLastOperation
        0  FLASH_PageErase
       24  HAL_FLASHEx_Erase
             24 -> FLASH_MassErase
             24 -> FLASH_PageErase
             24 -> FLASH_WaitForLastOperation
        8  HAL_FLASHEx_Erase_IT
              8 -> FLASH_MassErase
              8 -> FLASH_PageErase
       16  HAL_FLASHEx_OBErase
             16 -> FLASH_OB_GetRDP
             16 -> FLASH_OB_RDP_LevelConfig
             16 -> FLASH_WaitForLastOperation
        8  HAL_FLASHEx_OBGetConfig
              8 -> FLASH_OB_GetRDP
              8 -> FLASH_OB_GetUser
              8 -> FLASH_OB_GetWRP
        0  HAL_FLASHEx_OBGetUserData
        8  HAL_FLASHEx_OBProgram
              8 -> FLASH_OB_DisableWRP
              8 -> FLASH_OB_EnableWRP
              8 -> FLASH_OB_ProgramData
              8 -> FLASH_OB_RDP_LevelConfig
              8 -> FLASH_OB_UserConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      42  FLASH_MassErase
     252  FLASH_OB_DisableWRP
     252  FLASH_OB_EnableWRP
      26  FLASH_OB_GetRDP
      12  FLASH_OB_GetUser
       6  FLASH_OB_GetWRP
      74  FLASH_OB_ProgramData
     126  FLASH_OB_RDP_LevelConfig
      78  FLASH_OB_UserConfig
      36  FLASH_PageErase
     180  HAL_FLASHEx_Erase
     114  HAL_FLASHEx_Erase_IT
     116  HAL_FLASHEx_OBErase
      28  HAL_FLASHEx_OBGetConfig
      36  HAL_FLASHEx_OBGetUserData
     176  HAL_FLASHEx_OBProgram

 
 1 602 bytes in section .text
 
 1 602 bytes of CODE memory

Errors: none
Warnings: 1
