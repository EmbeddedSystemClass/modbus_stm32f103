###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  09:12:45 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\FreeModbus\User #
#                    ModbusSlaver.c                                           #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\FreeModbus\Use #
#                    rModbusSlaver.c" -D USE_FULL_LL_DRIVER -D                #
#                    USE_HAL_DRIVER -D STM32F103xB -lC "D:\projects\задания   #
#                    от работодателя\ЭМИС\EWARM\mb_v1.0/List\" -o             #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    Obj\" --no_cse --no_unroll --no_inline --no_code_motion  #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Full.h" -I           #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\UserModbusSlaver.lst                                 #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\UserModbusSlaver.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\FreeModbus\UserModbusSlaver.c
      1          #include "UserModbusSlaver.h"
      2          
      3          #include "hw_config.h"

  /**
    ^
"D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_adc.h",1  Warning[Pa050]: 
          non-native end of line sequence detected (this diagnostic is only
          issued once)
      4          #include "FreeRTOS.h"
      5          #include "task.h"
      6          #include "cmsis_os.h"
      7          #include "flash.h"
      8          /* ----------------------- Variables ---------------------------------*/

   \                                 In section .data, align 2
      9          USHORT   usDiscreteInputStart                             = DISCRETE_INPUT_START;
   \                     usDiscreteInputStart:
   \   00000000   0x0001             DC16 1

   \                                 In section .bss, align 2
     10          UCHAR    usDiscreteInputBuf[DISCRETE_INPUT_NDISCRETES/8]  ;
   \                     usDiscreteInputBuf:
   \   00000000                      DS8 2

   \                                 In section .data, align 2
     11          USHORT   usCoilStart                                      = COIL_START;
   \                     usCoilStart:
   \   00000000   0x0001             DC16 1

   \                                 In section .bss, align 4
     12          UCHAR    usCoilBuf[COIL_NCOILS/8]                         ;
   \                     usCoilBuf:
   \   00000000                      DS8 8

   \                                 In section .data, align 2
     13          USHORT   usRegInputStart                                  = REG_INPUT_START;
   \                     usRegInputStart:
   \   00000000   0x0001             DC16 1

   \                                 In section .bss, align 4
     14          USHORT   usRegInputBuf[REG_INPUT_NREGS]                   ;
   \                     usRegInputBuf:
   \   00000000                      DS8 200

   \                                 In section .data, align 2
     15          USHORT   usRegHoldingStart                                = REG_HOLDING_START;
   \                     usRegHoldingStart:
   \   00000000   0x0001             DC16 1

   \                                 In section .bss, align 4
     16          USHORT   usRegHoldingBuf[REG_HOLDING_NREGS]               ;
   \                     usRegHoldingBuf:
   \   00000000                      DS8 200
     17          

   \                                 In section .bss, align 4
     18          union FloatChar FlCh;
   \                     FlCh:
   \   00000000                      DS8 4
     19          extern osSemaphoreId FlashWriteSemHandle;///> semaphore Handle
     20          extern FlashQueue_typedef flash_queue_data;///> buf for holding registers
     21          
     22          
     23          
     24          
     25          //******************************                 **********************************
     26          
     27          //**********************************************************************************

   \                                 In section .text, align 2, keep-with-next
     28          eMBErrorCode
     29          eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
     30          {
   \                     eMBRegInputCB:
   \   00000000   0xB430             PUSH     {R4,R5}
     31              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000002   0x2300             MOVS     R3,#+0
     32              int             iRegIndex;
     33              if( ( usAddress >= REG_INPUT_START )///> checking validation of regiser addresses
     34                  && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) )
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD322             BCC.N    ??eMBRegInputCB_0
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   0x1854             ADDS     R4,R2,R1
   \   00000010   0x2C66             CMP      R4,#+102
   \   00000012   0xDA1D             BGE.N    ??eMBRegInputCB_0
     35              {
     36                  iRegIndex = ( int )( usAddress - usRegInputStart );
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x....             LDR.N    R4,??DataTable3
   \   00000018   0x8824             LDRH     R4,[R4, #+0]
   \   0000001A   0x1B09             SUBS     R1,R1,R4
     37                  /* saving ADC value to Input registers 40001 and 40002*/
     38                  usRegInputBuf[MB_INPUT_REG_FL_H] = FlCh.wd[0];
   \   0000001C   0x....             LDR.N    R4,??DataTable3_1
   \   0000001E   0x....             LDR.N    R5,??DataTable3_2
   \   00000020   0x882D             LDRH     R5,[R5, #+0]
   \   00000022   0x8025             STRH     R5,[R4, #+0]
     39                  usRegInputBuf[MB_INPUT_REG_FL_L] = FlCh.wd[1];
   \   00000024   0x....             LDR.N    R4,??DataTable3_1
   \   00000026   0x....             LDR.N    R5,??DataTable3_2
   \   00000028   0x886D             LDRH     R5,[R5, #+2]
   \   0000002A   0x8065             STRH     R5,[R4, #+2]
     40          
     41                  while( usNRegs > 0 )
   \                     ??eMBRegInputCB_1:
   \   0000002C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000002E   0x2A01             CMP      R2,#+1
   \   00000030   0xD30F             BCC.N    ??eMBRegInputCB_2
     42                  {
     43                      *pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] >> 8 );
   \   00000032   0x....             LDR.N    R4,??DataTable3_1
   \   00000034   0xF834 0x4011      LDRH     R4,[R4, R1, LSL #+1]
   \   00000038   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003A   0x0A24             LSRS     R4,R4,#+8
   \   0000003C   0x7004             STRB     R4,[R0, #+0]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
     44                      *pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] & 0xFF );
   \   00000040   0x....             LDR.N    R4,??DataTable3_1
   \   00000042   0xF834 0x4011      LDRH     R4,[R4, R1, LSL #+1]
   \   00000046   0x7004             STRB     R4,[R0, #+0]
   \   00000048   0x1C40             ADDS     R0,R0,#+1
     45                      iRegIndex++;
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
     46                      usNRegs--;
   \   0000004C   0x1E52             SUBS     R2,R2,#+1
   \   0000004E   0xE7ED             B.N      ??eMBRegInputCB_1
     47                  }
     48              }
     49              else
     50              {
     51                  eStatus = MB_ENOREG;
   \                     ??eMBRegInputCB_0:
   \   00000050   0x2301             MOVS     R3,#+1
     52              }
     53          
     54              return eStatus;
   \                     ??eMBRegInputCB_2:
   \   00000052   0x0018             MOVS     R0,R3
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBC30             POP      {R4,R5}
   \   00000058   0x4770             BX       LR               ;; return
     55          }
     56          //*******************************                  *********************************
     57          
     58          //**********************************************************************************

   \                                 In section .text, align 2, keep-with-next
     59          eMBErrorCode
     60          eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, eMBRegisterMode eMode )
     61          {
   \                     eMBRegHoldingCB:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
     62              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000008   0x2600             MOVS     R6,#+0
     63              int             iRegIndex;
     64              int isQueue = FALSE;
   \   0000000A   0x2700             MOVS     R7,#+0
     65              uint16_t * p_temp;
     66              uint16_t temp;
     67              
     68              
     69              if( ( usAddress >= REG_HOLDING_START ) &&
     70                  ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xF0C0 0x808E      BCC.W    ??eMBRegHoldingCB_0
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000018   0x1868             ADDS     R0,R5,R1
   \   0000001A   0x2866             CMP      R0,#+102
   \   0000001C   0xF280 0x8088      BGE.W    ??eMBRegHoldingCB_0
     71              {
     72                  iRegIndex = ( int )( usAddress - usRegHoldingStart );
   \   00000020   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000022   0x....             LDR.N    R0,??DataTable3_3
   \   00000024   0x8800             LDRH     R0,[R0, #+0]
   \   00000026   0xEBB1 0x0800      SUBS     R8,R1,R0
     73                  
     74                  switch ( eMode )
   \   0000002A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002C   0x2B00             CMP      R3,#+0
   \   0000002E   0xD00E             BEQ.N    ??eMBRegHoldingCB_1
   \   00000030   0x2B01             CMP      R3,#+1
   \   00000032   0xD03B             BEQ.N    ??eMBRegHoldingCB_2
   \   00000034   0xE07D             B.N      ??eMBRegHoldingCB_3
     75                  {
     76                      /* Pass current register values to the protocol stack. */
     77                  case MB_REG_READ:
     78                      while( usNRegs > 0 )
     79                      {
     80                        /*Checking register address and reading Flash*/
     81                        if(iRegIndex == MB_HOLDING_REG1_FL_H)                 
     82                            temp = FLASH_read(mbHoldingReg1HIGH);  
     83                         else if(iRegIndex == MB_HOLDING_REG1_FL_L)
     84                            temp =  FLASH_read(mbHoldingReg1LOW);
     85                         else if(iRegIndex == MB_HOLDING_REG2_FL_H)
     86                            temp =  FLASH_read(mbHoldingReg2HIGH);
     87                         else if(iRegIndex == MB_HOLDING_REG2_FL_L)
     88                            temp =  FLASH_read(mbHoldingReg2LOW);
     89                         else  
     90                            temp = usRegHoldingBuf[iRegIndex];
   \                     ??eMBRegHoldingCB_4:
   \   00000036   0x....             LDR.N    R0,??DataTable3_4
   \   00000038   0xF830 0x0018      LDRH     R0,[R0, R8, LSL #+1]
     91                        
     92                          *pucRegBuffer++ = ( unsigned char )( temp >> 8 );
   \                     ??eMBRegHoldingCB_5:
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x0A01             LSRS     R1,R0,#+8
   \   00000040   0x7021             STRB     R1,[R4, #+0]
   \   00000042   0x1C64             ADDS     R4,R4,#+1
     93                          *pucRegBuffer++ = ( unsigned char )( temp & 0xFF );
   \   00000044   0x7020             STRB     R0,[R4, #+0]
   \   00000046   0x1C64             ADDS     R4,R4,#+1
     94                          iRegIndex++;
   \   00000048   0xF118 0x0801      ADDS     R8,R8,#+1
     95                          usNRegs--;
   \   0000004C   0x1E6D             SUBS     R5,R5,#+1
   \                     ??eMBRegHoldingCB_1:
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0x2D01             CMP      R5,#+1
   \   00000052   0xD31B             BCC.N    ??eMBRegHoldingCB_6
   \   00000054   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000058   0xD103             BNE.N    ??eMBRegHoldingCB_7
   \   0000005A   0x....             LDR.N    R0,??DataTable3_5  ;; 0x800f800
   \   0000005C   0x.... 0x....      BL       FLASH_read
   \   00000060   0xE7EC             B.N      ??eMBRegHoldingCB_5
   \                     ??eMBRegHoldingCB_7:
   \   00000062   0xF1B8 0x0F05      CMP      R8,#+5
   \   00000066   0xD103             BNE.N    ??eMBRegHoldingCB_8
   \   00000068   0x....             LDR.N    R0,??DataTable3_6  ;; 0x800f802
   \   0000006A   0x.... 0x....      BL       FLASH_read
   \   0000006E   0xE7E5             B.N      ??eMBRegHoldingCB_5
   \                     ??eMBRegHoldingCB_8:
   \   00000070   0xF1B8 0x0F0E      CMP      R8,#+14
   \   00000074   0xD103             BNE.N    ??eMBRegHoldingCB_9
   \   00000076   0x....             LDR.N    R0,??DataTable3_7  ;; 0x800f400
   \   00000078   0x.... 0x....      BL       FLASH_read
   \   0000007C   0xE7DE             B.N      ??eMBRegHoldingCB_5
   \                     ??eMBRegHoldingCB_9:
   \   0000007E   0xF1B8 0x0F0F      CMP      R8,#+15
   \   00000082   0xD1D8             BNE.N    ??eMBRegHoldingCB_4
   \   00000084   0x....             LDR.N    R0,??DataTable3_8  ;; 0x800f402
   \   00000086   0x.... 0x....      BL       FLASH_read
   \   0000008A   0xE7D7             B.N      ??eMBRegHoldingCB_5
     96                        
     97                        /*  *pucRegBuffer++ = ( unsigned char )( usRegHoldingBuf[iRegIndex] >> 8 );
     98                          *pucRegBuffer++ = ( unsigned char )( usRegHoldingBuf[iRegIndex] & 0xFF );
     99                          iRegIndex++;
    100                          usNRegs--;*/
    101                      }
    102                      break;
   \                     ??eMBRegHoldingCB_6:
   \   0000008C   0xE051             B.N      ??eMBRegHoldingCB_3
    103          
    104                      /* Update current register values with new values from the
    105                       * protocol stack. */
    106                  case MB_REG_WRITE:
    107                        
    108                      while( usNRegs > 0 )
    109                      {
    110                        /*Checking register 60005  and packing buf for saving to flash*/
    111                        if((iRegIndex == MB_HOLDING_REG1_FL_H)||(iRegIndex == MB_HOLDING_REG1_FL_L)||
    112                           (iRegIndex == MB_HOLDING_REG2_FL_H)||(iRegIndex == MB_HOLDING_REG2_FL_L))
    113                        {
    114                          memset(&flash_queue_data, 0, sizeof(flash_queue_data));
                                 ^
Warning[Pe223]: function "memset" declared implicitly
    115                          isQueue = TRUE;
    116                        }
    117                         if(iRegIndex == MB_HOLDING_REG1_FL_H) 
    118                         {                 
    119                            p_temp = &flash_queue_data.reg1_h;
    120                            flash_queue_data.mask |=  HOLDING_REG1_H_MASK;  
    121                         }
    122                         else if(iRegIndex == MB_HOLDING_REG1_FL_L)
    123                         {
    124                            p_temp = &flash_queue_data.reg1_l;
    125                            flash_queue_data.mask |=  HOLDING_REG1_L_MASK;
    126                         }
    127                         else if(iRegIndex == MB_HOLDING_REG2_FL_H)
    128                         {
    129                            p_temp = &flash_queue_data.reg2_h;
    130                            flash_queue_data.mask |=  HOLDING_REG2_H_MASK;
    131                         }
    132                         else if(iRegIndex == MB_HOLDING_REG2_FL_L)
    133                         {
    134                            p_temp = &flash_queue_data.reg2_l;
    135                            flash_queue_data.mask |=  HOLDING_REG2_L_MASK;
    136                         }
    137                         else
    138                            p_temp = &usRegHoldingBuf[iRegIndex];
   \                     ??eMBRegHoldingCB_10:
   \   0000008E   0x....             LDR.N    R0,??DataTable3_4
   \   00000090   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
    139                         
    140                         *p_temp = *pucRegBuffer++ << 8; 
   \                     ??eMBRegHoldingCB_11:
   \   00000094   0x7821             LDRB     R1,[R4, #+0]
   \   00000096   0x0209             LSLS     R1,R1,#+8
   \   00000098   0x8001             STRH     R1,[R0, #+0]
   \   0000009A   0x1C64             ADDS     R4,R4,#+1
    141                         *p_temp |= *pucRegBuffer++;
   \   0000009C   0x8801             LDRH     R1,[R0, #+0]
   \   0000009E   0x7822             LDRB     R2,[R4, #+0]
   \   000000A0   0x4311             ORRS     R1,R2,R1
   \   000000A2   0x8001             STRH     R1,[R0, #+0]
   \   000000A4   0x1C64             ADDS     R4,R4,#+1
    142                         iRegIndex++;
   \   000000A6   0xF118 0x0801      ADDS     R8,R8,#+1
    143                         usNRegs--;
   \   000000AA   0x1E6D             SUBS     R5,R5,#+1
   \                     ??eMBRegHoldingCB_2:
   \   000000AC   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000AE   0x2D01             CMP      R5,#+1
   \   000000B0   0xD33D             BCC.N    ??eMBRegHoldingCB_12
   \   000000B2   0xF1B8 0x0F04      CMP      R8,#+4
   \   000000B6   0xD008             BEQ.N    ??eMBRegHoldingCB_13
   \   000000B8   0xF1B8 0x0F05      CMP      R8,#+5
   \   000000BC   0xD005             BEQ.N    ??eMBRegHoldingCB_13
   \   000000BE   0xF1B8 0x0F0E      CMP      R8,#+14
   \   000000C2   0xD002             BEQ.N    ??eMBRegHoldingCB_13
   \   000000C4   0xF1B8 0x0F0F      CMP      R8,#+15
   \   000000C8   0xD105             BNE.N    ??eMBRegHoldingCB_14
   \                     ??eMBRegHoldingCB_13:
   \   000000CA   0x220A             MOVS     R2,#+10
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x....             LDR.N    R0,??DataTable3_9
   \   000000D0   0x.... 0x....      BL       memset
   \   000000D4   0x2701             MOVS     R7,#+1
   \                     ??eMBRegHoldingCB_14:
   \   000000D6   0xF1B8 0x0F04      CMP      R8,#+4
   \   000000DA   0xD107             BNE.N    ??eMBRegHoldingCB_15
   \   000000DC   0x....             LDR.N    R0,??DataTable3_9
   \   000000DE   0x....             LDR.N    R1,??DataTable3_9
   \   000000E0   0x8909             LDRH     R1,[R1, #+8]
   \   000000E2   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   000000E6   0x....             LDR.N    R2,??DataTable3_9
   \   000000E8   0x8111             STRH     R1,[R2, #+8]
   \   000000EA   0xE7D3             B.N      ??eMBRegHoldingCB_11
   \                     ??eMBRegHoldingCB_15:
   \   000000EC   0xF1B8 0x0F05      CMP      R8,#+5
   \   000000F0   0xD107             BNE.N    ??eMBRegHoldingCB_16
   \   000000F2   0x....             LDR.N    R0,??DataTable3_10
   \   000000F4   0x....             LDR.N    R1,??DataTable3_9
   \   000000F6   0x8909             LDRH     R1,[R1, #+8]
   \   000000F8   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   000000FC   0x....             LDR.N    R2,??DataTable3_9
   \   000000FE   0x8111             STRH     R1,[R2, #+8]
   \   00000100   0xE7C8             B.N      ??eMBRegHoldingCB_11
   \                     ??eMBRegHoldingCB_16:
   \   00000102   0xF1B8 0x0F0E      CMP      R8,#+14
   \   00000106   0xD107             BNE.N    ??eMBRegHoldingCB_17
   \   00000108   0x....             LDR.N    R0,??DataTable3_11
   \   0000010A   0x....             LDR.N    R1,??DataTable3_9
   \   0000010C   0x8909             LDRH     R1,[R1, #+8]
   \   0000010E   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000112   0x....             LDR.N    R2,??DataTable3_9
   \   00000114   0x8111             STRH     R1,[R2, #+8]
   \   00000116   0xE7BD             B.N      ??eMBRegHoldingCB_11
   \                     ??eMBRegHoldingCB_17:
   \   00000118   0xF1B8 0x0F0F      CMP      R8,#+15
   \   0000011C   0xD1B7             BNE.N    ??eMBRegHoldingCB_10
   \   0000011E   0x....             LDR.N    R0,??DataTable3_12
   \   00000120   0x....             LDR.N    R1,??DataTable3_9
   \   00000122   0x8909             LDRH     R1,[R1, #+8]
   \   00000124   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   00000128   0x....             LDR.N    R2,??DataTable3_9
   \   0000012A   0x8111             STRH     R1,[R2, #+8]
   \   0000012C   0xE7B2             B.N      ??eMBRegHoldingCB_11
    144                        /*   
    145                          usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ << 8;
    146                          usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
    147                          iRegIndex++;
    148                          usNRegs--;*/
    149                      }
    150                      break;
   \                     ??eMBRegHoldingCB_12:
   \   0000012E   0xE000             B.N      ??eMBRegHoldingCB_3
    151                  }
    152              }
    153              else
    154              {
    155                  eStatus = MB_ENOREG;
   \                     ??eMBRegHoldingCB_0:
   \   00000130   0x2601             MOVS     R6,#+1
    156              }
    157              if(isQueue == TRUE)
   \                     ??eMBRegHoldingCB_3:
   \   00000132   0x2F01             CMP      R7,#+1
   \   00000134   0xD106             BNE.N    ??eMBRegHoldingCB_18
    158                   xSemaphoreGive( FlashWriteSemHandle );///> signalling
   \   00000136   0x2300             MOVS     R3,#+0
   \   00000138   0x2200             MOVS     R2,#+0
   \   0000013A   0x2100             MOVS     R1,#+0
   \   0000013C   0x....             LDR.N    R0,??DataTable3_13
   \   0000013E   0x6800             LDR      R0,[R0, #+0]
   \   00000140   0x.... 0x....      BL       xQueueGenericSend
    159              return eStatus;
   \                     ??eMBRegHoldingCB_18:
   \   00000144   0x0030             MOVS     R0,R6
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000148   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    160          }
    161          //****************************                     ********************************
    162          
    163          //**********************************************************************************

   \                                 In section .text, align 2, keep-with-next
    164          eMBErrorCode
    165          eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, eMBRegisterMode eMode )
    166          {
   \                     eMBRegCoilsCB:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
    167              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000008   0x2600             MOVS     R6,#+0
    168              int             iRegIndex , iRegBitIndex , iNReg;
    169              iNReg =  usNCoils / 8 + 1;        //
   \   0000000A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0xFB95 0xF0F0      SDIV     R0,R5,R0
   \   00000012   0x1C47             ADDS     R7,R0,#+1
    170              if( ( usAddress >= COIL_START ) &&
    171                  ( usAddress + usNCoils <= COIL_START + COIL_NCOILS ) )
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD360             BCC.N    ??eMBRegCoilsCB_0
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x1868             ADDS     R0,R5,R1
   \   00000020   0x2842             CMP      R0,#+66
   \   00000022   0xDA5B             BGE.N    ??eMBRegCoilsCB_0
    172              {
    173                  iRegIndex    = ( int )( usAddress - usCoilStart ) / 8 ;    //
   \   00000024   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000026   0x....             LDR.N    R0,??DataTable3_14
   \   00000028   0x8800             LDRH     R0,[R0, #+0]
   \   0000002A   0x1A08             SUBS     R0,R1,R0
   \   0000002C   0x2208             MOVS     R2,#+8
   \   0000002E   0xFB90 0xF8F2      SDIV     R8,R0,R2
    174          		iRegBitIndex = ( int )( usAddress - usCoilStart ) % 8 ;	   //
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0x....             LDR.N    R0,??DataTable3_14
   \   00000036   0x8800             LDRH     R0,[R0, #+0]
   \   00000038   0x1A08             SUBS     R0,R1,R0
   \   0000003A   0x2108             MOVS     R1,#+8
   \   0000003C   0xFB90 0xF9F1      SDIV     R9,R0,R1
   \   00000040   0xFB09 0x0911      MLS      R9,R9,R1,R0
    175                  switch ( eMode )
   \   00000044   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000046   0x2B00             CMP      R3,#+0
   \   00000048   0xD00F             BEQ.N    ??eMBRegCoilsCB_1
   \   0000004A   0x2B01             CMP      R3,#+1
   \   0000004C   0xD02F             BEQ.N    ??eMBRegCoilsCB_2
   \   0000004E   0xE046             B.N      ??eMBRegCoilsCB_3
    176                  {
    177                      /* Pass current coil values to the protocol stack. */
    178                  case MB_REG_READ:
    179                      while( iNReg > 0 )
    180                      {
    181          				*pucRegBuffer++ = xMBUtilGetBits(&usCoilBuf[iRegIndex++] , iRegBitIndex , 8);
   \                     ??eMBRegCoilsCB_4:
   \   00000050   0x2208             MOVS     R2,#+8
   \   00000052   0x4649             MOV      R1,R9
   \   00000054   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000056   0x....             LDR.N    R0,??DataTable3_15
   \   00000058   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000005C   0x.... 0x....      BL       xMBUtilGetBits
   \   00000060   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000064   0x7020             STRB     R0,[R4, #+0]
   \   00000066   0x1C64             ADDS     R4,R4,#+1
    182                          iNReg --;
   \   00000068   0x1E7F             SUBS     R7,R7,#+1
    183                      }
   \                     ??eMBRegCoilsCB_1:
   \   0000006A   0x2F01             CMP      R7,#+1
   \   0000006C   0xDAF0             BGE.N    ??eMBRegCoilsCB_4
    184          			pucRegBuffer --;
   \   0000006E   0x1E64             SUBS     R4,R4,#+1
    185          			usNCoils = usNCoils % 8;                        //
   \   00000070   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000072   0x2108             MOVS     R1,#+8
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0xFB90 0xF5F1      SDIV     R5,R0,R1
   \   0000007A   0xFB05 0x0511      MLS      R5,R5,R1,R0
    186          			*pucRegBuffer = *pucRegBuffer <<(8 - usNCoils); //
   \   0000007E   0x7820             LDRB     R0,[R4, #+0]
   \   00000080   0xF1D5 0x0108      RSBS     R1,R5,#+8
   \   00000084   0x4088             LSLS     R0,R0,R1
   \   00000086   0x7020             STRB     R0,[R4, #+0]
    187          			*pucRegBuffer = *pucRegBuffer >>(8 - usNCoils);
   \   00000088   0x7820             LDRB     R0,[R4, #+0]
   \   0000008A   0xF1D5 0x0108      RSBS     R1,R5,#+8
   \   0000008E   0x4108             ASRS     R0,R0,R1
   \   00000090   0x7020             STRB     R0,[R4, #+0]
    188                      break;
   \   00000092   0xE024             B.N      ??eMBRegCoilsCB_3
    189          
    190                      /* Update current coil values with new values from the
    191                       * protocol stack. */
    192                  case MB_REG_WRITE:
    193                      while(iNReg > 1)									 //
    194                      {
    195          				xMBUtilSetBits(&usCoilBuf[iRegIndex++] , iRegBitIndex  , 8 , *pucRegBuffer++);
   \                     ??eMBRegCoilsCB_5:
   \   00000094   0x7823             LDRB     R3,[R4, #+0]
   \   00000096   0x2208             MOVS     R2,#+8
   \   00000098   0x4649             MOV      R1,R9
   \   0000009A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000009C   0x....             LDR.N    R0,??DataTable3_15
   \   0000009E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000000A2   0x.... 0x....      BL       xMBUtilSetBits
   \   000000A6   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000AA   0x1C64             ADDS     R4,R4,#+1
    196                          iNReg--;
   \   000000AC   0x1E7F             SUBS     R7,R7,#+1
    197                      }
   \                     ??eMBRegCoilsCB_2:
   \   000000AE   0x2F02             CMP      R7,#+2
   \   000000B0   0xDAF0             BGE.N    ??eMBRegCoilsCB_5
    198          			usNCoils = usNCoils % 8;                            //
   \   000000B2   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000B4   0x2108             MOVS     R1,#+8
   \   000000B6   0x0028             MOVS     R0,R5
   \   000000B8   0xFB90 0xF5F1      SDIV     R5,R0,R1
   \   000000BC   0xFB05 0x0511      MLS      R5,R5,R1,R0
    199          			xMBUtilSetBits(&usCoilBuf[iRegIndex++] , iRegBitIndex  , usNCoils , *pucRegBuffer++);
   \   000000C0   0x7823             LDRB     R3,[R4, #+0]
   \   000000C2   0x002A             MOVS     R2,R5
   \   000000C4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C6   0x4649             MOV      R1,R9
   \   000000C8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000CA   0x....             LDR.N    R0,??DataTable3_15
   \   000000CC   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000000D0   0x.... 0x....      BL       xMBUtilSetBits
   \   000000D4   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000D8   0x1C64             ADDS     R4,R4,#+1
    200          			break;
   \   000000DA   0xE000             B.N      ??eMBRegCoilsCB_3
    201                  }
    202              }
    203              else
    204              {
    205                  eStatus = MB_ENOREG;
   \                     ??eMBRegCoilsCB_0:
   \   000000DC   0x2601             MOVS     R6,#+1
    206              }
    207              return eStatus;
   \                     ??eMBRegCoilsCB_3:
   \   000000DE   0x0030             MOVS     R0,R6
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    208          }
    209          //****************************                      ********************************
    210          
    211          //**********************************************************************************

   \                                 In section .text, align 2, keep-with-next
    212          eMBErrorCode
    213          eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
    214          {
   \                     eMBRegDiscreteCB:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
    215              eMBErrorCode    eStatus = MB_ENOERR;
   \   00000008   0x2600             MOVS     R6,#+0
    216          	int             iRegIndex , iRegBitIndex , iNReg;
    217          	iNReg =  usNDiscrete / 8 + 1;        //
   \   0000000A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0xFB95 0xF0F0      SDIV     R0,R5,R0
   \   00000012   0x1C47             ADDS     R7,R0,#+1
    218              if( ( usAddress >= DISCRETE_INPUT_START )
    219                  && ( usAddress + usNDiscrete <= DISCRETE_INPUT_START + DISCRETE_INPUT_NDISCRETES ) )
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD337             BCC.N    ??eMBRegDiscreteCB_0
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x1868             ADDS     R0,R5,R1
   \   00000020   0x2812             CMP      R0,#+18
   \   00000022   0xDA32             BGE.N    ??eMBRegDiscreteCB_0
    220              {
    221                  iRegIndex    = ( int )( usAddress - usDiscreteInputStart ) / 8 ;    //
   \   00000024   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000026   0x....             LDR.N    R0,??DataTable3_16
   \   00000028   0x8800             LDRH     R0,[R0, #+0]
   \   0000002A   0x1A08             SUBS     R0,R1,R0
   \   0000002C   0x2208             MOVS     R2,#+8
   \   0000002E   0xFB90 0xF8F2      SDIV     R8,R0,R2
    222          		iRegBitIndex = ( int )( usAddress - usDiscreteInputStart ) % 8 ;	   //
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0x....             LDR.N    R0,??DataTable3_16
   \   00000036   0x8800             LDRH     R0,[R0, #+0]
   \   00000038   0x1A08             SUBS     R0,R1,R0
   \   0000003A   0x2108             MOVS     R1,#+8
   \   0000003C   0xFB90 0xF9F1      SDIV     R9,R0,R1
   \   00000040   0xFB09 0x0911      MLS      R9,R9,R1,R0
   \   00000044   0xE00C             B.N      ??eMBRegDiscreteCB_1
    223          	    while( iNReg > 0 )
    224                  {
    225          			*pucRegBuffer++ = xMBUtilGetBits(&usDiscreteInputBuf[iRegIndex++] , iRegBitIndex , 8);
   \                     ??eMBRegDiscreteCB_2:
   \   00000046   0x2208             MOVS     R2,#+8
   \   00000048   0x4649             MOV      R1,R9
   \   0000004A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004C   0x....             LDR.N    R0,??DataTable3_17
   \   0000004E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000052   0x.... 0x....      BL       xMBUtilGetBits
   \   00000056   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000005A   0x7020             STRB     R0,[R4, #+0]
   \   0000005C   0x1C64             ADDS     R4,R4,#+1
    226                      iNReg --;
   \   0000005E   0x1E7F             SUBS     R7,R7,#+1
    227                  }
   \                     ??eMBRegDiscreteCB_1:
   \   00000060   0x2F01             CMP      R7,#+1
   \   00000062   0xDAF0             BGE.N    ??eMBRegDiscreteCB_2
    228          		pucRegBuffer --;
   \   00000064   0x1E64             SUBS     R4,R4,#+1
    229          		usNDiscrete = usNDiscrete % 8;                     //
   \   00000066   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000068   0x2108             MOVS     R1,#+8
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0xFB90 0xF5F1      SDIV     R5,R0,R1
   \   00000070   0xFB05 0x0511      MLS      R5,R5,R1,R0
    230          		*pucRegBuffer = *pucRegBuffer <<(8 - usNDiscrete); //
   \   00000074   0x7820             LDRB     R0,[R4, #+0]
   \   00000076   0xF1D5 0x0108      RSBS     R1,R5,#+8
   \   0000007A   0x4088             LSLS     R0,R0,R1
   \   0000007C   0x7020             STRB     R0,[R4, #+0]
    231          		*pucRegBuffer = *pucRegBuffer >>(8 - usNDiscrete);
   \   0000007E   0x7820             LDRB     R0,[R4, #+0]
   \   00000080   0xF1D5 0x0108      RSBS     R1,R5,#+8
   \   00000084   0x4108             ASRS     R0,R0,R1
   \   00000086   0x7020             STRB     R0,[R4, #+0]
   \   00000088   0xE000             B.N      ??eMBRegDiscreteCB_3
    232              }
    233              else
    234              {
    235                  eStatus = MB_ENOREG;
   \                     ??eMBRegDiscreteCB_0:
   \   0000008A   0x2601             MOVS     R6,#+1
    236              }
    237          
    238              return eStatus;
   \                     ??eMBRegDiscreteCB_3:
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    239          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     usRegInputStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     usRegInputBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     FlCh

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     usRegHoldingStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     usRegHoldingBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x0800F800         DC32     0x800f800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x0800F802         DC32     0x800f802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x0800F400         DC32     0x800f400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x0800F402         DC32     0x800f402

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     flash_queue_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     flash_queue_data+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     flash_queue_data+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     flash_queue_data+0x6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     FlashWriteSemHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     usCoilStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x........         DC32     usCoilBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   0x........         DC32     usDiscreteInputStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \   00000000   0x........         DC32     usDiscreteInputBuf

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  eMBRegCoilsCB
             32 -> xMBUtilGetBits
             32 -> xMBUtilSetBits
       32  eMBRegDiscreteCB
             32 -> xMBUtilGetBits
       24  eMBRegHoldingCB
             24 -> FLASH_read
             24 -> memset
             24 -> xQueueGenericSend
        8  eMBRegInputCB


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  FlCh
     230  eMBRegCoilsCB
     148  eMBRegDiscreteCB
     332  eMBRegHoldingCB
      90  eMBRegInputCB
       8  usCoilBuf
       2  usCoilStart
       2  usDiscreteInputBuf
       2  usDiscreteInputStart
     200  usRegHoldingBuf
       2  usRegHoldingStart
     200  usRegInputBuf
       2  usRegInputStart

 
 414 bytes in section .bss
   8 bytes in section .data
 872 bytes in section .text
 
 872 bytes of CODE memory
 422 bytes of DATA memory

Errors: none
Warnings: 2
