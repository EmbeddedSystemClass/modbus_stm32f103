###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  06:15:50 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1 #
#                    xx_HAL_Driver\Src\stm32f1xx_hal_dma.c                    #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F #
#                    1xx_HAL_Driver\Src\stm32f1xx_hal_dma.c" -D               #
#                    USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F103xB -lC  #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    List\" -o "D:\projects\задания от                        #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/Obj\" --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\stm32f1xx_hal_dma.lst                                #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\stm32f1xx_hal_dma.o                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_dma.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_dma.c
      4            * @author  MCD Application Team
      5            * @brief   DMA HAL module driver.
      6            *         This file provides firmware functions to manage the following
      7            *         functionalities of the Direct Memory Access (DMA) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral State and errors functions
     11            @verbatim
     12            ==============================================================================
     13                                  ##### How to use this driver #####
     14            ==============================================================================
     15            [..]
     16             (#) Enable and configure the peripheral to be connected to the DMA Channel
     17                 (except for internal SRAM / FLASH memories: no initialization is 
     18                 necessary). Please refer to the Reference manual for connection between peripherals
     19                 and DMA requests.
     20          
     21             (#) For a given Channel, program the required configuration through the following parameters:
     22                 Channel request, Transfer Direction, Source and Destination data formats,
     23                 Circular or Normal mode, Channel Priority level, Source and Destination Increment mode
     24                 using HAL_DMA_Init() function.
     25          
     26             (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
     27                 detection.
     28                              
     29             (#) Use HAL_DMA_Abort() function to abort the current transfer
     30                             
     31               -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.
     32               *** Polling mode IO operation ***
     33               =================================
     34              [..]
     35                    (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source
     36                        address and destination address and the Length of data to be transferred
     37                    (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this
     38                        case a fixed Timeout can be configured by User depending from his application.
     39          
     40               *** Interrupt mode IO operation ***
     41               ===================================
     42              [..]
     43                    (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
     44                    (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ()
     45                    (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of
     46                        Source address and destination address and the Length of data to be transferred.
     47                        In this case the DMA interrupt is configured
     48                    (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
     49                    (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can
     50                        add his own function by customization of function pointer XferCpltCallback and
     51                        XferErrorCallback (i.e. a member of DMA handle structure).
     52          
     53               *** DMA HAL driver macros list ***
     54               ============================================= 
     55                [..]
     56                 Below the list of most used macros in DMA HAL driver.
     57          
     58                 (+) __HAL_DMA_ENABLE: Enable the specified DMA Channel.
     59                 (+) __HAL_DMA_DISABLE: Disable the specified DMA Channel.
     60                 (+) __HAL_DMA_GET_FLAG: Get the DMA Channel pending flags.
     61                 (+) __HAL_DMA_CLEAR_FLAG: Clear the DMA Channel pending flags.
     62                 (+) __HAL_DMA_ENABLE_IT: Enable the specified DMA Channel interrupts.
     63                 (+) __HAL_DMA_DISABLE_IT: Disable the specified DMA Channel interrupts.
     64                 (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Channel interrupt has occurred or not. 
     65          
     66               [..] 
     67                (@) You can refer to the DMA HAL driver header file for more useful macros  
     68          
     69            @endverbatim
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
     74            *
     75            * Redistribution and use in source and binary forms, with or without modification,
     76            * are permitted provided that the following conditions are met:
     77            *   1. Redistributions of source code must retain the above copyright notice,
     78            *      this list of conditions and the following disclaimer.
     79            *   2. Redistributions in binary form must reproduce the above copyright notice,
     80            *      this list of conditions and the following disclaimer in the documentation
     81            *      and/or other materials provided with the distribution.
     82            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     83            *      may be used to endorse or promote products derived from this software
     84            *      without specific prior written permission.
     85            *
     86            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     87            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     88            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     89            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     90            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     91            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     92            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     93            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     94            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     95            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     96            *
     97            ******************************************************************************
     98            */
     99          
    100          /* Includes ------------------------------------------------------------------*/
    101          #include "stm32f1xx_hal.h"
    102          
    103          /** @addtogroup STM32F1xx_HAL_Driver
    104            * @{
    105            */
    106          
    107          /** @defgroup DMA DMA
    108            * @brief DMA HAL module driver
    109            * @{
    110            */
    111          
    112          #ifdef HAL_DMA_MODULE_ENABLED
    113          
    114          /* Private typedef -----------------------------------------------------------*/
    115          /* Private define ------------------------------------------------------------*/
    116          /* Private macro -------------------------------------------------------------*/
    117          /* Private variables ---------------------------------------------------------*/
    118          /* Private function prototypes -----------------------------------------------*/
    119          /** @defgroup DMA_Private_Functions DMA Private Functions
    120            * @{
    121            */
    122          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
    123          /**
    124            * @}
    125            */
    126          
    127          /* Exported functions ---------------------------------------------------------*/
    128          
    129          /** @defgroup DMA_Exported_Functions DMA Exported Functions
    130            * @{
    131            */
    132          
    133          /** @defgroup DMA_Exported_Functions_Group1 Initialization and de-initialization functions
    134            *  @brief   Initialization and de-initialization functions 
    135            *
    136          @verbatim
    137           ===============================================================================
    138                       ##### Initialization and de-initialization functions  #####
    139           ===============================================================================
    140              [..]
    141              This section provides functions allowing to initialize the DMA Channel source
    142              and destination addresses, incrementation and data sizes, transfer direction, 
    143              circular/normal mode selection, memory-to-memory mode selection and Channel priority value.
    144              [..]
    145              The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    146              reference manual.  
    147          
    148          @endverbatim
    149            * @{
    150            */
    151          
    152          /**
    153            * @brief  Initialize the DMA according to the specified
    154            *         parameters in the DMA_InitTypeDef and initialize the associated handle.
    155            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
    156            *               the configuration information for the specified DMA Channel.
    157            * @retval HAL status
    158            */

   \                                 In section .text, align 2, keep-with-next
    159          HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
    160          {
    161            uint32_t tmp = 0U;
   \                     HAL_DMA_Init:
   \   00000000   0x2100             MOVS     R1,#+0
    162          
    163            /* Check the DMA handle allocation */
    164            if(hdma == NULL)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??HAL_DMA_Init_0
    165            {
    166              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE034             B.N      ??HAL_DMA_Init_1
    167            }
    168          
    169            /* Check the parameters */
    170            assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    171            assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    172            assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    173            assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    174            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    175            assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    176            assert_param(IS_DMA_MODE(hdma->Init.Mode));
    177            assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    178          
    179          #if defined (STM32F101xE) || defined (STM32F101xG) || defined (STM32F103xE) || defined (STM32F103xG) || defined (STM32F100xE) || defined (STM32F105xC) || defined (STM32F107xC)
    180            /* calculation of the channel index */
    181            if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
    182            {
    183              /* DMA1 */
    184              hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
    185              hdma->DmaBaseAddress = DMA1;
    186            }
    187            else 
    188            {
    189              /* DMA2 */
    190              hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
    191              hdma->DmaBaseAddress = DMA2;
    192            }
    193          #else
    194            /* DMA1 */
    195            hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
   \                     ??HAL_DMA_Init_0:
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable4  ;; 0xbffdfff8
   \   00000010   0x1851             ADDS     R1,R2,R1
   \   00000012   0x2214             MOVS     R2,#+20
   \   00000014   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000018   0x0089             LSLS     R1,R1,#+2
   \   0000001A   0x6401             STR      R1,[R0, #+64]
    196            hdma->DmaBaseAddress = DMA1;
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable4_1  ;; 0x40020000
   \   00000020   0x63C1             STR      R1,[R0, #+60]
    197          #endif /* STM32F101xE || STM32F101xG || STM32F103xE || STM32F103xG || STM32F100xE || STM32F105xC || STM32F107xC */
    198          
    199            /* Change DMA peripheral state */
    200            hdma->State = HAL_DMA_STATE_BUSY;
   \   00000022   0x2102             MOVS     R1,#+2
   \   00000024   0xF880 0x1021      STRB     R1,[R0, #+33]
    201          
    202            /* Get the CR register value */
    203            tmp = hdma->Instance->CCR;
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
    204          
    205            /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
    206            tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
    207                                DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
    208                                DMA_CCR_DIR));
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable4_2  ;; 0xffffc00f
   \   00000030   0x4011             ANDS     R1,R2,R1
    209          
    210            /* Prepare the DMA Channel configuration */
    211            tmp |=  hdma->Init.Direction        |
    212                    hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    213                    hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    214                    hdma->Init.Mode                | hdma->Init.Priority;
   \   00000032   0x6842             LDR      R2,[R0, #+4]
   \   00000034   0x6883             LDR      R3,[R0, #+8]
   \   00000036   0x431A             ORRS     R2,R3,R2
   \   00000038   0x68C3             LDR      R3,[R0, #+12]
   \   0000003A   0x431A             ORRS     R2,R3,R2
   \   0000003C   0x6903             LDR      R3,[R0, #+16]
   \   0000003E   0x431A             ORRS     R2,R3,R2
   \   00000040   0x6943             LDR      R3,[R0, #+20]
   \   00000042   0x431A             ORRS     R2,R3,R2
   \   00000044   0x6983             LDR      R3,[R0, #+24]
   \   00000046   0x431A             ORRS     R2,R3,R2
   \   00000048   0x69C3             LDR      R3,[R0, #+28]
   \   0000004A   0x431A             ORRS     R2,R3,R2
   \   0000004C   0x4311             ORRS     R1,R2,R1
    215          
    216            /* Write to DMA Channel CR register */
    217            hdma->Instance->CCR = tmp;
   \   0000004E   0x6802             LDR      R2,[R0, #+0]
   \   00000050   0x6011             STR      R1,[R2, #+0]
    218          
    219          
    220            /* Clean callbacks */
    221            hdma->XferCpltCallback = NULL;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x6281             STR      R1,[R0, #+40]
    222            hdma->XferHalfCpltCallback = NULL;
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x62C1             STR      R1,[R0, #+44]
    223            hdma->XferErrorCallback = NULL;
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x6301             STR      R1,[R0, #+48]
    224            hdma->XferAbortCallback = NULL;
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x6341             STR      R1,[R0, #+52]
    225          
    226            /* Initialise the error code */
    227            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x6381             STR      R1,[R0, #+56]
    228          
    229            /* Initialize the DMA state*/
    230            hdma->State = HAL_DMA_STATE_READY;
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0xF880 0x1021      STRB     R1,[R0, #+33]
    231            /* Allocate lock resource and initialize it */
    232            hdma->Lock = HAL_UNLOCKED;
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0xF880 0x1020      STRB     R1,[R0, #+32]
    233            
    234            return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_Init_1:
   \   00000074   0x4770             BX       LR               ;; return
    235          }
    236          
    237          /**
    238            * @brief  DeInitialize the DMA peripheral.
    239            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    240            *               the configuration information for the specified DMA Channel.
    241            * @retval HAL status
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
    244          {
    245            /* Check the DMA handle allocation */
    246            if(hdma == NULL)
   \                     HAL_DMA_DeInit:
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE.N    ??HAL_DMA_DeInit_0
    247            {
    248              return HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xE02B             B.N      ??HAL_DMA_DeInit_1
    249            }
    250          
    251            /* Check the parameters */
    252            assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
    253          
    254            /* Disable the selected DMA Channelx */
    255            __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_DeInit_0:
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x0849             LSRS     R1,R1,#+1
   \   0000000E   0x0049             LSLS     R1,R1,#+1
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0x6011             STR      R1,[R2, #+0]
    256          
    257            /* Reset DMA Channel control register */
    258            hdma->Instance->CCR  = 0U;
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x600A             STR      R2,[R1, #+0]
    259          
    260            /* Reset DMA Channel Number of Data to Transfer register */
    261            hdma->Instance->CNDTR = 0U;
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x604A             STR      R2,[R1, #+4]
    262          
    263            /* Reset DMA Channel peripheral address register */
    264            hdma->Instance->CPAR  = 0U;
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x608A             STR      R2,[R1, #+8]
    265          
    266            /* Reset DMA Channel memory address register */
    267            hdma->Instance->CMAR = 0U;
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x60CA             STR      R2,[R1, #+12]
    268          
    269          #if defined (STM32F101xE) || defined (STM32F101xG) || defined (STM32F103xE) || defined (STM32F103xG) || defined (STM32F100xE) || defined (STM32F105xC) || defined (STM32F107xC)
    270            /* calculation of the channel index */
    271            if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
    272            {
    273              /* DMA1 */
    274              hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
    275              hdma->DmaBaseAddress = DMA1;
    276            }
    277            else 
    278            {
    279              /* DMA2 */
    280              hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2;
    281              hdma->DmaBaseAddress = DMA2;
    282            }
    283          #else
    284            /* DMA1 */
    285            hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable4  ;; 0xbffdfff8
   \   00000032   0x1851             ADDS     R1,R2,R1
   \   00000034   0x2214             MOVS     R2,#+20
   \   00000036   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000003A   0x0089             LSLS     R1,R1,#+2
   \   0000003C   0x6401             STR      R1,[R0, #+64]
    286            hdma->DmaBaseAddress = DMA1;
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable4_1  ;; 0x40020000
   \   00000042   0x63C1             STR      R1,[R0, #+60]
    287          #endif /* STM32F101xE || STM32F101xG || STM32F103xE || STM32F103xG || STM32F100xE || STM32F105xC || STM32F107xC */
    288          
    289            /* Clear all flags */
    290            hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex));
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x6C02             LDR      R2,[R0, #+64]
   \   00000048   0x4091             LSLS     R1,R1,R2
   \   0000004A   0x6BC2             LDR      R2,[R0, #+60]
   \   0000004C   0x6051             STR      R1,[R2, #+4]
    291          
    292            /* Initialize the error code */
    293            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x6381             STR      R1,[R0, #+56]
    294          
    295            /* Initialize the DMA state */
    296            hdma->State = HAL_DMA_STATE_RESET;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xF880 0x1021      STRB     R1,[R0, #+33]
    297          
    298            /* Release Lock */
    299            __HAL_UNLOCK(hdma);
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0xF880 0x1020      STRB     R1,[R0, #+32]
    300          
    301            return HAL_OK;
   \   0000005E   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_DeInit_1:
   \   00000060   0x4770             BX       LR               ;; return
    302          }
    303          
    304          /**
    305            * @}
    306            */
    307          
    308          /** @defgroup DMA_Exported_Functions_Group2 Input and Output operation functions
    309            *  @brief   Input and Output operation functions
    310            *
    311          @verbatim
    312           ===============================================================================
    313                                #####  IO operation functions  #####
    314           ===============================================================================
    315              [..]  This section provides functions allowing to:
    316                (+) Configure the source, destination address and data length and Start DMA transfer
    317                (+) Configure the source, destination address and data length and
    318                    Start DMA transfer with interrupt
    319                (+) Abort DMA transfer
    320                (+) Poll for transfer complete
    321                (+) Handle DMA interrupt request
    322          
    323          @endverbatim
    324            * @{
    325            */
    326          
    327          /**
    328            * @brief  Start the DMA Transfer.
    329            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    330            *               the configuration information for the specified DMA Channel.
    331            * @param  SrcAddress: The source memory Buffer address
    332            * @param  DstAddress: The destination memory Buffer address
    333            * @param  DataLength: The length of data to be transferred from source to destination
    334            * @retval HAL status
    335            */

   \                                 In section .text, align 2, keep-with-next
    336          HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    337          {
   \                     HAL_DMA_Start:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    338            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    339          
    340            /* Check the parameters */
    341            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    342          
    343            /* Process locked */
    344            __HAL_LOCK(hdma);
   \   00000006   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_DMA_Start_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE021             B.N      ??HAL_DMA_Start_1
   \                     ??HAL_DMA_Start_0:
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0020      STRB     R0,[R4, #+32]
    345          
    346            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000018   0xF894 0x0021      LDRB     R0,[R4, #+33]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD114             BNE.N    ??HAL_DMA_Start_2
    347            {
    348              /* Change DMA peripheral state */
    349              hdma->State = HAL_DMA_STATE_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0021      STRB     R0,[R4, #+33]
    350              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x63A0             STR      R0,[R4, #+56]
    351                      
    352              /* Disable the peripheral */
    353              __HAL_DMA_DISABLE(hdma);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0x0040             LSLS     R0,R0,#+1
   \   00000032   0x6826             LDR      R6,[R4, #+0]
   \   00000034   0x6030             STR      R0,[R6, #+0]
    354              
    355              /* Configure the source, destination address and the data length & clear flags*/
    356              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       DMA_SetConfig
    357              
    358              /* Enable the Peripheral */
    359              __HAL_DMA_ENABLE(hdma);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6008             STR      R0,[R1, #+0]
   \   00000048   0xE003             B.N      ??HAL_DMA_Start_3
    360            }
    361            else
    362            {
    363             /* Process Unlocked */
    364             __HAL_UNLOCK(hdma);  
   \                     ??HAL_DMA_Start_2:
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF884 0x0020      STRB     R0,[R4, #+32]
    365             status = HAL_BUSY;
   \   00000050   0x2502             MOVS     R5,#+2
    366            }  
    367            return status;
   \                     ??HAL_DMA_Start_3:
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_DMA_Start_1:
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    368          }
    369          
    370          /**
    371            * @brief  Start the DMA Transfer with interrupt enabled.
    372            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    373            *               the configuration information for the specified DMA Channel.
    374            * @param  SrcAddress: The source memory Buffer address
    375            * @param  DstAddress: The destination memory Buffer address
    376            * @param  DataLength: The length of data to be transferred from source to destination
    377            * @retval HAL status
    378            */

   \                                 In section .text, align 2, keep-with-next
    379          HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    380          {
   \                     HAL_DMA_Start_IT:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    381            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
    382          
    383            /* Check the parameters */
    384            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    385          
    386            /* Process locked */
    387            __HAL_LOCK(hdma);
   \   00000006   0xF894 0x0020      LDRB     R0,[R4, #+32]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_DMA_Start_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xE037             B.N      ??HAL_DMA_Start_IT_1
   \                     ??HAL_DMA_Start_IT_0:
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0020      STRB     R0,[R4, #+32]
    388            
    389            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000018   0xF894 0x0021      LDRB     R0,[R4, #+33]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD12A             BNE.N    ??HAL_DMA_Start_IT_2
    390            {
    391              /* Change DMA peripheral state */
    392              hdma->State = HAL_DMA_STATE_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0021      STRB     R0,[R4, #+33]
    393              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x63A0             STR      R0,[R4, #+56]
    394              
    395              /* Disable the peripheral */
    396              __HAL_DMA_DISABLE(hdma);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0x0040             LSLS     R0,R0,#+1
   \   00000032   0x6826             LDR      R6,[R4, #+0]
   \   00000034   0x6030             STR      R0,[R6, #+0]
    397              
    398              /* Configure the source, destination address and the data length & clear flags*/
    399              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       DMA_SetConfig
    400              
    401              /* Enable the transfer complete interrupt */
    402              /* Enable the transfer Error interrupt */
    403              if(NULL != hdma->XferHalfCpltCallback)
   \   0000003C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD006             BEQ.N    ??HAL_DMA_Start_IT_3
    404              {
    405                /* Enable the Half transfer complete interrupt as well */
    406                __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF050 0x000E      ORRS     R0,R0,#0xE
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   \   0000004E   0xE00B             B.N      ??HAL_DMA_Start_IT_4
    407              }
    408              else
    409              {
    410                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
   \                     ??HAL_DMA_Start_IT_3:
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    411                __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF050 0x000A      ORRS     R0,R0,#0xA
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
    412              }
    413              /* Enable the Peripheral */
    414              __HAL_DMA_ENABLE(hdma);
   \                     ??HAL_DMA_Start_IT_4:
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6008             STR      R0,[R1, #+0]
   \   00000074   0xE003             B.N      ??HAL_DMA_Start_IT_5
    415            }
    416            else
    417            {      
    418              /* Process Unlocked */
    419              __HAL_UNLOCK(hdma); 
   \                     ??HAL_DMA_Start_IT_2:
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x0020      STRB     R0,[R4, #+32]
    420          
    421              /* Remain BUSY */
    422              status = HAL_BUSY;
   \   0000007C   0x2502             MOVS     R5,#+2
    423            }    
    424            return status;
   \                     ??HAL_DMA_Start_IT_5:
   \   0000007E   0x0028             MOVS     R0,R5
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_DMA_Start_IT_1:
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    425          }
    426          
    427          /**
    428            * @brief  Abort the DMA Transfer.
    429            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    430            *               the configuration information for the specified DMA Channel.
    431            * @retval HAL status
    432            */

   \                                 In section .text, align 2, keep-with-next
    433          HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
    434          {
    435            HAL_StatusTypeDef status = HAL_OK;
   \                     HAL_DMA_Abort:
   \   00000000   0x2100             MOVS     R1,#+0
    436          
    437            /* Disable DMA IT */
    438            __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0xF032 0x020E      BICS     R2,R2,#0xE
   \   0000000A   0x6803             LDR      R3,[R0, #+0]
   \   0000000C   0x601A             STR      R2,[R3, #+0]
    439              
    440            /* Disable the channel */
    441            __HAL_DMA_DISABLE(hdma);
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x0852             LSRS     R2,R2,#+1
   \   00000014   0x0052             LSLS     R2,R2,#+1
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0x601A             STR      R2,[R3, #+0]
    442              
    443            /* Clear all flags */
    444            hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x6C03             LDR      R3,[R0, #+64]
   \   0000001E   0x409A             LSLS     R2,R2,R3
   \   00000020   0x6BC3             LDR      R3,[R0, #+60]
   \   00000022   0x605A             STR      R2,[R3, #+4]
    445          
    446            /* Change the DMA state */
    447            hdma->State = HAL_DMA_STATE_READY;
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xF880 0x2021      STRB     R2,[R0, #+33]
    448          
    449            /* Process Unlocked */
    450            __HAL_UNLOCK(hdma);      
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0xF880 0x2020      STRB     R2,[R0, #+32]
    451            
    452            return status; 
   \   00000030   0x0008             MOVS     R0,R1
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x4770             BX       LR               ;; return
    453          }
    454          
    455          /**
    456            * @brief  Aborts the DMA Transfer in Interrupt mode.
    457            * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
    458            *                 the configuration information for the specified DMA Channel.
    459            * @retval HAL status
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
    462          {  
   \                     HAL_DMA_Abort_IT:
   \   00000000   0xB510             PUSH     {R4,LR}
    463            HAL_StatusTypeDef status = HAL_OK;
   \   00000002   0x2400             MOVS     R4,#+0
    464            
    465            if(HAL_DMA_STATE_BUSY != hdma->State)
   \   00000004   0xF890 0x1021      LDRB     R1,[R0, #+33]
   \   00000008   0x2902             CMP      R1,#+2
   \   0000000A   0xD003             BEQ.N    ??HAL_DMA_Abort_IT_0
    466            {
    467              /* no transfer ongoing */
    468              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x6381             STR      R1,[R0, #+56]
    469                  
    470              status = HAL_ERROR;
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0xE049             B.N      ??HAL_DMA_Abort_IT_1
    471            }
    472            else
    473            { 
    474              /* Disable DMA IT */
    475              __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
   \                     ??HAL_DMA_Abort_IT_0:
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0xF031 0x010E      BICS     R1,R1,#0xE
   \   0000001C   0x6802             LDR      R2,[R0, #+0]
   \   0000001E   0x6011             STR      R1,[R2, #+0]
    476          
    477              /* Disable the channel */
    478              __HAL_DMA_DISABLE(hdma);
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6802             LDR      R2,[R0, #+0]
   \   0000002A   0x6011             STR      R1,[R2, #+0]
    479          
    480              /* Clear all flags */
    481              __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable4_3  ;; 0x40020008
   \   00000032   0x4291             CMP      R1,R2
   \   00000034   0xD101             BNE.N    ??HAL_DMA_Abort_IT_2
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xE028             B.N      ??HAL_DMA_Abort_IT_3
   \                     ??HAL_DMA_Abort_IT_2:
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable4_4  ;; 0x4002001c
   \   00000040   0x4291             CMP      R1,R2
   \   00000042   0xD101             BNE.N    ??HAL_DMA_Abort_IT_4
   \   00000044   0x2110             MOVS     R1,#+16
   \   00000046   0xE021             B.N      ??HAL_DMA_Abort_IT_3
   \                     ??HAL_DMA_Abort_IT_4:
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable4_5  ;; 0x40020030
   \   0000004E   0x4291             CMP      R1,R2
   \   00000050   0xD102             BNE.N    ??HAL_DMA_Abort_IT_5
   \   00000052   0xF44F 0x7180      MOV      R1,#+256
   \   00000056   0xE019             B.N      ??HAL_DMA_Abort_IT_3
   \                     ??HAL_DMA_Abort_IT_5:
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable4_6  ;; 0x40020044
   \   0000005E   0x4291             CMP      R1,R2
   \   00000060   0xD102             BNE.N    ??HAL_DMA_Abort_IT_6
   \   00000062   0xF44F 0x5180      MOV      R1,#+4096
   \   00000066   0xE011             B.N      ??HAL_DMA_Abort_IT_3
   \                     ??HAL_DMA_Abort_IT_6:
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable4_7  ;; 0x40020058
   \   0000006E   0x4291             CMP      R1,R2
   \   00000070   0xD102             BNE.N    ??HAL_DMA_Abort_IT_7
   \   00000072   0xF45F 0x3180      MOVS     R1,#+65536
   \   00000076   0xE009             B.N      ??HAL_DMA_Abort_IT_3
   \                     ??HAL_DMA_Abort_IT_7:
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable4_8  ;; 0x4002006c
   \   0000007E   0x4291             CMP      R1,R2
   \   00000080   0xD102             BNE.N    ??HAL_DMA_Abort_IT_8
   \   00000082   0xF45F 0x1180      MOVS     R1,#+1048576
   \   00000086   0xE001             B.N      ??HAL_DMA_Abort_IT_3
   \                     ??HAL_DMA_Abort_IT_8:
   \   00000088   0xF05F 0x7180      MOVS     R1,#+16777216
   \                     ??HAL_DMA_Abort_IT_3:
   \   0000008C   0x.... 0x....      LDR.W    R2,??DataTable4_9  ;; 0x40020004
   \   00000090   0x6011             STR      R1,[R2, #+0]
    482          
    483              /* Change the DMA state */
    484              hdma->State = HAL_DMA_STATE_READY;
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0xF880 0x1021      STRB     R1,[R0, #+33]
    485          
    486              /* Process Unlocked */
    487              __HAL_UNLOCK(hdma);
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0xF880 0x1020      STRB     R1,[R0, #+32]
    488          
    489              /* Call User Abort callback */
    490              if(hdma->XferAbortCallback != NULL)
   \   0000009E   0x6B41             LDR      R1,[R0, #+52]
   \   000000A0   0x2900             CMP      R1,#+0
   \   000000A2   0xD001             BEQ.N    ??HAL_DMA_Abort_IT_1
    491              {
    492                hdma->XferAbortCallback(hdma);
   \   000000A4   0x6B41             LDR      R1,[R0, #+52]
   \   000000A6   0x4788             BLX      R1
    493              } 
    494            }
    495            return status;
   \                     ??HAL_DMA_Abort_IT_1:
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xBD10             POP      {R4,PC}          ;; return
    496          }
    497          
    498          /**
    499            * @brief  Polling for transfer complete.
    500            * @param  hdma:    pointer to a DMA_HandleTypeDef structure that contains
    501            *                  the configuration information for the specified DMA Channel.
    502            * @param  CompleteLevel: Specifies the DMA level complete.
    503            * @param  Timeout:       Timeout duration.
    504            * @retval HAL status
    505            */

   \                                 In section .text, align 2, keep-with-next
    506          HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout)
    507          {
   \                     HAL_DMA_PollForTransfer:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    508            uint32_t temp;
    509            uint32_t tickstart = 0U;
   \   0000000A   0x2700             MOVS     R7,#+0
    510          
    511            if(HAL_DMA_STATE_BUSY != hdma->State)
   \   0000000C   0xF894 0x0021      LDRB     R0,[R4, #+33]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD006             BEQ.N    ??HAL_DMA_PollForTransfer_0
    512            {
    513              /* no transfer ongoing */
    514              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0x63A0             STR      R0,[R4, #+56]
    515              __HAL_UNLOCK(hdma);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0020      STRB     R0,[R4, #+32]
    516              return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE12E             B.N      ??HAL_DMA_PollForTransfer_1
    517            }
    518          
    519            /* Polling mode not supported in circular mode */
    520            if (RESET != (hdma->Instance->CCR & DMA_CCR_CIRC))
   \                     ??HAL_DMA_PollForTransfer_0:
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_2
    521            {
    522              hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
   \   0000002A   0xF44F 0x7080      MOV      R0,#+256
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
    523              return HAL_ERROR;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE125             B.N      ??HAL_DMA_PollForTransfer_1
    524            }
    525            
    526            /* Get the level transfer complete flag */
    527            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_2:
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD132             BNE.N    ??HAL_DMA_PollForTransfer_3
    528            {
    529              /* Transfer Complete flag */
    530              temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable4_3  ;; 0x40020008
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_4
   \   00000042   0xF05F 0x0802      MOVS     R8,#+2
   \   00000046   0xE05C             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_4:
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable4_4  ;; 0x4002001c
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_6
   \   00000052   0xF05F 0x0820      MOVS     R8,#+32
   \   00000056   0xE054             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_6:
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable4_5  ;; 0x40020030
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_7
   \   00000062   0xF44F 0x7800      MOV      R8,#+512
   \   00000066   0xE04C             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_7:
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable4_6  ;; 0x40020044
   \   0000006E   0x4288             CMP      R0,R1
   \   00000070   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_8
   \   00000072   0xF44F 0x5800      MOV      R8,#+8192
   \   00000076   0xE044             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_8:
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x40020058
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_9
   \   00000082   0xF45F 0x3800      MOVS     R8,#+131072
   \   00000086   0xE03C             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_9:
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable4_8  ;; 0x4002006c
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_10
   \   00000092   0xF45F 0x1800      MOVS     R8,#+2097152
   \   00000096   0xE034             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_10:
   \   00000098   0xF05F 0x7800      MOVS     R8,#+33554432
   \   0000009C   0xE031             B.N      ??HAL_DMA_PollForTransfer_5
    531            }
    532            else
    533            {
    534              /* Half Transfer Complete flag */
    535              temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
   \                     ??HAL_DMA_PollForTransfer_3:
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable4_3  ;; 0x40020008
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_11
   \   000000A8   0xF05F 0x0804      MOVS     R8,#+4
   \   000000AC   0xE029             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_11:
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable4_4  ;; 0x4002001c
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_12
   \   000000B8   0xF05F 0x0840      MOVS     R8,#+64
   \   000000BC   0xE021             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_12:
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable4_5  ;; 0x40020030
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_13
   \   000000C8   0xF44F 0x6880      MOV      R8,#+1024
   \   000000CC   0xE019             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_13:
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable4_6  ;; 0x40020044
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_14
   \   000000D8   0xF44F 0x4880      MOV      R8,#+16384
   \   000000DC   0xE011             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_14:
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x40020058
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_15
   \   000000E8   0xF45F 0x2880      MOVS     R8,#+262144
   \   000000EC   0xE009             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_15:
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable4_8  ;; 0x4002006c
   \   000000F4   0x4288             CMP      R0,R1
   \   000000F6   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_16
   \   000000F8   0xF45F 0x0880      MOVS     R8,#+4194304
   \   000000FC   0xE001             B.N      ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_16:
   \   000000FE   0xF05F 0x6880      MOVS     R8,#+67108864
    536            }
    537          
    538            /* Get tick */
    539            tickstart = HAL_GetTick();
   \                     ??HAL_DMA_PollForTransfer_5:
   \   00000102   0x.... 0x....      BL       HAL_GetTick
   \   00000106   0x0007             MOVS     R7,R0
    540          
    541            while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
   \                     ??HAL_DMA_PollForTransfer_17:
   \   00000108   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020000
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xEA10 0x0F08      TST      R0,R8
   \   00000110   0xD154             BNE.N    ??HAL_DMA_PollForTransfer_18
    542            {
    543              if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
   \   00000112   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40020000
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x6821             LDR      R1,[R4, #+0]
   \   00000118   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40020008
   \   0000011A   0x4291             CMP      R1,R2
   \   0000011C   0xD101             BNE.N    ??HAL_DMA_PollForTransfer_19
   \   0000011E   0x2108             MOVS     R1,#+8
   \   00000120   0xE023             B.N      ??HAL_DMA_PollForTransfer_20
   \                     ??HAL_DMA_PollForTransfer_19:
   \   00000122   0x6821             LDR      R1,[R4, #+0]
   \   00000124   0x....             LDR.N    R2,??DataTable4_4  ;; 0x4002001c
   \   00000126   0x4291             CMP      R1,R2
   \   00000128   0xD101             BNE.N    ??HAL_DMA_PollForTransfer_21
   \   0000012A   0x2180             MOVS     R1,#+128
   \   0000012C   0xE01D             B.N      ??HAL_DMA_PollForTransfer_20
   \                     ??HAL_DMA_PollForTransfer_21:
   \   0000012E   0x6821             LDR      R1,[R4, #+0]
   \   00000130   0x....             LDR.N    R2,??DataTable4_5  ;; 0x40020030
   \   00000132   0x4291             CMP      R1,R2
   \   00000134   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_22
   \   00000136   0xF44F 0x6100      MOV      R1,#+2048
   \   0000013A   0xE016             B.N      ??HAL_DMA_PollForTransfer_20
   \                     ??HAL_DMA_PollForTransfer_22:
   \   0000013C   0x6821             LDR      R1,[R4, #+0]
   \   0000013E   0x....             LDR.N    R2,??DataTable4_6  ;; 0x40020044
   \   00000140   0x4291             CMP      R1,R2
   \   00000142   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_23
   \   00000144   0xF44F 0x4100      MOV      R1,#+32768
   \   00000148   0xE00F             B.N      ??HAL_DMA_PollForTransfer_20
   \                     ??HAL_DMA_PollForTransfer_23:
   \   0000014A   0x6821             LDR      R1,[R4, #+0]
   \   0000014C   0x....             LDR.N    R2,??DataTable4_7  ;; 0x40020058
   \   0000014E   0x4291             CMP      R1,R2
   \   00000150   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_24
   \   00000152   0xF45F 0x2100      MOVS     R1,#+524288
   \   00000156   0xE008             B.N      ??HAL_DMA_PollForTransfer_20
   \                     ??HAL_DMA_PollForTransfer_24:
   \   00000158   0x6821             LDR      R1,[R4, #+0]
   \   0000015A   0x....             LDR.N    R2,??DataTable4_8  ;; 0x4002006c
   \   0000015C   0x4291             CMP      R1,R2
   \   0000015E   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_25
   \   00000160   0xF45F 0x0100      MOVS     R1,#+8388608
   \   00000164   0xE001             B.N      ??HAL_DMA_PollForTransfer_20
   \                     ??HAL_DMA_PollForTransfer_25:
   \   00000166   0xF05F 0x6100      MOVS     R1,#+134217728
   \                     ??HAL_DMA_PollForTransfer_20:
   \   0000016A   0x4208             TST      R0,R1
   \   0000016C   0xD010             BEQ.N    ??HAL_DMA_PollForTransfer_26
    544              {
    545                /* When a DMA transfer error occurs */
    546                /* A hardware clear of its EN bits is performed */
    547                /* Clear all flags */
    548                hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0x6C21             LDR      R1,[R4, #+64]
   \   00000172   0x4088             LSLS     R0,R0,R1
   \   00000174   0x6BE1             LDR      R1,[R4, #+60]
   \   00000176   0x6048             STR      R0,[R1, #+4]
    549          
    550                /* Update error code */
    551                SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
   \   00000178   0x6BA0             LDR      R0,[R4, #+56]
   \   0000017A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000017E   0x63A0             STR      R0,[R4, #+56]
    552          
    553                /* Change the DMA state */
    554                hdma->State= HAL_DMA_STATE_READY;
   \   00000180   0x2001             MOVS     R0,#+1
   \   00000182   0xF884 0x0021      STRB     R0,[R4, #+33]
    555          
    556                /* Process Unlocked */
    557                __HAL_UNLOCK(hdma);
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0xF884 0x0020      STRB     R0,[R4, #+32]
    558          
    559                return HAL_ERROR;
   \   0000018C   0x2001             MOVS     R0,#+1
   \   0000018E   0xE077             B.N      ??HAL_DMA_PollForTransfer_1
    560              }
    561              /* Check for the Timeout */
    562              if(Timeout != HAL_MAX_DELAY)
   \                     ??HAL_DMA_PollForTransfer_26:
   \   00000190   0xF116 0x0F01      CMN      R6,#+1
   \   00000194   0xD0B8             BEQ.N    ??HAL_DMA_PollForTransfer_17
    563              {
    564                if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
   \   00000196   0x2E00             CMP      R6,#+0
   \   00000198   0xD004             BEQ.N    ??HAL_DMA_PollForTransfer_27
   \   0000019A   0x.... 0x....      BL       HAL_GetTick
   \   0000019E   0x1BC0             SUBS     R0,R0,R7
   \   000001A0   0x4286             CMP      R6,R0
   \   000001A2   0xD2B1             BCS.N    ??HAL_DMA_PollForTransfer_17
    565                {
    566                  /* Update error code */
    567                  SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TIMEOUT);
   \                     ??HAL_DMA_PollForTransfer_27:
   \   000001A4   0x6BA0             LDR      R0,[R4, #+56]
   \   000001A6   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000001AA   0x63A0             STR      R0,[R4, #+56]
    568          
    569                  /* Change the DMA state */
    570                  hdma->State = HAL_DMA_STATE_READY;
   \   000001AC   0x2001             MOVS     R0,#+1
   \   000001AE   0xF884 0x0021      STRB     R0,[R4, #+33]
    571          
    572                  /* Process Unlocked */
    573                  __HAL_UNLOCK(hdma);
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0xF884 0x0020      STRB     R0,[R4, #+32]
    574          
    575                  return HAL_ERROR;
   \   000001B8   0x2001             MOVS     R0,#+1
   \   000001BA   0xE061             B.N      ??HAL_DMA_PollForTransfer_1
    576                }
    577              }
    578            }
    579          
    580            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_18:
   \   000001BC   0x2D00             CMP      R5,#+0
   \   000001BE   0xD12F             BNE.N    ??HAL_DMA_PollForTransfer_28
    581            {
    582              /* Clear the transfer complete flag */
    583              __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
   \   000001C0   0x6820             LDR      R0,[R4, #+0]
   \   000001C2   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40020008
   \   000001C4   0x4288             CMP      R0,R1
   \   000001C6   0xD101             BNE.N    ??HAL_DMA_PollForTransfer_29
   \   000001C8   0x2002             MOVS     R0,#+2
   \   000001CA   0xE023             B.N      ??HAL_DMA_PollForTransfer_30
   \                     ??HAL_DMA_PollForTransfer_29:
   \   000001CC   0x6820             LDR      R0,[R4, #+0]
   \   000001CE   0x....             LDR.N    R1,??DataTable4_4  ;; 0x4002001c
   \   000001D0   0x4288             CMP      R0,R1
   \   000001D2   0xD101             BNE.N    ??HAL_DMA_PollForTransfer_31
   \   000001D4   0x2020             MOVS     R0,#+32
   \   000001D6   0xE01D             B.N      ??HAL_DMA_PollForTransfer_30
   \                     ??HAL_DMA_PollForTransfer_31:
   \   000001D8   0x6820             LDR      R0,[R4, #+0]
   \   000001DA   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40020030
   \   000001DC   0x4288             CMP      R0,R1
   \   000001DE   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_32
   \   000001E0   0xF44F 0x7000      MOV      R0,#+512
   \   000001E4   0xE016             B.N      ??HAL_DMA_PollForTransfer_30
   \                     ??HAL_DMA_PollForTransfer_32:
   \   000001E6   0x6820             LDR      R0,[R4, #+0]
   \   000001E8   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40020044
   \   000001EA   0x4288             CMP      R0,R1
   \   000001EC   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_33
   \   000001EE   0xF44F 0x5000      MOV      R0,#+8192
   \   000001F2   0xE00F             B.N      ??HAL_DMA_PollForTransfer_30
   \                     ??HAL_DMA_PollForTransfer_33:
   \   000001F4   0x6820             LDR      R0,[R4, #+0]
   \   000001F6   0x....             LDR.N    R1,??DataTable4_7  ;; 0x40020058
   \   000001F8   0x4288             CMP      R0,R1
   \   000001FA   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_34
   \   000001FC   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000200   0xE008             B.N      ??HAL_DMA_PollForTransfer_30
   \                     ??HAL_DMA_PollForTransfer_34:
   \   00000202   0x6820             LDR      R0,[R4, #+0]
   \   00000204   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4002006c
   \   00000206   0x4288             CMP      R0,R1
   \   00000208   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_35
   \   0000020A   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000020E   0xE001             B.N      ??HAL_DMA_PollForTransfer_30
   \                     ??HAL_DMA_PollForTransfer_35:
   \   00000210   0xF05F 0x7000      MOVS     R0,#+33554432
   \                     ??HAL_DMA_PollForTransfer_30:
   \   00000214   0x....             LDR.N    R1,??DataTable4_9  ;; 0x40020004
   \   00000216   0x6008             STR      R0,[R1, #+0]
    584          
    585              /* The selected Channelx EN bit is cleared (DMA is disabled and
    586              all transfers are complete) */
    587              hdma->State = HAL_DMA_STATE_READY;
   \   00000218   0x2001             MOVS     R0,#+1
   \   0000021A   0xF884 0x0021      STRB     R0,[R4, #+33]
   \   0000021E   0xE02B             B.N      ??HAL_DMA_PollForTransfer_36
    588            }
    589            else
    590            {
    591              /* Clear the half transfer complete flag */
    592              __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
   \                     ??HAL_DMA_PollForTransfer_28:
   \   00000220   0x6820             LDR      R0,[R4, #+0]
   \   00000222   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40020008
   \   00000224   0x4288             CMP      R0,R1
   \   00000226   0xD101             BNE.N    ??HAL_DMA_PollForTransfer_37
   \   00000228   0x2004             MOVS     R0,#+4
   \   0000022A   0xE023             B.N      ??HAL_DMA_PollForTransfer_38
   \                     ??HAL_DMA_PollForTransfer_37:
   \   0000022C   0x6820             LDR      R0,[R4, #+0]
   \   0000022E   0x....             LDR.N    R1,??DataTable4_4  ;; 0x4002001c
   \   00000230   0x4288             CMP      R0,R1
   \   00000232   0xD101             BNE.N    ??HAL_DMA_PollForTransfer_39
   \   00000234   0x2040             MOVS     R0,#+64
   \   00000236   0xE01D             B.N      ??HAL_DMA_PollForTransfer_38
   \                     ??HAL_DMA_PollForTransfer_39:
   \   00000238   0x6820             LDR      R0,[R4, #+0]
   \   0000023A   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40020030
   \   0000023C   0x4288             CMP      R0,R1
   \   0000023E   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_40
   \   00000240   0xF44F 0x6080      MOV      R0,#+1024
   \   00000244   0xE016             B.N      ??HAL_DMA_PollForTransfer_38
   \                     ??HAL_DMA_PollForTransfer_40:
   \   00000246   0x6820             LDR      R0,[R4, #+0]
   \   00000248   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40020044
   \   0000024A   0x4288             CMP      R0,R1
   \   0000024C   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_41
   \   0000024E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000252   0xE00F             B.N      ??HAL_DMA_PollForTransfer_38
   \                     ??HAL_DMA_PollForTransfer_41:
   \   00000254   0x6820             LDR      R0,[R4, #+0]
   \   00000256   0x....             LDR.N    R1,??DataTable4_7  ;; 0x40020058
   \   00000258   0x4288             CMP      R0,R1
   \   0000025A   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_42
   \   0000025C   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000260   0xE008             B.N      ??HAL_DMA_PollForTransfer_38
   \                     ??HAL_DMA_PollForTransfer_42:
   \   00000262   0x6820             LDR      R0,[R4, #+0]
   \   00000264   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4002006c
   \   00000266   0x4288             CMP      R0,R1
   \   00000268   0xD102             BNE.N    ??HAL_DMA_PollForTransfer_43
   \   0000026A   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000026E   0xE001             B.N      ??HAL_DMA_PollForTransfer_38
   \                     ??HAL_DMA_PollForTransfer_43:
   \   00000270   0xF05F 0x6080      MOVS     R0,#+67108864
   \                     ??HAL_DMA_PollForTransfer_38:
   \   00000274   0x....             LDR.N    R1,??DataTable4_9  ;; 0x40020004
   \   00000276   0x6008             STR      R0,[R1, #+0]
    593            }
    594            
    595            /* Process unlocked */
    596            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_PollForTransfer_36:
   \   00000278   0x2000             MOVS     R0,#+0
   \   0000027A   0xF884 0x0020      STRB     R0,[R4, #+32]
    597          
    598            return HAL_OK;
   \   0000027E   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_PollForTransfer_1:
   \   00000280   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    599          }
    600          
    601          /**
    602            * @brief  Handles DMA interrupt request.
    603            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    604            *               the configuration information for the specified DMA Channel.  
    605            * @retval None
    606            */

   \                                 In section .text, align 2, keep-with-next
    607          void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
    608          {
   \                     HAL_DMA_IRQHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
    609            uint32_t flag_it = hdma->DmaBaseAddress->ISR;
   \   00000002   0x6BC1             LDR      R1,[R0, #+60]
   \   00000004   0x6809             LDR      R1,[R1, #+0]
    610            uint32_t source_it = hdma->Instance->CCR;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x6812             LDR      R2,[R2, #+0]
    611            
    612            /* Half Transfer Complete Interrupt management ******************************/
    613            if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
   \   0000000A   0x2304             MOVS     R3,#+4
   \   0000000C   0x6C04             LDR      R4,[R0, #+64]
   \   0000000E   0x40A3             LSLS     R3,R3,R4
   \   00000010   0x4219             TST      R1,R3
   \   00000012   0xD03E             BEQ.N    ??HAL_DMA_IRQHandler_0
   \   00000014   0x0013             MOVS     R3,R2
   \   00000016   0x075B             LSLS     R3,R3,#+29
   \   00000018   0xD53B             BPL.N    ??HAL_DMA_IRQHandler_0
    614            {
    615              /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    616              if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD405             BMI.N    ??HAL_DMA_IRQHandler_1
    617              {
    618                /* Disable the half transfer interrupt */
    619                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0xF031 0x0104      BICS     R1,R1,#0x4
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x6011             STR      R1,[R2, #+0]
    620              }
    621              /* Clear the half transfer complete flag */
    622              __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
   \                     ??HAL_DMA_IRQHandler_1:
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40020008
   \   00000032   0x4291             CMP      R1,R2
   \   00000034   0xD101             BNE.N    ??HAL_DMA_IRQHandler_2
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0xE023             B.N      ??HAL_DMA_IRQHandler_3
   \                     ??HAL_DMA_IRQHandler_2:
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x....             LDR.N    R2,??DataTable4_4  ;; 0x4002001c
   \   0000003E   0x4291             CMP      R1,R2
   \   00000040   0xD101             BNE.N    ??HAL_DMA_IRQHandler_4
   \   00000042   0x2140             MOVS     R1,#+64
   \   00000044   0xE01D             B.N      ??HAL_DMA_IRQHandler_3
   \                     ??HAL_DMA_IRQHandler_4:
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x....             LDR.N    R2,??DataTable4_5  ;; 0x40020030
   \   0000004A   0x4291             CMP      R1,R2
   \   0000004C   0xD102             BNE.N    ??HAL_DMA_IRQHandler_5
   \   0000004E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000052   0xE016             B.N      ??HAL_DMA_IRQHandler_3
   \                     ??HAL_DMA_IRQHandler_5:
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x....             LDR.N    R2,??DataTable4_6  ;; 0x40020044
   \   00000058   0x4291             CMP      R1,R2
   \   0000005A   0xD102             BNE.N    ??HAL_DMA_IRQHandler_6
   \   0000005C   0xF44F 0x4180      MOV      R1,#+16384
   \   00000060   0xE00F             B.N      ??HAL_DMA_IRQHandler_3
   \                     ??HAL_DMA_IRQHandler_6:
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0x....             LDR.N    R2,??DataTable4_7  ;; 0x40020058
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xD102             BNE.N    ??HAL_DMA_IRQHandler_7
   \   0000006A   0xF45F 0x2180      MOVS     R1,#+262144
   \   0000006E   0xE008             B.N      ??HAL_DMA_IRQHandler_3
   \                     ??HAL_DMA_IRQHandler_7:
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x....             LDR.N    R2,??DataTable4_8  ;; 0x4002006c
   \   00000074   0x4291             CMP      R1,R2
   \   00000076   0xD102             BNE.N    ??HAL_DMA_IRQHandler_8
   \   00000078   0xF45F 0x0180      MOVS     R1,#+4194304
   \   0000007C   0xE001             B.N      ??HAL_DMA_IRQHandler_3
   \                     ??HAL_DMA_IRQHandler_8:
   \   0000007E   0xF05F 0x6180      MOVS     R1,#+67108864
   \                     ??HAL_DMA_IRQHandler_3:
   \   00000082   0x....             LDR.N    R2,??DataTable4_9  ;; 0x40020004
   \   00000084   0x6011             STR      R1,[R2, #+0]
    623          
    624              /* DMA peripheral state is not updated in Half Transfer */
    625              /* but in Transfer Complete case */
    626          
    627              if(hdma->XferHalfCpltCallback != NULL)
   \   00000086   0x6AC1             LDR      R1,[R0, #+44]
   \   00000088   0x2900             CMP      R1,#+0
   \   0000008A   0xD06B             BEQ.N    ??HAL_DMA_IRQHandler_9
    628              {
    629                /* Half transfer callback */
    630                hdma->XferHalfCpltCallback(hdma);
   \   0000008C   0x6AC1             LDR      R1,[R0, #+44]
   \   0000008E   0x4788             BLX      R1
   \   00000090   0xE068             B.N      ??HAL_DMA_IRQHandler_9
    631              }
    632            }
    633          
    634            /* Transfer Complete Interrupt management ***********************************/
    635            else if (((flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_TC) != RESET))
   \                     ??HAL_DMA_IRQHandler_0:
   \   00000092   0x2302             MOVS     R3,#+2
   \   00000094   0x6C04             LDR      R4,[R0, #+64]
   \   00000096   0x40A3             LSLS     R3,R3,R4
   \   00000098   0x4219             TST      R1,R3
   \   0000009A   0xD044             BEQ.N    ??HAL_DMA_IRQHandler_10
   \   0000009C   0x0013             MOVS     R3,R2
   \   0000009E   0x079B             LSLS     R3,R3,#+30
   \   000000A0   0xD541             BPL.N    ??HAL_DMA_IRQHandler_10
    636            {
    637              if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
   \   000000A2   0x6801             LDR      R1,[R0, #+0]
   \   000000A4   0x6809             LDR      R1,[R1, #+0]
   \   000000A6   0x0689             LSLS     R1,R1,#+26
   \   000000A8   0xD408             BMI.N    ??HAL_DMA_IRQHandler_11
    638              {
    639                /* Disable the transfer complete and error interrupt */
    640                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);  
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0xF031 0x010A      BICS     R1,R1,#0xA
   \   000000B2   0x6802             LDR      R2,[R0, #+0]
   \   000000B4   0x6011             STR      R1,[R2, #+0]
    641          
    642                /* Change the DMA state */
    643                hdma->State = HAL_DMA_STATE_READY;
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0xF880 0x1021      STRB     R1,[R0, #+33]
    644              }
    645              /* Clear the transfer complete flag */
    646                __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
   \                     ??HAL_DMA_IRQHandler_11:
   \   000000BC   0x6801             LDR      R1,[R0, #+0]
   \   000000BE   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40020008
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0xD101             BNE.N    ??HAL_DMA_IRQHandler_12
   \   000000C4   0x2102             MOVS     R1,#+2
   \   000000C6   0xE023             B.N      ??HAL_DMA_IRQHandler_13
   \                     ??HAL_DMA_IRQHandler_12:
   \   000000C8   0x6801             LDR      R1,[R0, #+0]
   \   000000CA   0x....             LDR.N    R2,??DataTable4_4  ;; 0x4002001c
   \   000000CC   0x4291             CMP      R1,R2
   \   000000CE   0xD101             BNE.N    ??HAL_DMA_IRQHandler_14
   \   000000D0   0x2120             MOVS     R1,#+32
   \   000000D2   0xE01D             B.N      ??HAL_DMA_IRQHandler_13
   \                     ??HAL_DMA_IRQHandler_14:
   \   000000D4   0x6801             LDR      R1,[R0, #+0]
   \   000000D6   0x....             LDR.N    R2,??DataTable4_5  ;; 0x40020030
   \   000000D8   0x4291             CMP      R1,R2
   \   000000DA   0xD102             BNE.N    ??HAL_DMA_IRQHandler_15
   \   000000DC   0xF44F 0x7100      MOV      R1,#+512
   \   000000E0   0xE016             B.N      ??HAL_DMA_IRQHandler_13
   \                     ??HAL_DMA_IRQHandler_15:
   \   000000E2   0x6801             LDR      R1,[R0, #+0]
   \   000000E4   0x....             LDR.N    R2,??DataTable4_6  ;; 0x40020044
   \   000000E6   0x4291             CMP      R1,R2
   \   000000E8   0xD102             BNE.N    ??HAL_DMA_IRQHandler_16
   \   000000EA   0xF44F 0x5100      MOV      R1,#+8192
   \   000000EE   0xE00F             B.N      ??HAL_DMA_IRQHandler_13
   \                     ??HAL_DMA_IRQHandler_16:
   \   000000F0   0x6801             LDR      R1,[R0, #+0]
   \   000000F2   0x....             LDR.N    R2,??DataTable4_7  ;; 0x40020058
   \   000000F4   0x4291             CMP      R1,R2
   \   000000F6   0xD102             BNE.N    ??HAL_DMA_IRQHandler_17
   \   000000F8   0xF45F 0x3100      MOVS     R1,#+131072
   \   000000FC   0xE008             B.N      ??HAL_DMA_IRQHandler_13
   \                     ??HAL_DMA_IRQHandler_17:
   \   000000FE   0x6801             LDR      R1,[R0, #+0]
   \   00000100   0x....             LDR.N    R2,??DataTable4_8  ;; 0x4002006c
   \   00000102   0x4291             CMP      R1,R2
   \   00000104   0xD102             BNE.N    ??HAL_DMA_IRQHandler_18
   \   00000106   0xF45F 0x1100      MOVS     R1,#+2097152
   \   0000010A   0xE001             B.N      ??HAL_DMA_IRQHandler_13
   \                     ??HAL_DMA_IRQHandler_18:
   \   0000010C   0xF05F 0x7100      MOVS     R1,#+33554432
   \                     ??HAL_DMA_IRQHandler_13:
   \   00000110   0x....             LDR.N    R2,??DataTable4_9  ;; 0x40020004
   \   00000112   0x6011             STR      R1,[R2, #+0]
    647          
    648              /* Process Unlocked */
    649              __HAL_UNLOCK(hdma);
   \   00000114   0x2100             MOVS     R1,#+0
   \   00000116   0xF880 0x1020      STRB     R1,[R0, #+32]
    650          
    651              if(hdma->XferCpltCallback != NULL)
   \   0000011A   0x6A81             LDR      R1,[R0, #+40]
   \   0000011C   0x2900             CMP      R1,#+0
   \   0000011E   0xD021             BEQ.N    ??HAL_DMA_IRQHandler_9
    652              {
    653                /* Transfer complete callback */
    654                hdma->XferCpltCallback(hdma);
   \   00000120   0x6A81             LDR      R1,[R0, #+40]
   \   00000122   0x4788             BLX      R1
   \   00000124   0xE01E             B.N      ??HAL_DMA_IRQHandler_9
    655              }
    656            }
    657          
    658            /* Transfer Error Interrupt management **************************************/
    659            else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
   \                     ??HAL_DMA_IRQHandler_10:
   \   00000126   0x2308             MOVS     R3,#+8
   \   00000128   0x6C04             LDR      R4,[R0, #+64]
   \   0000012A   0x40A3             LSLS     R3,R3,R4
   \   0000012C   0x4219             TST      R1,R3
   \   0000012E   0xD019             BEQ.N    ??HAL_DMA_IRQHandler_9
   \   00000130   0x0711             LSLS     R1,R2,#+28
   \   00000132   0xD517             BPL.N    ??HAL_DMA_IRQHandler_9
    660            {
    661              /* When a DMA transfer error occurs */
    662              /* A hardware clear of its EN bits is performed */
    663              /* Disable ALL DMA IT */
    664              __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
   \   00000134   0x6801             LDR      R1,[R0, #+0]
   \   00000136   0x6809             LDR      R1,[R1, #+0]
   \   00000138   0xF031 0x010E      BICS     R1,R1,#0xE
   \   0000013C   0x6802             LDR      R2,[R0, #+0]
   \   0000013E   0x6011             STR      R1,[R2, #+0]
    665          
    666              /* Clear all flags */
    667              hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
   \   00000140   0x2101             MOVS     R1,#+1
   \   00000142   0x6C02             LDR      R2,[R0, #+64]
   \   00000144   0x4091             LSLS     R1,R1,R2
   \   00000146   0x6BC2             LDR      R2,[R0, #+60]
   \   00000148   0x6051             STR      R1,[R2, #+4]
    668          
    669              /* Update error code */
    670              hdma->ErrorCode = HAL_DMA_ERROR_TE;
   \   0000014A   0x2101             MOVS     R1,#+1
   \   0000014C   0x6381             STR      R1,[R0, #+56]
    671          
    672              /* Change the DMA state */
    673              hdma->State = HAL_DMA_STATE_READY;
   \   0000014E   0x2101             MOVS     R1,#+1
   \   00000150   0xF880 0x1021      STRB     R1,[R0, #+33]
    674          
    675              /* Process Unlocked */
    676              __HAL_UNLOCK(hdma);
   \   00000154   0x2100             MOVS     R1,#+0
   \   00000156   0xF880 0x1020      STRB     R1,[R0, #+32]
    677          
    678              if (hdma->XferErrorCallback != NULL)
   \   0000015A   0x6B01             LDR      R1,[R0, #+48]
   \   0000015C   0x2900             CMP      R1,#+0
   \   0000015E   0xD001             BEQ.N    ??HAL_DMA_IRQHandler_9
    679              {
    680                /* Transfer error callback */
    681                hdma->XferErrorCallback(hdma);
   \   00000160   0x6B01             LDR      R1,[R0, #+48]
   \   00000162   0x4788             BLX      R1
    682              }
    683            }
    684            return;
   \                     ??HAL_DMA_IRQHandler_9:
   \   00000164   0xBD10             POP      {R4,PC}          ;; return
    685          }
    686          
    687          /**
    688            * @brief Register callbacks
    689            * @param hdma: pointer to a DMA_HandleTypeDef structure that contains
    690            *              the configuration information for the specified DMA Channel.
    691            * @param CallbackID: User Callback identifer
    692            *                    a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
    693            * @param pCallback: pointer to private callbacsk function which has pointer to 
    694            *                   a DMA_HandleTypeDef structure as parameter.
    695            * @retval HAL status
    696            */                          

   \                                 In section .text, align 2, keep-with-next
    697          HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)( DMA_HandleTypeDef * _hdma))
    698          {
   \                     HAL_DMA_RegisterCallback:
   \   00000000   0xB410             PUSH     {R4}
    699            HAL_StatusTypeDef status = HAL_OK;
   \   00000002   0x2300             MOVS     R3,#+0
    700            
    701            /* Process locked */
    702            __HAL_LOCK(hdma);
   \   00000004   0xF890 0x4020      LDRB     R4,[R0, #+32]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_DMA_RegisterCallback_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE01F             B.N      ??HAL_DMA_RegisterCallback_1
   \                     ??HAL_DMA_RegisterCallback_0:
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0xF880 0x4020      STRB     R4,[R0, #+32]
    703            
    704            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000016   0xF890 0x4021      LDRB     R4,[R0, #+33]
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD112             BNE.N    ??HAL_DMA_RegisterCallback_2
    705            {
    706              switch (CallbackID)
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD005             BEQ.N    ??HAL_DMA_RegisterCallback_3
   \   00000024   0x2902             CMP      R1,#+2
   \   00000026   0xD007             BEQ.N    ??HAL_DMA_RegisterCallback_4
   \   00000028   0xD304             BCC.N    ??HAL_DMA_RegisterCallback_5
   \   0000002A   0x2903             CMP      R1,#+3
   \   0000002C   0xD006             BEQ.N    ??HAL_DMA_RegisterCallback_6
   \   0000002E   0xE007             B.N      ??HAL_DMA_RegisterCallback_7
    707              {
    708              case  HAL_DMA_XFER_CPLT_CB_ID:
    709                hdma->XferCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_3:
   \   00000030   0x6282             STR      R2,[R0, #+40]
    710                break;
   \   00000032   0xE008             B.N      ??HAL_DMA_RegisterCallback_8
    711                
    712              case  HAL_DMA_XFER_HALFCPLT_CB_ID:
    713                hdma->XferHalfCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_5:
   \   00000034   0x62C2             STR      R2,[R0, #+44]
    714                break;         
   \   00000036   0xE006             B.N      ??HAL_DMA_RegisterCallback_8
    715          
    716              case  HAL_DMA_XFER_ERROR_CB_ID:
    717                hdma->XferErrorCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_4:
   \   00000038   0x6302             STR      R2,[R0, #+48]
    718                break;         
   \   0000003A   0xE004             B.N      ??HAL_DMA_RegisterCallback_8
    719                
    720              case  HAL_DMA_XFER_ABORT_CB_ID:
    721                hdma->XferAbortCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_6:
   \   0000003C   0x6342             STR      R2,[R0, #+52]
    722                break; 
   \   0000003E   0xE002             B.N      ??HAL_DMA_RegisterCallback_8
    723                
    724              default:
    725                status = HAL_ERROR;
   \                     ??HAL_DMA_RegisterCallback_7:
   \   00000040   0x2301             MOVS     R3,#+1
    726                break;                                                            
   \   00000042   0xE000             B.N      ??HAL_DMA_RegisterCallback_8
    727              }
    728            }
    729            else
    730            {
    731              status = HAL_ERROR;
   \                     ??HAL_DMA_RegisterCallback_2:
   \   00000044   0x2301             MOVS     R3,#+1
    732            } 
    733            
    734            /* Release Lock */
    735            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_RegisterCallback_8:
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF880 0x1020      STRB     R1,[R0, #+32]
    736            
    737            return status;
   \   0000004C   0x0018             MOVS     R0,R3
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_DMA_RegisterCallback_1:
   \   00000050   0xBC10             POP      {R4}
   \   00000052   0x4770             BX       LR               ;; return
    738          }
    739          
    740          /**
    741            * @brief UnRegister callbacks
    742            * @param hdma: pointer to a DMA_HandleTypeDef structure that contains
    743            *              the configuration information for the specified DMA Channel.
    744            * @param CallbackID: User Callback identifer
    745            *                    a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
    746            * @retval HAL status
    747            */              

   \                                 In section .text, align 2, keep-with-next
    748          HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
    749          {
   \                     HAL_DMA_UnRegisterCallback:
   \   00000000   0x000A             MOVS     R2,R1
    750            HAL_StatusTypeDef status = HAL_OK;
   \   00000002   0x2100             MOVS     R1,#+0
    751          
    752            /* Process locked */
    753            __HAL_LOCK(hdma);
   \   00000004   0xF890 0x3020      LDRB     R3,[R0, #+32]
   \   00000008   0x2B01             CMP      R3,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_DMA_UnRegisterCallback_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE02D             B.N      ??HAL_DMA_UnRegisterCallback_1
   \                     ??HAL_DMA_UnRegisterCallback_0:
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0xF880 0x3020      STRB     R3,[R0, #+32]
    754            
    755            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000016   0xF890 0x3021      LDRB     R3,[R0, #+33]
   \   0000001A   0x2B01             CMP      R3,#+1
   \   0000001C   0xD120             BNE.N    ??HAL_DMA_UnRegisterCallback_2
    756            {
    757              switch (CallbackID)
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD006             BEQ.N    ??HAL_DMA_UnRegisterCallback_3
   \   00000024   0x2A02             CMP      R2,#+2
   \   00000026   0xD00A             BEQ.N    ??HAL_DMA_UnRegisterCallback_4
   \   00000028   0xD306             BCC.N    ??HAL_DMA_UnRegisterCallback_5
   \   0000002A   0x2A04             CMP      R2,#+4
   \   0000002C   0xD00D             BEQ.N    ??HAL_DMA_UnRegisterCallback_6
   \   0000002E   0xD309             BCC.N    ??HAL_DMA_UnRegisterCallback_7
   \   00000030   0xE014             B.N      ??HAL_DMA_UnRegisterCallback_8
    758              {
    759              case  HAL_DMA_XFER_CPLT_CB_ID:
    760                hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_3:
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x6282             STR      R2,[R0, #+40]
    761                break;
   \   00000036   0xE014             B.N      ??HAL_DMA_UnRegisterCallback_9
    762          
    763              case  HAL_DMA_XFER_HALFCPLT_CB_ID:
    764                hdma->XferHalfCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_5:
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x62C2             STR      R2,[R0, #+44]
    765                break;         
   \   0000003C   0xE011             B.N      ??HAL_DMA_UnRegisterCallback_9
    766          
    767              case  HAL_DMA_XFER_ERROR_CB_ID:
    768                hdma->XferErrorCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_4:
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x6302             STR      R2,[R0, #+48]
    769                break;         
   \   00000042   0xE00E             B.N      ??HAL_DMA_UnRegisterCallback_9
    770          
    771              case  HAL_DMA_XFER_ABORT_CB_ID:
    772                hdma->XferAbortCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_7:
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6342             STR      R2,[R0, #+52]
    773                break; 
   \   00000048   0xE00B             B.N      ??HAL_DMA_UnRegisterCallback_9
    774          
    775              case   HAL_DMA_XFER_ALL_CB_ID:
    776                hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_6:
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x6282             STR      R2,[R0, #+40]
    777                hdma->XferHalfCpltCallback = NULL;
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x62C2             STR      R2,[R0, #+44]
    778                hdma->XferErrorCallback = NULL;
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x6302             STR      R2,[R0, #+48]
    779                hdma->XferAbortCallback = NULL;
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x6342             STR      R2,[R0, #+52]
    780                break; 
   \   0000005A   0xE002             B.N      ??HAL_DMA_UnRegisterCallback_9
    781          
    782              default:
    783                status = HAL_ERROR;
   \                     ??HAL_DMA_UnRegisterCallback_8:
   \   0000005C   0x2101             MOVS     R1,#+1
    784                break;
   \   0000005E   0xE000             B.N      ??HAL_DMA_UnRegisterCallback_9
    785              }
    786            }
    787            else
    788            {
    789              status = HAL_ERROR;
   \                     ??HAL_DMA_UnRegisterCallback_2:
   \   00000060   0x2101             MOVS     R1,#+1
    790            } 
    791            
    792            /* Release Lock */
    793            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_UnRegisterCallback_9:
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0xF880 0x2020      STRB     R2,[R0, #+32]
    794            
    795            return status;
   \   00000068   0x0008             MOVS     R0,R1
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??HAL_DMA_UnRegisterCallback_1:
   \   0000006C   0x4770             BX       LR               ;; return
    796          }
    797            
    798          /**
    799            * @}
    800            */
    801          
    802          /** @defgroup DMA_Exported_Functions_Group3 Peripheral State and Errors functions
    803            *  @brief    Peripheral State and Errors functions
    804            *
    805          @verbatim
    806           ===============================================================================
    807                      ##### Peripheral State and Errors functions #####
    808           ===============================================================================  
    809              [..]
    810              This subsection provides functions allowing to
    811                (+) Check the DMA state
    812                (+) Get error code
    813          
    814          @endverbatim
    815            * @{
    816            */
    817          
    818          /**
    819            * @brief  Return the DMA hande state.
    820            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    821            *               the configuration information for the specified DMA Channel.
    822            * @retval HAL state
    823            */

   \                                 In section .text, align 2, keep-with-next
    824          HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
    825          {
    826            /* Return DMA handle state */
    827            return hdma->State;
   \                     HAL_DMA_GetState:
   \   00000000   0xF890 0x0021      LDRB     R0,[R0, #+33]
   \   00000004   0x4770             BX       LR               ;; return
    828          }
    829          
    830          /**
    831            * @brief  Return the DMA error code.
    832            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
    833            *              the configuration information for the specified DMA Channel.
    834            * @retval DMA Error Code
    835            */

   \                                 In section .text, align 2, keep-with-next
    836          uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
    837          {
    838            return hdma->ErrorCode;
   \                     HAL_DMA_GetError:
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
    839          }
    840          
    841          /**
    842            * @}
    843            */
    844          
    845          /**
    846            * @}
    847            */
    848          
    849          /** @addtogroup DMA_Private_Functions
    850            * @{
    851            */
    852          
    853          /**
    854            * @brief  Sets the DMA Transfer parameter.
    855            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    856            *                     the configuration information for the specified DMA Channel.
    857            * @param  SrcAddress: The source memory Buffer address
    858            * @param  DstAddress: The destination memory Buffer address
    859            * @param  DataLength: The length of data to be transferred from source to destination
    860            * @retval HAL status
    861            */

   \                                 In section .text, align 2, keep-with-next
    862          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    863          {
   \                     DMA_SetConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
    864            /* Clear all flags */
    865            hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
   \   00000002   0x2401             MOVS     R4,#+1
   \   00000004   0x6C05             LDR      R5,[R0, #+64]
   \   00000006   0x40AC             LSLS     R4,R4,R5
   \   00000008   0x6BC5             LDR      R5,[R0, #+60]
   \   0000000A   0x606C             STR      R4,[R5, #+4]
    866          
    867            /* Configure DMA Channel data length */
    868            hdma->Instance->CNDTR = DataLength;
   \   0000000C   0x6804             LDR      R4,[R0, #+0]
   \   0000000E   0x6063             STR      R3,[R4, #+4]
    869          
    870            /* Memory to Peripheral */
    871            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
   \   00000010   0x6843             LDR      R3,[R0, #+4]
   \   00000012   0x2B10             CMP      R3,#+16
   \   00000014   0xD104             BNE.N    ??DMA_SetConfig_0
    872            {
    873              /* Configure DMA Channel destination address */
    874              hdma->Instance->CPAR = DstAddress;
   \   00000016   0x6803             LDR      R3,[R0, #+0]
   \   00000018   0x609A             STR      R2,[R3, #+8]
    875          
    876              /* Configure DMA Channel source address */
    877              hdma->Instance->CMAR = SrcAddress;
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x60C1             STR      R1,[R0, #+12]
   \   0000001E   0xE003             B.N      ??DMA_SetConfig_1
    878            }
    879            /* Peripheral to Memory */
    880            else
    881            {
    882              /* Configure DMA Channel source address */
    883              hdma->Instance->CPAR = SrcAddress;
   \                     ??DMA_SetConfig_0:
   \   00000020   0x6803             LDR      R3,[R0, #+0]
   \   00000022   0x6099             STR      R1,[R3, #+8]
    884          
    885              /* Configure DMA Channel destination address */
    886              hdma->Instance->CMAR = DstAddress;
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x60C2             STR      R2,[R0, #+12]
    887            }
    888          }
   \                     ??DMA_SetConfig_1:
   \   00000028   0xBC30             POP      {R4,R5}
   \   0000002A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xBFFDFFF8         DC32     0xbffdfff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xFFFFC00F         DC32     0xffffc00f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40020008         DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x4002001C         DC32     0x4002001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40020030         DC32     0x40020030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40020044         DC32     0x40020044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x40020058         DC32     0x40020058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x4002006C         DC32     0x4002006c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x40020004         DC32     0x40020004
    889          
    890          /**
    891            * @}
    892            */
    893          
    894          #endif /* HAL_DMA_MODULE_ENABLED */
    895          /**
    896            * @}
    897            */
    898          
    899          /**
    900            * @}
    901            */
    902          
    903          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  DMA_SetConfig
        0  HAL_DMA_Abort
        8  HAL_DMA_Abort_IT
              8 -- Indirect call
        0  HAL_DMA_DeInit
        0  HAL_DMA_GetError
        0  HAL_DMA_GetState
        8  HAL_DMA_IRQHandler
              8 -- Indirect call
        0  HAL_DMA_Init
       24  HAL_DMA_PollForTransfer
             24 -> HAL_GetTick
        4  HAL_DMA_RegisterCallback
       16  HAL_DMA_Start
             16 -> DMA_SetConfig
       16  HAL_DMA_Start_IT
             16 -> DMA_SetConfig
        0  HAL_DMA_UnRegisterCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      44  DMA_SetConfig
      54  HAL_DMA_Abort
     174  HAL_DMA_Abort_IT
      98  HAL_DMA_DeInit
       4  HAL_DMA_GetError
       6  HAL_DMA_GetState
     358  HAL_DMA_IRQHandler
     118  HAL_DMA_Init
     644  HAL_DMA_PollForTransfer
      84  HAL_DMA_RegisterCallback
      88  HAL_DMA_Start
     132  HAL_DMA_Start_IT
     110  HAL_DMA_UnRegisterCallback

 
 1 954 bytes in section .text
 
 1 954 bytes of CODE memory

Errors: none
Warnings: 1
