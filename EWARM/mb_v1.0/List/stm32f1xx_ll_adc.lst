###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     27/Aug/2018  06:16:12 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1 #
#                    xx_HAL_Driver\Src\stm32f1xx_ll_adc.c                     #
#    Command line =  "D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F #
#                    1xx_HAL_Driver\Src\stm32f1xx_ll_adc.c" -D                #
#                    USE_FULL_LL_DRIVER -D USE_HAL_DRIVER -D STM32F103xB -lC  #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/ #
#                    List\" -o "D:\projects\задания от                        #
#                    работодателя\ЭМИС\EWARM\mb_v1.0/Obj\" --no_cse           #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.0\arm\INC\c\DLib_Config_Full.h" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Inc\" #
#                     -I "D:\projects\задания от                              #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc\" -I "D:\projects\задания от                         #
#                    работодателя\ЭМИС\EWARM/../Drivers/STM32F1xx_HAL_Driver/ #
#                    Inc/Legacy\" -I "D:\projects\задания от                  #
#                    работодателя\ЭМИС\EWARM/../Middlewares/Third_Party/FreeR #
#                    TOS/Source/portable/IAR/ARM_CM3\" -I                     #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Device/ST/STM32F1xx/Include\" -I                #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/include\" -I          #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Middl #
#                    ewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\" -I       #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../Drive #
#                    rs/CMSIS/Include\" -I "D:\projects\задания от            #
#                    работодателя\ЭМИС\EWARM/../FreeModbus\" -I               #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus\" -I "D:\projects\задания от                #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/rtu\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/ascii\" -I "D:\projects\задания от          #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/tcp\" -I    #
#                    "D:\projects\задания от работодателя\ЭМИС\EWARM/../FreeM #
#                    odbus/modbus/functions\" -I "D:\projects\задания от      #
#                    работодателя\ЭМИС\EWARM/../FreeModbus/modbus/include\"   #
#                    -I "D:\projects\задания от работодателя\ЭМИС\EWARM/../Fr #
#                    eeModbus/port\" -Ol                                      #
#    List file    =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/L #
#                    ist\stm32f1xx_ll_adc.lst                                 #
#    Object file  =  D:\projects\задания от работодателя\ЭМИС\EWARM\mb_v1.0/O #
#                    bj\stm32f1xx_ll_adc.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

D:\projects\задания от работодателя\ЭМИС\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_ll_adc.c
      1          /**
                   ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2            ******************************************************************************
      3            * @file    stm32f1xx_ll_adc.c
      4            * @author  MCD Application Team
      5            * @brief   ADC LL module driver
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
     10            *
     11            * Redistribution and use in source and binary forms, with or without modification,
     12            * are permitted provided that the following conditions are met:
     13            *   1. Redistributions of source code must retain the above copyright notice,
     14            *      this list of conditions and the following disclaimer.
     15            *   2. Redistributions in binary form must reproduce the above copyright notice,
     16            *      this list of conditions and the following disclaimer in the documentation
     17            *      and/or other materials provided with the distribution.
     18            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     19            *      may be used to endorse or promote products derived from this software
     20            *      without specific prior written permission.
     21            *
     22            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     23            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     24            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     25            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     26            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     27            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     28            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     29            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     30            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     31            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     32            *
     33            ******************************************************************************
     34            */
     35          #if defined(USE_FULL_LL_DRIVER)
     36          
     37          /* Includes ------------------------------------------------------------------*/
     38          #include "stm32f1xx_ll_adc.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_APB2_GRP1_ForceReset(uint32_t)
   \                     LL_APB2_GRP1_ForceReset:
   \   00000000   0x....             LDR.N    R1,??DataTable4  ;; 0x4002100c
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x4308             ORRS     R0,R0,R1
   \   00000006   0x....             LDR.N    R1,??DataTable4  ;; 0x4002100c
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_APB2_GRP1_ReleaseReset(uint32_t)
   \                     LL_APB2_GRP1_ReleaseReset:
   \   00000000   0x....             LDR.N    R1,??DataTable4  ;; 0x4002100c
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0xEA31 0x0000      BICS     R0,R1,R0
   \   00000008   0x....             LDR.N    R1,??DataTable4  ;; 0x4002100c
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_ADC_REG_SetTriggerSource(ADC_TypeDef *, uint32_t)
   \                     LL_ADC_REG_SetTriggerSource:
   \   00000000   0x0C49             LSRS     R1,R1,#+17
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0xF361 0x4253      BFI      R2,R1,#+17,#+3
   \   00000008   0x6082             STR      R2,[R0, #+8]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_ADC_REG_SetSequencerLength(ADC_TypeDef *, uint32_t)
   \                     LL_ADC_REG_SetSequencerLength:
   \   00000000   0x6AC2             LDR      R2,[R0, #+44]
   \   00000002   0xF432 0x0270      BICS     R2,R2,#0xF00000
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x62C1             STR      R1,[R0, #+44]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_ADC_INJ_SetTriggerSource(ADC_TypeDef *, uint32_t)
   \                     LL_ADC_INJ_SetTriggerSource:
   \   00000000   0x0B09             LSRS     R1,R1,#+12
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0xF361 0x320E      BFI      R2,R1,#+12,#+3
   \   00000008   0x6082             STR      R2,[R0, #+8]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_ADC_INJ_SetSequencerLength(ADC_TypeDef *, uint32_t)
   \                     LL_ADC_INJ_SetSequencerLength:
   \   00000000   0x6B82             LDR      R2,[R0, #+56]
   \   00000002   0xF432 0x1240      BICS     R2,R2,#0x300000
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x6381             STR      R1,[R0, #+56]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_ADC_Disable(ADC_TypeDef *)
   \                     LL_ADC_Disable:
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x0849             LSRS     R1,R1,#+1
   \   00000004   0x0049             LSLS     R1,R1,#+1
   \   00000006   0x6081             STR      R1,[R0, #+8]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t LL_ADC_IsEnabled(ADC_TypeDef *)
   \                     LL_ADC_IsEnabled:
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000006   0x4770             BX       LR               ;; return
     39          #include "stm32f1xx_ll_bus.h"
     40          
     41          #ifdef  USE_FULL_ASSERT
     42            #include "stm32_assert.h"
     43          #else
     44            #define assert_param(expr) ((void)0U)
     45          #endif
     46          
     47          /** @addtogroup STM32F1xx_LL_Driver
     48            * @{
     49            */
     50          
     51          #if defined (ADC1) || defined (ADC2) || defined (ADC3)
     52          
     53          /** @addtogroup ADC_LL ADC
     54            * @{
     55            */
     56          
     57          /* Private types -------------------------------------------------------------*/
     58          /* Private variables ---------------------------------------------------------*/
     59          /* Private constants ---------------------------------------------------------*/
     60          /* Private macros ------------------------------------------------------------*/
     61          
     62          /** @addtogroup ADC_LL_Private_Macros
     63            * @{
     64            */
     65          
     66          /* Check of parameters for configuration of ADC hierarchical scope:           */
     67          /* common to several ADC instances.                                           */
     68          /* Check of parameters for configuration of ADC hierarchical scope:           */
     69          /* ADC instance.                                                              */
     70          #define IS_LL_ADC_DATA_ALIGN(__DATA_ALIGN__)                                   \
     71            (   ((__DATA_ALIGN__) == LL_ADC_DATA_ALIGN_RIGHT)                            \
     72             || ((__DATA_ALIGN__) == LL_ADC_DATA_ALIGN_LEFT)                             \
     73            )
     74          
     75          #define IS_LL_ADC_SCAN_SELECTION(__SCAN_SELECTION__)                           \
     76            (   ((__SCAN_SELECTION__) == LL_ADC_SEQ_SCAN_DISABLE)                        \
     77             || ((__SCAN_SELECTION__) == LL_ADC_SEQ_SCAN_ENABLE)                         \
     78            )
     79          
     80          #define IS_LL_ADC_SEQ_SCAN_MODE(__SEQ_SCAN_MODE__)                             \
     81            (   ((__SCAN_MODE__) == LL_ADC_SEQ_SCAN_DISABLE)                             \
     82             || ((__SCAN_MODE__) == LL_ADC_SEQ_SCAN_ENABLE)                              \
     83            )
     84          
     85          /* Check of parameters for configuration of ADC hierarchical scope:           */
     86          /* ADC group regular                                                          */
     87          #if defined(ADC3)
     88          #define IS_LL_ADC_REG_TRIG_SOURCE(__ADC_INSTANCE__, __REG_TRIG_SOURCE__)       \
     89            ((((__ADC_INSTANCE__) == ADC1) || ((__ADC_INSTANCE__) == ADC2))              \
     90              ? (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
     91                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)              \
     92                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1)              \
     93                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2)              \
     94                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2)              \
     95                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO)             \
     96                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH4)              \
     97                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11)           \
     98                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO)             \
     99                )                                                                        \
    100                :                                                                        \
    101                (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                  \
    102                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)              \
    103                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_CH1)              \
    104                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH3)              \
    105                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_CH1)              \
    106                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO_ADC3)        \
    107                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM5_CH1)              \
    108                 || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM5_CH3)              \
    109                )                                                                        \
    110            )
    111          #else
    112          #if defined (STM32F101xE) || defined (STM32F105xC) || defined (STM32F107xC)
    113          #define IS_LL_ADC_REG_TRIG_SOURCE(__REG_TRIG_SOURCE__)                         \
    114            (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                      \
    115             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)                  \
    116             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1)                  \
    117             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2)                  \
    118             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2)                  \
    119             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO)                 \
    120             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH4)                  \
    121             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11)               \
    122             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM8_TRGO)                 \
    123            )
    124          #else
    125          #define IS_LL_ADC_REG_TRIG_SOURCE(__REG_TRIG_SOURCE__)                         \
    126            (   ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_SOFTWARE)                      \
    127             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH3)                  \
    128             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH1)                  \
    129             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM1_CH2)                  \
    130             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM2_CH2)                  \
    131             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM3_TRGO)                 \
    132             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_TIM4_CH4)                  \
    133             || ((__REG_TRIG_SOURCE__) == LL_ADC_REG_TRIG_EXT_EXTI_LINE11)               \
    134            )
    135          #endif
    136          #endif
    137          #define IS_LL_ADC_REG_CONTINUOUS_MODE(__REG_CONTINUOUS_MODE__)                 \
    138            (   ((__REG_CONTINUOUS_MODE__) == LL_ADC_REG_CONV_SINGLE)                    \
    139             || ((__REG_CONTINUOUS_MODE__) == LL_ADC_REG_CONV_CONTINUOUS)                \
    140            )
    141          
    142          #define IS_LL_ADC_REG_DMA_TRANSFER(__REG_DMA_TRANSFER__)                       \
    143            (   ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_NONE)                 \
    144             || ((__REG_DMA_TRANSFER__) == LL_ADC_REG_DMA_TRANSFER_UNLIMITED)            \
    145            )
    146          
    147          #define IS_LL_ADC_REG_SEQ_SCAN_LENGTH(__REG_SEQ_SCAN_LENGTH__)                 \
    148            (   ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_DISABLE)               \
    149             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS)         \
    150             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS)         \
    151             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS)         \
    152             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS)         \
    153             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS)         \
    154             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS)         \
    155             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS)         \
    156             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS)         \
    157             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS)        \
    158             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS)        \
    159             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS)        \
    160             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS)        \
    161             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS)        \
    162             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS)        \
    163             || ((__REG_SEQ_SCAN_LENGTH__) == LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS)        \
    164            )
    165          
    166          #define IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(__REG_SEQ_DISCONT_MODE__)          \
    167            (   ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_DISABLE)           \
    168             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_1RANK)             \
    169             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_2RANKS)            \
    170             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_3RANKS)            \
    171             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_4RANKS)            \
    172             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_5RANKS)            \
    173             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_6RANKS)            \
    174             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_7RANKS)            \
    175             || ((__REG_SEQ_DISCONT_MODE__) == LL_ADC_REG_SEQ_DISCONT_8RANKS)            \
    176            )
    177          
    178          /* Check of parameters for configuration of ADC hierarchical scope:           */
    179          /* ADC group injected                                                         */
    180          #if defined(ADC3)
    181          #define IS_LL_ADC_INJ_TRIG_SOURCE(__ADC_INSTANCE__, __INJ_TRIG_SOURCE__)       \
    182            ((((__ADC_INSTANCE__) == ADC1) || ((__ADC_INSTANCE__) == ADC2))              \
    183              ? (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                  \
    184                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)             \
    185                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)              \
    186                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)             \
    187                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1)              \
    188                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4)              \
    189                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO)             \
    190                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)           \
    191                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4)              \
    192                )                                                                        \
    193                :                                                                        \
    194                (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                  \
    195                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)             \
    196                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)              \
    197                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_CH3)              \
    198                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH2)              \
    199                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4_ADC3)         \
    200                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM5_TRGO)             \
    201                 || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM5_CH4)              \
    202                )                                                                        \
    203            )
    204          #else
    205          #if defined (STM32F101xE) || defined (STM32F105xC) || defined (STM32F107xC)
    206          #define IS_LL_ADC_INJ_TRIG_SOURCE(__INJ_TRIG_SOURCE__)                         \
    207            (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                      \
    208             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)                 \
    209             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)                  \
    210             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)                 \
    211             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1)                  \
    212             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4)                  \
    213             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO)                 \
    214             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)               \
    215             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM8_CH4)                  \
    216            )
    217          #else
    218          #define IS_LL_ADC_INJ_TRIG_SOURCE(__INJ_TRIG_SOURCE__)                         \
    219            (   ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_SOFTWARE)                      \
    220             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_TRGO)                 \
    221             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM1_CH4)                  \
    222             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_TRGO)                 \
    223             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM2_CH1)                  \
    224             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM3_CH4)                  \
    225             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_TIM4_TRGO)                 \
    226             || ((__INJ_TRIG_SOURCE__) == LL_ADC_INJ_TRIG_EXT_EXTI_LINE15)               \
    227            )
    228          #endif
    229          #endif
    230          #define IS_LL_ADC_INJ_TRIG_AUTO(__INJ_TRIG_AUTO__)                             \
    231            (   ((__INJ_TRIG_AUTO__) == LL_ADC_INJ_TRIG_INDEPENDENT)                     \
    232             || ((__INJ_TRIG_AUTO__) == LL_ADC_INJ_TRIG_FROM_GRP_REGULAR)                \
    233            )
    234          
    235          #define IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(__INJ_SEQ_SCAN_LENGTH__)                 \
    236            (   ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_DISABLE)               \
    237             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_2RANKS)         \
    238             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_3RANKS)         \
    239             || ((__INJ_SEQ_SCAN_LENGTH__) == LL_ADC_INJ_SEQ_SCAN_ENABLE_4RANKS)         \
    240            )
    241          
    242          #define IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(__INJ_SEQ_DISCONT_MODE__)          \
    243            (   ((__INJ_SEQ_DISCONT_MODE__) == LL_ADC_INJ_SEQ_DISCONT_DISABLE)           \
    244             || ((__INJ_SEQ_DISCONT_MODE__) == LL_ADC_INJ_SEQ_DISCONT_1RANK)             \
    245            )
    246          
    247          #if defined(ADC_MULTIMODE_SUPPORT)
    248          /* Check of parameters for configuration of ADC hierarchical scope:           */
    249          /* multimode.                                                                 */
    250          #define IS_LL_ADC_MULTI_MODE(__MULTI_MODE__)                                   \
    251            (   ((__MULTI_MODE__) == LL_ADC_MULTI_INDEPENDENT)                           \
    252             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIMULT)                       \
    253             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INTERL_FAST)                  \
    254             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INTERL_SLOW)                  \
    255             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_INJ_SIMULT)                       \
    256             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_INJ_ALTERN)                       \
    257             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM)                  \
    258             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT)                  \
    259             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INTFAST_INJ_SIM)              \
    260             || ((__MULTI_MODE__) == LL_ADC_MULTI_DUAL_REG_INTSLOW_INJ_SIM)              \
    261            )
    262          
    263          #define IS_LL_ADC_MULTI_MASTER_SLAVE(__MULTI_MASTER_SLAVE__)                   \
    264            (   ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_MASTER)                        \
    265             || ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_SLAVE)                         \
    266             || ((__MULTI_MASTER_SLAVE__) == LL_ADC_MULTI_MASTER_SLAVE)                  \
    267            )
    268          
    269          #endif /* ADC_MULTIMODE_SUPPORT */
    270          /**
    271            * @}
    272            */
    273          
    274          
    275          /* Private function prototypes -----------------------------------------------*/
    276          
    277          /* Exported functions --------------------------------------------------------*/
    278          /** @addtogroup ADC_LL_Exported_Functions
    279            * @{
    280            */
    281          
    282          /** @addtogroup ADC_LL_EF_Init
    283            * @{
    284            */
    285          
    286          /**
    287            * @brief  De-initialize registers of all ADC instances belonging to
    288            *         the same ADC common instance to their default reset values.
    289            * @param  ADCxy_COMMON ADC common instance
    290            *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
    291            * @retval An ErrorStatus enumeration value:
    292            *          - SUCCESS: ADC common registers are de-initialized
    293            *          - ERROR: not applicable
    294            */

   \                                 In section .text, align 2, keep-with-next
    295          ErrorStatus LL_ADC_CommonDeInit(ADC_Common_TypeDef *ADCxy_COMMON)
    296          {
   \                     LL_ADC_CommonDeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    297            /* Check the parameters */
    298            assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));
    299            
    300            /* Force reset of ADC clock (core clock) */
    301            LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_ADC1);
   \   00000002   0xF44F 0x7000      MOV      R0,#+512
   \   00000006   0x.... 0x....      BL       LL_APB2_GRP1_ForceReset
    302            
    303            /* Release reset of ADC clock (core clock) */
    304            LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_ADC1);
   \   0000000A   0xF44F 0x7000      MOV      R0,#+512
   \   0000000E   0x.... 0x....      BL       LL_APB2_GRP1_ReleaseReset
    305            
    306            return SUCCESS;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    307          }
    308          
    309          /**
    310            * @brief  Initialize some features of ADC common parameters
    311            *         (all ADC instances belonging to the same ADC common instance)
    312            *         and multimode (for devices with several ADC instances available).
    313            * @note   The setting of ADC common parameters is conditioned to
    314            *         ADC instances state:
    315            *         All ADC instances belonging to the same ADC common instance
    316            *         must be disabled.
    317            * @param  ADCxy_COMMON ADC common instance
    318            *         (can be set directly from CMSIS definition or by using helper macro @ref __LL_ADC_COMMON_INSTANCE() )
    319            * @param  ADC_CommonInitStruct Pointer to a @ref LL_ADC_CommonInitTypeDef structure
    320            * @retval An ErrorStatus enumeration value:
    321            *          - SUCCESS: ADC common registers are initialized
    322            *          - ERROR: ADC common registers are not initialized
    323            */

   \                                 In section .text, align 2, keep-with-next
    324          ErrorStatus LL_ADC_CommonInit(ADC_Common_TypeDef *ADCxy_COMMON, LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)
    325          {
   \                     LL_ADC_CommonInit:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    326            ErrorStatus status = SUCCESS;
   \   00000006   0x2501             MOVS     R5,#+1
    327            
    328            /* Check the parameters */
    329            assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));
    330          #if defined(ADC_MULTIMODE_SUPPORT)
    331            assert_param(IS_LL_ADC_MULTI_MODE(ADC_CommonInitStruct->Multimode));
    332          #endif /* ADC_MULTIMODE_SUPPORT */
    333          
    334            /* Note: Hardware constraint (refer to description of functions             */
    335            /*       "LL_ADC_SetCommonXXX()" and "LL_ADC_SetMultiXXX()"):               */
    336            /*       On this STM32 serie, setting of these features is conditioned to   */
    337            /*       ADC state:                                                         */
    338            /*       All ADC instances of the ADC common group must be disabled.        */
    339            if(__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(ADCxy_COMMON) == 0U)
   \   00000008   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40012400
   \   0000000A   0x.... 0x....      BL       LL_ADC_IsEnabled
   \   0000000E   0x0007             MOVS     R7,R0
   \   00000010   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40012800
   \   00000012   0x.... 0x....      BL       LL_ADC_IsEnabled
   \   00000016   0x4338             ORRS     R0,R0,R7
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10E             BNE.N    ??LL_ADC_CommonInit_0
    340            {
    341              /* Configuration of ADC hierarchical scope:                               */
    342              /*  - common to several ADC                                               */
    343              /*    (all ADC instances belonging to the same ADC common instance)       */
    344              /*  - multimode (if several ADC instances available on the                */
    345              /*    selected device)                                                    */
    346              /*    - Set ADC multimode configuration                                   */
    347              /*    - Set ADC multimode DMA transfer                                    */
    348              /*    - Set ADC multimode: delay between 2 sampling phases                */
    349          #if defined(ADC_MULTIMODE_SUPPORT)
    350              if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)
   \   0000001C   0x6830             LDR      R0,[R6, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD006             BEQ.N    ??LL_ADC_CommonInit_1
    351              {
    352                MODIFY_REG(ADCxy_COMMON->CR1,
    353                           ADC_CR1_DUALMOD,
    354                           ADC_CommonInitStruct->Multimode
    355                          );
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0xF430 0x2070      BICS     R0,R0,#0xF0000
   \   00000028   0x6831             LDR      R1,[R6, #+0]
   \   0000002A   0x4308             ORRS     R0,R1,R0
   \   0000002C   0x6060             STR      R0,[R4, #+4]
   \   0000002E   0xE005             B.N      ??LL_ADC_CommonInit_2
    356              }
    357              else
    358              {
    359                MODIFY_REG(ADCxy_COMMON->CR1,
    360                           ADC_CR1_DUALMOD,
    361                           LL_ADC_MULTI_INDEPENDENT
    362                          );
   \                     ??LL_ADC_CommonInit_1:
   \   00000030   0x6860             LDR      R0,[R4, #+4]
   \   00000032   0xF430 0x2070      BICS     R0,R0,#0xF0000
   \   00000036   0x6060             STR      R0,[R4, #+4]
   \   00000038   0xE000             B.N      ??LL_ADC_CommonInit_2
    363              }
    364          #endif
    365            }
    366            else
    367            {
    368              /* Initialization error: One or several ADC instances belonging to        */
    369              /* the same ADC common instance are not disabled.                         */
    370              status = ERROR;
   \                     ??LL_ADC_CommonInit_0:
   \   0000003A   0x2500             MOVS     R5,#+0
    371            }
    372            
    373            return status;
   \                     ??LL_ADC_CommonInit_2:
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    374          }
    375          
    376          /**
    377            * @brief  Set each @ref LL_ADC_CommonInitTypeDef field to default value.
    378            * @param  ADC_CommonInitStruct Pointer to a @ref LL_ADC_CommonInitTypeDef structure
    379            *                              whose fields will be set to default values.
    380            * @retval None
    381            */

   \                                 In section .text, align 2, keep-with-next
    382          void LL_ADC_CommonStructInit(LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)
    383          {
    384            /* Set ADC_CommonInitStruct fields to default values */
    385            /* Set fields of ADC common */
    386            /* (all ADC instances belonging to the same ADC common instance) */
    387            
    388          #if defined(ADC_MULTIMODE_SUPPORT)
    389            /* Set fields of ADC multimode */
    390            ADC_CommonInitStruct->Multimode             = LL_ADC_MULTI_INDEPENDENT;
   \                     LL_ADC_CommonStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    391          #endif /* ADC_MULTIMODE_SUPPORT */
    392          }
   \   00000004   0x4770             BX       LR               ;; return
    393          
    394          /**
    395            * @brief  De-initialize registers of the selected ADC instance
    396            *         to their default reset values.
    397            * @note   To reset all ADC instances quickly (perform a hard reset),
    398            *         use function @ref LL_ADC_CommonDeInit().
    399            * @param  ADCx ADC instance
    400            * @retval An ErrorStatus enumeration value:
    401            *          - SUCCESS: ADC registers are de-initialized
    402            *          - ERROR: ADC registers are not de-initialized
    403            */

   \                                 In section .text, align 2, keep-with-next
    404          ErrorStatus LL_ADC_DeInit(ADC_TypeDef *ADCx)
    405          {
   \                     LL_ADC_DeInit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    406            ErrorStatus status = SUCCESS;
   \   00000004   0x2501             MOVS     R5,#+1
    407            
    408            /* Check the parameters */
    409            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
    410            
    411            /* Disable ADC instance if not already disabled.                            */
    412            if(LL_ADC_IsEnabled(ADCx) == 1U)
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       LL_ADC_IsEnabled
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD10C             BNE.N    ??LL_ADC_DeInit_0
    413            {
    414              /* Set ADC group regular trigger source to SW start to ensure to not      */
    415              /* have an external trigger event occurring during the conversion stop    */
    416              /* ADC disable process.                                                   */
    417              LL_ADC_REG_SetTriggerSource(ADCx, LL_ADC_REG_TRIG_SOFTWARE);
   \   00000010   0xF45F 0x2160      MOVS     R1,#+917504
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       LL_ADC_REG_SetTriggerSource
    418              
    419              /* Set ADC group injected trigger source to SW start to ensure to not     */
    420              /* have an external trigger event occurring during the conversion stop    */
    421              /* ADC disable process.                                                   */
    422              LL_ADC_INJ_SetTriggerSource(ADCx, LL_ADC_INJ_TRIG_SOFTWARE);
   \   0000001A   0xF44F 0x41E0      MOV      R1,#+28672
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       LL_ADC_INJ_SetTriggerSource
    423              
    424              /* Disable the ADC instance */
    425              LL_ADC_Disable(ADCx);
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       LL_ADC_Disable
    426            }
    427            
    428            /* Check whether ADC state is compliant with expected state */
    429            /* (hardware requirements of bits state to reset registers below) */
    430            if(READ_BIT(ADCx->CR2, ADC_CR2_ADON) == 0U)
   \                     ??LL_ADC_DeInit_0:
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x07C0             LSLS     R0,R0,#+31
   \   0000002E   0xD438             BMI.N    ??LL_ADC_DeInit_1
    431            {
    432              /* ========== Reset ADC registers ========== */
    433              /* Reset register SR */
    434              CLEAR_BIT(ADCx->SR,
    435                        (  LL_ADC_FLAG_STRT
    436                         | LL_ADC_FLAG_JSTRT
    437                         | LL_ADC_FLAG_EOS
    438                         | LL_ADC_FLAG_JEOS
    439                         | LL_ADC_FLAG_AWD1 )
    440                       );
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x0940             LSRS     R0,R0,#+5
   \   00000034   0x0140             LSLS     R0,R0,#+5
   \   00000036   0x6020             STR      R0,[R4, #+0]
    441              
    442              /* Reset register CR1 */
    443            #if defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F105xC) || defined (STM32F107xC) || defined (STM32F103xE) || defined (STM32F103xG)
    444          
    445              CLEAR_BIT(ADCx->CR1,
    446                        (  ADC_CR1_AWDEN   | ADC_CR1_JAWDEN  | ADC_CR1_DUALMOD
    447                         | ADC_CR1_DISCNUM | ADC_CR1_JDISCEN | ADC_CR1_DISCEN
    448                         | ADC_CR1_JAUTO   | ADC_CR1_AWDSGL  | ADC_CR1_SCAN
    449                         | ADC_CR1_JEOCIE  | ADC_CR1_AWDIE   | ADC_CR1_EOCIE
    450                         | ADC_CR1_AWDCH                                     )
    451                       );
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x....             LDR.N    R1,??DataTable4_3  ;; 0xff300000
   \   0000003C   0x4008             ANDS     R0,R1,R0
   \   0000003E   0x6060             STR      R0,[R4, #+4]
    452            #else 
    453          
    454              CLEAR_BIT(ADCx->CR1,
    455                        (  ADC_CR1_AWDEN   | ADC_CR1_JAWDEN  | ADC_CR1_DISCNUM 
    456                         | ADC_CR1_JDISCEN | ADC_CR1_DISCEN  | ADC_CR1_JAUTO
    457                         | ADC_CR1_AWDSGL  | ADC_CR1_SCAN    | ADC_CR1_JEOCIE  
    458                         | ADC_CR1_AWDIE   | ADC_CR1_EOCIE   | ADC_CR1_AWDCH )
    459                       );
    460            #endif
    461              
    462              /* Reset register CR2 */
    463              CLEAR_BIT(ADCx->CR2,
    464                        (  ADC_CR2_TSVREFE
    465                         | ADC_CR2_SWSTART  | ADC_CR2_EXTTRIG  | ADC_CR2_EXTSEL
    466                         | ADC_CR2_JSWSTART | ADC_CR2_JEXTTRIG | ADC_CR2_JEXTSEL
    467                         | ADC_CR2_ALIGN    | ADC_CR2_DMA
    468                         | ADC_CR2_RSTCAL   | ADC_CR2_CAL
    469                         | ADC_CR2_CONT     | ADC_CR2_ADON                      )
    470                       );
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0x....             LDR.N    R1,??DataTable4_4  ;; 0xff0106f0
   \   00000044   0x4008             ANDS     R0,R1,R0
   \   00000046   0x60A0             STR      R0,[R4, #+8]
    471              
    472              /* Reset register SMPR1 */
    473              CLEAR_BIT(ADCx->SMPR1,
    474                        (  ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16
    475                         | ADC_SMPR1_SMP15 | ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13
    476                         | ADC_SMPR1_SMP12 | ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10)
    477                       );
   \   00000048   0x68E0             LDR      R0,[R4, #+12]
   \   0000004A   0xF010 0x407F      ANDS     R0,R0,#0xFF000000
   \   0000004E   0x60E0             STR      R0,[R4, #+12]
    478              
    479              /* Reset register SMPR2 */
    480              CLEAR_BIT(ADCx->SMPR2,
    481                        (  ADC_SMPR2_SMP9
    482                         | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | ADC_SMPR2_SMP6
    483                         | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | ADC_SMPR2_SMP3
    484                         | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | ADC_SMPR2_SMP0)
    485                       );
   \   00000050   0x6920             LDR      R0,[R4, #+16]
   \   00000052   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   00000056   0x6120             STR      R0,[R4, #+16]
    486              
    487              /* Reset register JOFR1 */
    488              CLEAR_BIT(ADCx->JOFR1, ADC_JOFR1_JOFFSET1);
   \   00000058   0x6960             LDR      R0,[R4, #+20]
   \   0000005A   0x0B00             LSRS     R0,R0,#+12
   \   0000005C   0x0300             LSLS     R0,R0,#+12
   \   0000005E   0x6160             STR      R0,[R4, #+20]
    489              /* Reset register JOFR2 */
    490              CLEAR_BIT(ADCx->JOFR2, ADC_JOFR2_JOFFSET2);
   \   00000060   0x69A0             LDR      R0,[R4, #+24]
   \   00000062   0x0B00             LSRS     R0,R0,#+12
   \   00000064   0x0300             LSLS     R0,R0,#+12
   \   00000066   0x61A0             STR      R0,[R4, #+24]
    491              /* Reset register JOFR3 */
    492              CLEAR_BIT(ADCx->JOFR3, ADC_JOFR3_JOFFSET3);
   \   00000068   0x69E0             LDR      R0,[R4, #+28]
   \   0000006A   0x0B00             LSRS     R0,R0,#+12
   \   0000006C   0x0300             LSLS     R0,R0,#+12
   \   0000006E   0x61E0             STR      R0,[R4, #+28]
    493              /* Reset register JOFR4 */
    494              CLEAR_BIT(ADCx->JOFR4, ADC_JOFR4_JOFFSET4);
   \   00000070   0x6A20             LDR      R0,[R4, #+32]
   \   00000072   0x0B00             LSRS     R0,R0,#+12
   \   00000074   0x0300             LSLS     R0,R0,#+12
   \   00000076   0x6220             STR      R0,[R4, #+32]
    495              
    496              /* Reset register HTR */
    497              SET_BIT(ADCx->HTR, ADC_HTR_HT);
   \   00000078   0x6A60             LDR      R0,[R4, #+36]
   \   0000007A   0xF640 0x71FF      MOVW     R1,#+4095
   \   0000007E   0x4308             ORRS     R0,R1,R0
   \   00000080   0x6260             STR      R0,[R4, #+36]
    498              /* Reset register LTR */
    499              CLEAR_BIT(ADCx->LTR, ADC_LTR_LT);
   \   00000082   0x6AA0             LDR      R0,[R4, #+40]
   \   00000084   0x0B00             LSRS     R0,R0,#+12
   \   00000086   0x0300             LSLS     R0,R0,#+12
   \   00000088   0x62A0             STR      R0,[R4, #+40]
    500              
    501              /* Reset register SQR1 */
    502              CLEAR_BIT(ADCx->SQR1,
    503                        (  ADC_SQR1_L
    504                         | ADC_SQR1_SQ16
    505                         | ADC_SQR1_SQ15 | ADC_SQR1_SQ14 | ADC_SQR1_SQ13)
    506                       );
   \   0000008A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000008C   0xF010 0x407F      ANDS     R0,R0,#0xFF000000
   \   00000090   0x62E0             STR      R0,[R4, #+44]
    507                       
    508              /* Reset register SQR2 */
    509              CLEAR_BIT(ADCx->SQR2,
    510                        (  ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10
    511                         | ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7)
    512                       );
   \   00000092   0x6B20             LDR      R0,[R4, #+48]
   \   00000094   0xF010 0x4040      ANDS     R0,R0,#0xC0000000
   \   00000098   0x6320             STR      R0,[R4, #+48]
    513              
    514              
    515              /* Reset register JSQR */
    516              CLEAR_BIT(ADCx->JSQR,
    517                        (  ADC_JSQR_JL
    518                         | ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3
    519                         | ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  )
    520                       );
   \   0000009A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000009C   0x0D80             LSRS     R0,R0,#+22
   \   0000009E   0x0580             LSLS     R0,R0,#+22
   \   000000A0   0x63A0             STR      R0,[R4, #+56]
    521              
    522              /* Reset register DR */
    523              /* bits in access mode read only, no direct reset applicable */
    524              
    525              /* Reset registers JDR1, JDR2, JDR3, JDR4 */
    526              /* bits in access mode read only, no direct reset applicable */
    527              
    528            }
    529            
    530            return status;
   \                     ??LL_ADC_DeInit_1:
   \   000000A2   0x0028             MOVS     R0,R5
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    531          }
    532          
    533          /**
    534            * @brief  Initialize some features of ADC instance.
    535            * @note   These parameters have an impact on ADC scope: ADC instance.
    536            *         Affects both group regular and group injected (availability
    537            *         of ADC group injected depends on STM32 families).
    538            *         Refer to corresponding unitary functions into
    539            *         @ref ADC_LL_EF_Configuration_ADC_Instance .
    540            * @note   The setting of these parameters by function @ref LL_ADC_Init()
    541            *         is conditioned to ADC state:
    542            *         ADC instance must be disabled.
    543            *         This condition is applied to all ADC features, for efficiency
    544            *         and compatibility over all STM32 families. However, the different
    545            *         features can be set under different ADC state conditions
    546            *         (setting possible with ADC enabled without conversion on going,
    547            *         ADC enabled with conversion on going, ...)
    548            *         Each feature can be updated afterwards with a unitary function
    549            *         and potentially with ADC in a different state than disabled,
    550            *         refer to description of each function for setting
    551            *         conditioned to ADC state.
    552            * @note   After using this function, some other features must be configured
    553            *         using LL unitary functions.
    554            *         The minimum configuration remaining to be done is:
    555            *          - Set ADC group regular or group injected sequencer:
    556            *            map channel on the selected sequencer rank.
    557            *            Refer to function @ref LL_ADC_REG_SetSequencerRanks().
    558            *          - Set ADC channel sampling time
    559            *            Refer to function LL_ADC_SetChannelSamplingTime();
    560            * @param  ADCx ADC instance
    561            * @param  ADC_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
    562            * @retval An ErrorStatus enumeration value:
    563            *          - SUCCESS: ADC registers are initialized
    564            *          - ERROR: ADC registers are not initialized
    565            */

   \                                 In section .text, align 2, keep-with-next
    566          ErrorStatus LL_ADC_Init(ADC_TypeDef *ADCx, LL_ADC_InitTypeDef *ADC_InitStruct)
    567          {
   \                     LL_ADC_Init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    568            ErrorStatus status = SUCCESS;
   \   00000006   0x2601             MOVS     R6,#+1
    569            
    570            /* Check the parameters */
    571            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
    572            
    573            assert_param(IS_LL_ADC_DATA_ALIGN(ADC_InitStruct->DataAlignment));
    574            assert_param(IS_LL_ADC_SCAN_SELECTION(ADC_InitStruct->SequencersScanMode));
    575            
    576            /* Note: Hardware constraint (refer to description of this function):       */
    577            /*       ADC instance must be disabled.                                     */
    578            if(LL_ADC_IsEnabled(ADCx) == 0U)
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       LL_ADC_IsEnabled
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD10C             BNE.N    ??LL_ADC_Init_0
    579            {
    580              /* Configuration of ADC hierarchical scope:                               */
    581              /*  - ADC instance                                                        */
    582              /*    - Set ADC conversion data alignment                                 */
    583              MODIFY_REG(ADCx->CR1,
    584                           ADC_CR1_SCAN
    585                        ,
    586                           ADC_InitStruct->SequencersScanMode
    587                        );
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000018   0x6869             LDR      R1,[R5, #+4]
   \   0000001A   0x4308             ORRS     R0,R1,R0
   \   0000001C   0x6060             STR      R0,[R4, #+4]
    588              
    589              MODIFY_REG(ADCx->CR2,
    590                           ADC_CR2_ALIGN
    591                        ,
    592                           ADC_InitStruct->DataAlignment
    593                        );
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000024   0x6829             LDR      R1,[R5, #+0]
   \   00000026   0x4308             ORRS     R0,R1,R0
   \   00000028   0x60A0             STR      R0,[R4, #+8]
   \   0000002A   0xE000             B.N      ??LL_ADC_Init_1
    594          
    595            }
    596            else
    597            {
    598              /* Initialization error: ADC instance is not disabled. */
    599              status = ERROR;
   \                     ??LL_ADC_Init_0:
   \   0000002C   0x2600             MOVS     R6,#+0
    600            }
    601            return status;
   \                     ??LL_ADC_Init_1:
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    602          }
    603          
    604          /**
    605            * @brief  Set each @ref LL_ADC_InitTypeDef field to default value.
    606            * @param  ADC_InitStruct Pointer to a @ref LL_ADC_InitTypeDef structure
    607            *                        whose fields will be set to default values.
    608            * @retval None
    609            */

   \                                 In section .text, align 2, keep-with-next
    610          void LL_ADC_StructInit(LL_ADC_InitTypeDef *ADC_InitStruct)
    611          {
    612            /* Set ADC_InitStruct fields to default values */
    613            /* Set fields of ADC instance */
    614            ADC_InitStruct->DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
   \                     LL_ADC_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    615            
    616            /* Enable scan mode to have a generic behavior with ADC of other            */
    617            /* STM32 families, without this setting available:                          */
    618            /* ADC group regular sequencer and ADC group injected sequencer depend      */
    619            /* only of their own configuration.                                         */
    620            ADC_InitStruct->SequencersScanMode      = LL_ADC_SEQ_SCAN_ENABLE;
   \   00000004   0xF44F 0x7180      MOV      R1,#+256
   \   00000008   0x6041             STR      R1,[R0, #+4]
    621            
    622          }
   \   0000000A   0x4770             BX       LR               ;; return
    623          
    624          /**
    625            * @brief  Initialize some features of ADC group regular.
    626            * @note   These parameters have an impact on ADC scope: ADC group regular.
    627            *         Refer to corresponding unitary functions into
    628            *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular
    629            *         (functions with prefix "REG").
    630            * @note   The setting of these parameters by function @ref LL_ADC_Init()
    631            *         is conditioned to ADC state:
    632            *         ADC instance must be disabled.
    633            *         This condition is applied to all ADC features, for efficiency
    634            *         and compatibility over all STM32 families. However, the different
    635            *         features can be set under different ADC state conditions
    636            *         (setting possible with ADC enabled without conversion on going,
    637            *         ADC enabled with conversion on going, ...)
    638            *         Each feature can be updated afterwards with a unitary function
    639            *         and potentially with ADC in a different state than disabled,
    640            *         refer to description of each function for setting
    641            *         conditioned to ADC state.
    642            * @note   After using this function, other features must be configured
    643            *         using LL unitary functions.
    644            *         The minimum configuration remaining to be done is:
    645            *          - Set ADC group regular or group injected sequencer:
    646            *            map channel on the selected sequencer rank.
    647            *            Refer to function @ref LL_ADC_REG_SetSequencerRanks().
    648            *          - Set ADC channel sampling time
    649            *            Refer to function LL_ADC_SetChannelSamplingTime();
    650            * @param  ADCx ADC instance
    651            * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
    652            * @retval An ErrorStatus enumeration value:
    653            *          - SUCCESS: ADC registers are initialized
    654            *          - ERROR: ADC registers are not initialized
    655            */

   \                                 In section .text, align 2, keep-with-next
    656          ErrorStatus LL_ADC_REG_Init(ADC_TypeDef *ADCx, LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)
    657          {
   \                     LL_ADC_REG_Init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    658            ErrorStatus status = SUCCESS;
   \   00000006   0x2601             MOVS     R6,#+1
    659            
    660            /* Check the parameters */
    661            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
    662          #if defined(ADC3)
    663            assert_param(IS_LL_ADC_REG_TRIG_SOURCE(ADCx, ADC_REG_InitStruct->TriggerSource));
    664          #else
    665            assert_param(IS_LL_ADC_REG_TRIG_SOURCE(ADC_REG_InitStruct->TriggerSource));
    666          #endif
    667            assert_param(IS_LL_ADC_REG_SEQ_SCAN_LENGTH(ADC_REG_InitStruct->SequencerLength));
    668            if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   \   00000008   0x6868             LDR      R0,[R5, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
    669            {
    670              assert_param(IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(ADC_REG_InitStruct->SequencerDiscont));
    671            }
    672            assert_param(IS_LL_ADC_REG_CONTINUOUS_MODE(ADC_REG_InitStruct->ContinuousMode));
    673            assert_param(IS_LL_ADC_REG_DMA_TRANSFER(ADC_REG_InitStruct->DMATransfer));
    674            
    675            /* Note: Hardware constraint (refer to description of this function):       */
    676            /*       ADC instance must be disabled.                                     */
    677            if(LL_ADC_IsEnabled(ADCx) == 0U)
   \                     ??LL_ADC_REG_Init_0:
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       LL_ADC_IsEnabled
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD120             BNE.N    ??LL_ADC_REG_Init_1
    678            {
    679              /* Configuration of ADC hierarchical scope:                               */
    680              /*  - ADC group regular                                                   */
    681              /*    - Set ADC group regular trigger source                              */
    682              /*    - Set ADC group regular sequencer length                            */
    683              /*    - Set ADC group regular sequencer discontinuous mode                */
    684              /*    - Set ADC group regular continuous mode                             */
    685              /*    - Set ADC group regular conversion data transfer: no transfer or    */
    686              /*      transfer by DMA, and DMA requests mode                            */
    687              /* Note: On this STM32 serie, ADC trigger edge is set when starting       */
    688              /*       ADC conversion.                                                  */
    689              /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().      */
    690              if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   \   00000016   0x6868             LDR      R0,[R5, #+4]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD008             BEQ.N    ??LL_ADC_REG_Init_2
    691              {
    692                MODIFY_REG(ADCx->CR1,
    693                             ADC_CR1_DISCEN
    694                           | ADC_CR1_DISCNUM
    695                          ,
    696                             ADC_REG_InitStruct->SequencerLength
    697                           | ADC_REG_InitStruct->SequencerDiscont
    698                          );
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0xF430 0x4068      BICS     R0,R0,#0xE800
   \   00000022   0x6869             LDR      R1,[R5, #+4]
   \   00000024   0x4308             ORRS     R0,R1,R0
   \   00000026   0x68A9             LDR      R1,[R5, #+8]
   \   00000028   0x4308             ORRS     R0,R1,R0
   \   0000002A   0x6060             STR      R0,[R4, #+4]
   \   0000002C   0xE005             B.N      ??LL_ADC_REG_Init_3
    699              }
    700              else
    701              {
    702                MODIFY_REG(ADCx->CR1,
    703                             ADC_CR1_DISCEN
    704                           | ADC_CR1_DISCNUM
    705                          ,
    706                             ADC_REG_InitStruct->SequencerLength
    707                           | LL_ADC_REG_SEQ_DISCONT_DISABLE
    708                          );
   \                     ??LL_ADC_REG_Init_2:
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0xF430 0x4068      BICS     R0,R0,#0xE800
   \   00000034   0x6869             LDR      R1,[R5, #+4]
   \   00000036   0x4308             ORRS     R0,R1,R0
   \   00000038   0x6060             STR      R0,[R4, #+4]
    709              }
    710              
    711              MODIFY_REG(ADCx->CR2,
    712                           ADC_CR2_EXTSEL
    713                         | ADC_CR2_CONT
    714                         | ADC_CR2_DMA
    715                        ,
    716                           ADC_REG_InitStruct->TriggerSource
    717                         | ADC_REG_InitStruct->ContinuousMode
    718                         | ADC_REG_InitStruct->DMATransfer
    719                        );
   \                     ??LL_ADC_REG_Init_3:
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0x....             LDR.N    R1,??DataTable4_5  ;; 0xfff1fefd
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x6829             LDR      R1,[R5, #+0]
   \   00000042   0x4308             ORRS     R0,R1,R0
   \   00000044   0x68E9             LDR      R1,[R5, #+12]
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x6929             LDR      R1,[R5, #+16]
   \   0000004A   0x4308             ORRS     R0,R1,R0
   \   0000004C   0x60A0             STR      R0,[R4, #+8]
    720          
    721              /* Set ADC group regular sequencer length and scan direction */
    722              /* Note: Hardware constraint (refer to description of this function):     */
    723              /* Note: If ADC instance feature scan mode is disabled                    */
    724              /*       (refer to  ADC instance initialization structure                 */
    725              /*       parameter @ref SequencersScanMode                                */
    726              /*       or function @ref LL_ADC_SetSequencersScanMode() ),               */
    727              /*       this parameter is discarded.                                     */
    728              LL_ADC_REG_SetSequencerLength(ADCx, ADC_REG_InitStruct->SequencerLength);
   \   0000004E   0x6869             LDR      R1,[R5, #+4]
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       LL_ADC_REG_SetSequencerLength
   \   00000056   0xE000             B.N      ??LL_ADC_REG_Init_4
    729            }
    730            else
    731            {
    732              /* Initialization error: ADC instance is not disabled. */
    733              status = ERROR;
   \                     ??LL_ADC_REG_Init_1:
   \   00000058   0x2600             MOVS     R6,#+0
    734            }
    735            return status;
   \                     ??LL_ADC_REG_Init_4:
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
    736          }
    737          
    738          /**
    739            * @brief  Set each @ref LL_ADC_REG_InitTypeDef field to default value.
    740            * @param  ADC_REG_InitStruct Pointer to a @ref LL_ADC_REG_InitTypeDef structure
    741            *                            whose fields will be set to default values.
    742            * @retval None
    743            */

   \                                 In section .text, align 2, keep-with-next
    744          void LL_ADC_REG_StructInit(LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)
    745          {
    746            /* Set ADC_REG_InitStruct fields to default values */
    747            /* Set fields of ADC group regular */
    748            /* Note: On this STM32 serie, ADC trigger edge is set when starting         */
    749            /*       ADC conversion.                                                    */
    750            /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().        */
    751            ADC_REG_InitStruct->TriggerSource    = LL_ADC_REG_TRIG_SOFTWARE;
   \                     LL_ADC_REG_StructInit:
   \   00000000   0xF45F 0x2160      MOVS     R1,#+917504
   \   00000004   0x6001             STR      R1,[R0, #+0]
    752            ADC_REG_InitStruct->SequencerLength  = LL_ADC_REG_SEQ_SCAN_DISABLE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6041             STR      R1,[R0, #+4]
    753            ADC_REG_InitStruct->SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    754            ADC_REG_InitStruct->ContinuousMode   = LL_ADC_REG_CONV_SINGLE;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x60C1             STR      R1,[R0, #+12]
    755            ADC_REG_InitStruct->DMATransfer      = LL_ADC_REG_DMA_TRANSFER_NONE;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6101             STR      R1,[R0, #+16]
    756          }
   \   00000016   0x4770             BX       LR               ;; return
    757          
    758          /**
    759            * @brief  Initialize some features of ADC group injected.
    760            * @note   These parameters have an impact on ADC scope: ADC group injected.
    761            *         Refer to corresponding unitary functions into
    762            *         @ref ADC_LL_EF_Configuration_ADC_Group_Regular
    763            *         (functions with prefix "INJ").
    764            * @note   The setting of these parameters by function @ref LL_ADC_Init()
    765            *         is conditioned to ADC state:
    766            *         ADC instance must be disabled.
    767            *         This condition is applied to all ADC features, for efficiency
    768            *         and compatibility over all STM32 families. However, the different
    769            *         features can be set under different ADC state conditions
    770            *         (setting possible with ADC enabled without conversion on going,
    771            *         ADC enabled with conversion on going, ...)
    772            *         Each feature can be updated afterwards with a unitary function
    773            *         and potentially with ADC in a different state than disabled,
    774            *         refer to description of each function for setting
    775            *         conditioned to ADC state.
    776            * @note   After using this function, other features must be configured
    777            *         using LL unitary functions.
    778            *         The minimum configuration remaining to be done is:
    779            *          - Set ADC group injected sequencer:
    780            *            map channel on the selected sequencer rank.
    781            *            Refer to function @ref LL_ADC_INJ_SetSequencerRanks().
    782            *          - Set ADC channel sampling time
    783            *            Refer to function LL_ADC_SetChannelSamplingTime();
    784            * @param  ADCx ADC instance
    785            * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure
    786            * @retval An ErrorStatus enumeration value:
    787            *          - SUCCESS: ADC registers are initialized
    788            *          - ERROR: ADC registers are not initialized
    789            */

   \                                 In section .text, align 2, keep-with-next
    790          ErrorStatus LL_ADC_INJ_Init(ADC_TypeDef *ADCx, LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)
    791          {
   \                     LL_ADC_INJ_Init:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    792            ErrorStatus status = SUCCESS;
   \   00000006   0x2601             MOVS     R6,#+1
    793            
    794            /* Check the parameters */
    795            assert_param(IS_ADC_ALL_INSTANCE(ADCx));
    796          #if defined(ADC3)
    797            assert_param(IS_LL_ADC_INJ_TRIG_SOURCE(ADCx, ADC_INJ_InitStruct->TriggerSource));
    798          #else
    799            assert_param(IS_LL_ADC_INJ_TRIG_SOURCE(ADC_INJ_InitStruct->TriggerSource));
    800          #endif
    801            assert_param(IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(ADC_INJ_InitStruct->SequencerLength));
    802            if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_INJ_SEQ_SCAN_DISABLE)
   \   00000008   0x6868             LDR      R0,[R5, #+4]
   \   0000000A   0x2800             CMP      R0,#+0
    803            {
    804              assert_param(IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(ADC_INJ_InitStruct->SequencerDiscont));
    805            }
    806            assert_param(IS_LL_ADC_INJ_TRIG_AUTO(ADC_INJ_InitStruct->TrigAuto));
    807            
    808            /* Note: Hardware constraint (refer to description of this function):       */
    809            /*       ADC instance must be disabled.                                     */
    810            if(LL_ADC_IsEnabled(ADCx) == 0U)
   \                     ??LL_ADC_INJ_Init_0:
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       LL_ADC_IsEnabled
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD11C             BNE.N    ??LL_ADC_INJ_Init_1
    811            {
    812              /* Configuration of ADC hierarchical scope:                               */
    813              /*  - ADC group injected                                                  */
    814              /*    - Set ADC group injected trigger source                             */
    815              /*    - Set ADC group injected sequencer length                           */
    816              /*    - Set ADC group injected sequencer discontinuous mode               */
    817              /*    - Set ADC group injected conversion trigger: independent or         */
    818              /*      from ADC group regular                                            */
    819              /* Note: On this STM32 serie, ADC trigger edge is set when starting       */
    820              /*       ADC conversion.                                                  */
    821              /*       Refer to function @ref LL_ADC_INJ_StartConversionExtTrig().      */
    822              if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
   \   00000016   0x6868             LDR      R0,[R5, #+4]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD008             BEQ.N    ??LL_ADC_INJ_Init_2
    823              {
    824                MODIFY_REG(ADCx->CR1,
    825                             ADC_CR1_JDISCEN
    826                           | ADC_CR1_JAUTO
    827                          ,
    828                             ADC_INJ_InitStruct->SequencerDiscont
    829                           | ADC_INJ_InitStruct->TrigAuto
    830                          );
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0xF430 0x50A0      BICS     R0,R0,#0x1400
   \   00000022   0x68A9             LDR      R1,[R5, #+8]
   \   00000024   0x4308             ORRS     R0,R1,R0
   \   00000026   0x68E9             LDR      R1,[R5, #+12]
   \   00000028   0x4308             ORRS     R0,R1,R0
   \   0000002A   0x6060             STR      R0,[R4, #+4]
   \   0000002C   0xE005             B.N      ??LL_ADC_INJ_Init_3
    831              }
    832              else
    833              {
    834                MODIFY_REG(ADCx->CR1,
    835                             ADC_CR1_JDISCEN
    836                           | ADC_CR1_JAUTO
    837                          ,
    838                             LL_ADC_REG_SEQ_DISCONT_DISABLE
    839                           | ADC_INJ_InitStruct->TrigAuto
    840                          );
   \                     ??LL_ADC_INJ_Init_2:
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0xF430 0x50A0      BICS     R0,R0,#0x1400
   \   00000034   0x68E9             LDR      R1,[R5, #+12]
   \   00000036   0x4308             ORRS     R0,R1,R0
   \   00000038   0x6060             STR      R0,[R4, #+4]
    841              }
    842              
    843              MODIFY_REG(ADCx->CR2,
    844                         ADC_CR2_JEXTSEL
    845                        ,
    846                         ADC_INJ_InitStruct->TriggerSource
    847                        );
   \                     ??LL_ADC_INJ_Init_3:
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0xF430 0x40E0      BICS     R0,R0,#0x7000
   \   00000040   0x6829             LDR      R1,[R5, #+0]
   \   00000042   0x4308             ORRS     R0,R1,R0
   \   00000044   0x60A0             STR      R0,[R4, #+8]
    848              
    849              /* Note: Hardware constraint (refer to description of this function):     */
    850              /* Note: If ADC instance feature scan mode is disabled                    */
    851              /*       (refer to  ADC instance initialization structure                 */
    852              /*       parameter @ref SequencersScanMode                                */
    853              /*       or function @ref LL_ADC_SetSequencersScanMode() ),               */
    854              /*       this parameter is discarded.                                     */
    855              LL_ADC_INJ_SetSequencerLength(ADCx, ADC_INJ_InitStruct->SequencerLength);
   \   00000046   0x6869             LDR      R1,[R5, #+4]
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       LL_ADC_INJ_SetSequencerLength
   \   0000004E   0xE000             B.N      ??LL_ADC_INJ_Init_4
    856            }
    857            else
    858            {
    859              /* Initialization error: ADC instance is not disabled. */
    860              status = ERROR;
   \                     ??LL_ADC_INJ_Init_1:
   \   00000050   0x2600             MOVS     R6,#+0
    861            }
    862            return status;
   \                     ??LL_ADC_INJ_Init_4:
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    863          }
    864          
    865          /**
    866            * @brief  Set each @ref LL_ADC_INJ_InitTypeDef field to default value.
    867            * @param  ADC_INJ_InitStruct Pointer to a @ref LL_ADC_INJ_InitTypeDef structure
    868            *                            whose fields will be set to default values.
    869            * @retval None
    870            */

   \                                 In section .text, align 2, keep-with-next
    871          void LL_ADC_INJ_StructInit(LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)
    872          {
    873            /* Set ADC_INJ_InitStruct fields to default values */
    874            /* Set fields of ADC group injected */
    875            ADC_INJ_InitStruct->TriggerSource    = LL_ADC_INJ_TRIG_SOFTWARE;
   \                     LL_ADC_INJ_StructInit:
   \   00000000   0xF44F 0x41E0      MOV      R1,#+28672
   \   00000004   0x6001             STR      R1,[R0, #+0]
    876            ADC_INJ_InitStruct->SequencerLength  = LL_ADC_INJ_SEQ_SCAN_DISABLE;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6041             STR      R1,[R0, #+4]
    877            ADC_INJ_InitStruct->SequencerDiscont = LL_ADC_INJ_SEQ_DISCONT_DISABLE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    878            ADC_INJ_InitStruct->TrigAuto         = LL_ADC_INJ_TRIG_INDEPENDENT;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x60C1             STR      R1,[R0, #+12]
    879          }
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x4002100C         DC32     0x4002100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40012800         DC32     0x40012800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0xFF300000         DC32     0xff300000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0xFF0106F0         DC32     0xff0106f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0xFFF1FEFD         DC32     0xfff1fefd
    880          
    881          /**
    882            * @}
    883            */
    884          
    885          /**
    886            * @}
    887            */
    888          
    889          /**
    890            * @}
    891            */
    892          
    893          #endif /* ADC1 || ADC2 || ADC3 */
    894          
    895          /**
    896            * @}
    897            */
    898          
    899          #endif /* USE_FULL_LL_DRIVER */
    900          
    901          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  LL_ADC_CommonDeInit
              8 -> LL_APB2_GRP1_ForceReset
              8 -> LL_APB2_GRP1_ReleaseReset
       24  LL_ADC_CommonInit
             24 -> LL_ADC_IsEnabled
        0  LL_ADC_CommonStructInit
       16  LL_ADC_DeInit
             16 -> LL_ADC_Disable
             16 -> LL_ADC_INJ_SetTriggerSource
             16 -> LL_ADC_IsEnabled
             16 -> LL_ADC_REG_SetTriggerSource
        0  LL_ADC_Disable
       16  LL_ADC_INJ_Init
             16 -> LL_ADC_INJ_SetSequencerLength
             16 -> LL_ADC_IsEnabled
        0  LL_ADC_INJ_SetSequencerLength
        0  LL_ADC_INJ_SetTriggerSource
        0  LL_ADC_INJ_StructInit
       16  LL_ADC_Init
             16 -> LL_ADC_IsEnabled
        0  LL_ADC_IsEnabled
       16  LL_ADC_REG_Init
             16 -> LL_ADC_IsEnabled
             16 -> LL_ADC_REG_SetSequencerLength
        0  LL_ADC_REG_SetSequencerLength
        0  LL_ADC_REG_SetTriggerSource
        0  LL_ADC_REG_StructInit
        0  LL_ADC_StructInit
        0  LL_APB2_GRP1_ForceReset
        0  LL_APB2_GRP1_ReleaseReset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
      22  LL_ADC_CommonDeInit
      66  LL_ADC_CommonInit
       6  LL_ADC_CommonStructInit
     168  LL_ADC_DeInit
      10  LL_ADC_Disable
      88  LL_ADC_INJ_Init
      12  LL_ADC_INJ_SetSequencerLength
      12  LL_ADC_INJ_SetTriggerSource
      20  LL_ADC_INJ_StructInit
      52  LL_ADC_Init
       8  LL_ADC_IsEnabled
      96  LL_ADC_REG_Init
      12  LL_ADC_REG_SetSequencerLength
      12  LL_ADC_REG_SetTriggerSource
      24  LL_ADC_REG_StructInit
      12  LL_ADC_StructInit
      12  LL_APB2_GRP1_ForceReset
      14  LL_APB2_GRP1_ReleaseReset

 
 670 bytes in section .text
 
 670 bytes of CODE memory

Errors: none
Warnings: 1
